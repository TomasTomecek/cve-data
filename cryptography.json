[
  {
    "patch": "diff --git a/src/cryptography/hazmat/backends/openssl/ciphers.py b/src/cryptography/hazmat/backends/openssl/ciphers.py\nindex 2b10681b3..0f96795fd 100644\n--- a/src/cryptography/hazmat/backends/openssl/ciphers.py\n+++ b/src/cryptography/hazmat/backends/openssl/ciphers.py\n@@ -16,7 +16,7 @@ from cryptography.hazmat.primitives.ciphers import modes\n class _CipherContext(object):\n     _ENCRYPT = 1\n     _DECRYPT = 0\n-    _MAX_CHUNK_SIZE = 2 ** 31 - 1\n+    _MAX_CHUNK_SIZE = 2 ** 30 - 1\n \n     def __init__(self, backend, cipher, mode, operation):\n         self._backend = backend\n",
    "commit_message": "port changelog and fix back to master for CVE-2020-36242 (#5748)\n\n\n",
    "code_before": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nfrom cryptography import utils\nfrom cryptography.exceptions import InvalidTag, UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.primitives import ciphers\nfrom cryptography.hazmat.primitives.ciphers import modes\n\n\n@utils.register_interface(ciphers.CipherContext)\n@utils.register_interface(ciphers.AEADCipherContext)\n@utils.register_interface(ciphers.AEADEncryptionContext)\n@utils.register_interface(ciphers.AEADDecryptionContext)\nclass _CipherContext(object):\n    _ENCRYPT = 1\n    _DECRYPT = 0\n    _MAX_CHUNK_SIZE = 2 ** 31 - 1\n\n    def __init__(self, backend, cipher, mode, operation):\n        self._backend = backend\n        self._cipher = cipher\n        self._mode = mode\n        self._operation = operation\n        self._tag = None\n\n        if isinstance(self._cipher, ciphers.BlockCipherAlgorithm):\n            self._block_size_bytes = self._cipher.block_size // 8\n        else:\n            self._block_size_bytes = 1\n\n        ctx = self._backend._lib.EVP_CIPHER_CTX_new()\n        ctx = self._backend._ffi.gc(\n            ctx, self._backend._lib.EVP_CIPHER_CTX_free\n        )\n\n        registry = self._backend._cipher_registry\n        try:\n            adapter = registry[type(cipher), type(mode)]\n        except KeyError:\n            raise UnsupportedAlgorithm(\n                \"cipher {} in {} mode is not supported \"\n                \"by this backend.\".format(\n                    cipher.name, mode.name if mode else mode\n                ),\n                _Reasons.UNSUPPORTED_CIPHER,\n            )\n\n        evp_cipher = adapter(self._backend, cipher, mode)\n        if evp_cipher == self._backend._ffi.NULL:\n            msg = \"cipher {0.name} \".format(cipher)\n            if mode is not None:\n                msg += \"in {0.name} mode \".format(mode)\n            msg += (\n                \"is not supported by this backend (Your version of OpenSSL \"\n                \"may be too old. Current version: {}.)\"\n            ).format(self._backend.openssl_version_text())\n            raise UnsupportedAlgorithm(msg, _Reasons.UNSUPPORTED_CIPHER)\n\n        if isinstance(mode, modes.ModeWithInitializationVector):\n            iv_nonce = self._backend._ffi.from_buffer(\n                mode.initialization_vector\n            )\n        elif isinstance(mode, modes.ModeWithTweak):\n            iv_nonce = self._backend._ffi.from_buffer(mode.tweak)\n        elif isinstance(mode, modes.ModeWithNonce):\n            iv_nonce = self._backend._ffi.from_buffer(mode.nonce)\n        elif isinstance(cipher, modes.ModeWithNonce):\n            iv_nonce = self._backend._ffi.from_buffer(cipher.nonce)\n        else:\n            iv_nonce = self._backend._ffi.NULL\n        # begin init with cipher and operation type\n        res = self._backend._lib.EVP_CipherInit_ex(\n            ctx,\n            evp_cipher,\n            self._backend._ffi.NULL,\n            self._backend._ffi.NULL,\n            self._backend._ffi.NULL,\n            operation,\n        )\n        self._backend.openssl_assert(res != 0)\n        # set the key length to handle variable key ciphers\n        res = self._backend._lib.EVP_CIPHER_CTX_set_key_length(\n            ctx, len(cipher.key)\n        )\n        self._backend.openssl_assert(res != 0)\n        if isinstance(mode, modes.GCM):\n            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(\n                ctx,\n                self._backend._lib.EVP_CTRL_AEAD_SET_IVLEN,\n                len(iv_nonce),\n                self._backend._ffi.NULL,\n            )\n            self._backend.openssl_assert(res != 0)\n            if mode.tag is not None:\n                res = self._backend._lib.EVP_CIPHER_CTX_ctrl(\n                    ctx,\n                    self._backend._lib.EVP_CTRL_AEAD_SET_TAG,\n                    len(mode.tag),\n                    mode.tag,\n                )\n                self._backend.openssl_assert(res != 0)\n                self._tag = mode.tag\n\n        # pass key/iv\n        res = self._backend._lib.EVP_CipherInit_ex(\n            ctx,\n            self._backend._ffi.NULL,\n            self._backend._ffi.NULL,\n            self._backend._ffi.from_buffer(cipher.key),\n            iv_nonce,\n            operation,\n        )\n        self._backend.openssl_assert(res != 0)\n        # We purposely disable padding here as it's handled higher up in the\n        # API.\n        self._backend._lib.EVP_CIPHER_CTX_set_padding(ctx, 0)\n        self._ctx = ctx\n\n    def update(self, data: bytes) -> bytes:\n        buf = bytearray(len(data) + self._block_size_bytes - 1)\n        n = self.update_into(data, buf)\n        return bytes(buf[:n])\n\n    def update_into(self, data: bytes, buf) -> int:\n        total_data_len = len(data)\n        if len(buf) < (total_data_len + self._block_size_bytes - 1):\n            raise ValueError(\n                \"buffer must be at least {} bytes for this \"\n                \"payload\".format(len(data) + self._block_size_bytes - 1)\n            )\n\n        data_processed = 0\n        total_out = 0\n        outlen = self._backend._ffi.new(\"int *\")\n        baseoutbuf = self._backend._ffi.from_buffer(buf)\n        baseinbuf = self._backend._ffi.from_buffer(data)\n\n        while data_processed != total_data_len:\n            outbuf = baseoutbuf + total_out\n            inbuf = baseinbuf + data_processed\n            inlen = min(self._MAX_CHUNK_SIZE, total_data_len - data_processed)\n\n            res = self._backend._lib.EVP_CipherUpdate(\n                self._ctx, outbuf, outlen, inbuf, inlen\n            )\n            self._backend.openssl_assert(res != 0)\n            data_processed += inlen\n            total_out += outlen[0]\n\n        return total_out\n\n    def finalize(self) -> bytes:\n        if (\n            self._operation == self._DECRYPT\n            and isinstance(self._mode, modes.ModeWithAuthenticationTag)\n            and self.tag is None\n        ):\n            raise ValueError(\n                \"Authentication tag must be provided when decrypting.\"\n            )\n\n        buf = self._backend._ffi.new(\"unsigned char[]\", self._block_size_bytes)\n        outlen = self._backend._ffi.new(\"int *\")\n        res = self._backend._lib.EVP_CipherFinal_ex(self._ctx, buf, outlen)\n        if res == 0:\n            errors = self._backend._consume_errors()\n\n            if not errors and isinstance(self._mode, modes.GCM):\n                raise InvalidTag\n\n            self._backend.openssl_assert(\n                errors[0]._lib_reason_match(\n                    self._backend._lib.ERR_LIB_EVP,\n                    self._backend._lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH,\n                ),\n                errors=errors,\n            )\n            raise ValueError(\n                \"The length of the provided data is not a multiple of \"\n                \"the block length.\"\n            )\n\n        if (\n            isinstance(self._mode, modes.GCM)\n            and self._operation == self._ENCRYPT\n        ):\n            tag_buf = self._backend._ffi.new(\n                \"unsigned char[]\", self._block_size_bytes\n            )\n            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(\n                self._ctx,\n                self._backend._lib.EVP_CTRL_AEAD_GET_TAG,\n                self._block_size_bytes,\n                tag_buf,\n            )\n            self._backend.openssl_assert(res != 0)\n            self._tag = self._backend._ffi.buffer(tag_buf)[:]\n\n        res = self._backend._lib.EVP_CIPHER_CTX_reset(self._ctx)\n        self._backend.openssl_assert(res == 1)\n        return self._backend._ffi.buffer(buf)[: outlen[0]]\n\n    def finalize_with_tag(self, tag: bytes) -> bytes:\n        if len(tag) < self._mode._min_tag_length:\n            raise ValueError(\n                \"Authentication tag must be {} bytes or longer.\".format(\n                    self._mode._min_tag_length\n                )\n            )\n        res = self._backend._lib.EVP_CIPHER_CTX_ctrl(\n            self._ctx, self._backend._lib.EVP_CTRL_AEAD_SET_TAG, len(tag), tag\n        )\n        self._backend.openssl_assert(res != 0)\n        self._tag = tag\n        return self.finalize()\n\n    def authenticate_additional_data(self, data: bytes) -> None:\n        outlen = self._backend._ffi.new(\"int *\")\n        res = self._backend._lib.EVP_CipherUpdate(\n            self._ctx,\n            self._backend._ffi.NULL,\n            outlen,\n            self._backend._ffi.from_buffer(data),\n            len(data),\n        )\n        self._backend.openssl_assert(res != 0)\n\n    tag = utils.read_only_property(\"_tag\")\n",
    "code_after": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nfrom cryptography import utils\nfrom cryptography.exceptions import InvalidTag, UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.primitives import ciphers\nfrom cryptography.hazmat.primitives.ciphers import modes\n\n\n@utils.register_interface(ciphers.CipherContext)\n@utils.register_interface(ciphers.AEADCipherContext)\n@utils.register_interface(ciphers.AEADEncryptionContext)\n@utils.register_interface(ciphers.AEADDecryptionContext)\nclass _CipherContext(object):\n    _ENCRYPT = 1\n    _DECRYPT = 0\n    _MAX_CHUNK_SIZE = 2 ** 30 - 1\n\n    def __init__(self, backend, cipher, mode, operation):\n        self._backend = backend\n        self._cipher = cipher\n        self._mode = mode\n        self._operation = operation\n        self._tag = None\n\n        if isinstance(self._cipher, ciphers.BlockCipherAlgorithm):\n            self._block_size_bytes = self._cipher.block_size // 8\n        else:\n            self._block_size_bytes = 1\n\n        ctx = self._backend._lib.EVP_CIPHER_CTX_new()\n        ctx = self._backend._ffi.gc(\n            ctx, self._backend._lib.EVP_CIPHER_CTX_free\n        )\n\n        registry = self._backend._cipher_registry\n        try:\n            adapter = registry[type(cipher), type(mode)]\n        except KeyError:\n            raise UnsupportedAlgorithm(\n                \"cipher {} in {} mode is not supported \"\n                \"by this backend.\".format(\n                    cipher.name, mode.name if mode else mode\n                ),\n                _Reasons.UNSUPPORTED_CIPHER,\n            )\n\n        evp_cipher = adapter(self._backend, cipher, mode)\n        if evp_cipher == self._backend._ffi.NULL:\n            msg = \"cipher {0.name} \".format(cipher)\n            if mode is not None:\n                msg += \"in {0.name} mode \".format(mode)\n            msg += (\n                \"is not supported by this backend (Your version of OpenSSL \"\n                \"may be too old. Current version: {}.)\"\n            ).format(self._backend.openssl_version_text())\n            raise UnsupportedAlgorithm(msg, _Reasons.UNSUPPORTED_CIPHER)\n\n        if isinstance(mode, modes.ModeWithInitializationVector):\n            iv_nonce = self._backend._ffi.from_buffer(\n                mode.initialization_vector\n            )\n        elif isinstance(mode, modes.ModeWithTweak):\n            iv_nonce = self._backend._ffi.from_buffer(mode.tweak)\n        elif isinstance(mode, modes.ModeWithNonce):\n            iv_nonce = self._backend._ffi.from_buffer(mode.nonce)\n        elif isinstance(cipher, modes.ModeWithNonce):\n            iv_nonce = self._backend._ffi.from_buffer(cipher.nonce)\n        else:\n            iv_nonce = self._backend._ffi.NULL\n        # begin init with cipher and operation type\n        res = self._backend._lib.EVP_CipherInit_ex(\n            ctx,\n            evp_cipher,\n            self._backend._ffi.NULL,\n            self._backend._ffi.NULL,\n            self._backend._ffi.NULL,\n            operation,\n        )\n        self._backend.openssl_assert(res != 0)\n        # set the key length to handle variable key ciphers\n        res = self._backend._lib.EVP_CIPHER_CTX_set_key_length(\n            ctx, len(cipher.key)\n        )\n        self._backend.openssl_assert(res != 0)\n        if isinstance(mode, modes.GCM):\n            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(\n                ctx,\n                self._backend._lib.EVP_CTRL_AEAD_SET_IVLEN,\n                len(iv_nonce),\n                self._backend._ffi.NULL,\n            )\n            self._backend.openssl_assert(res != 0)\n            if mode.tag is not None:\n                res = self._backend._lib.EVP_CIPHER_CTX_ctrl(\n                    ctx,\n                    self._backend._lib.EVP_CTRL_AEAD_SET_TAG,\n                    len(mode.tag),\n                    mode.tag,\n                )\n                self._backend.openssl_assert(res != 0)\n                self._tag = mode.tag\n\n        # pass key/iv\n        res = self._backend._lib.EVP_CipherInit_ex(\n            ctx,\n            self._backend._ffi.NULL,\n            self._backend._ffi.NULL,\n            self._backend._ffi.from_buffer(cipher.key),\n            iv_nonce,\n            operation,\n        )\n        self._backend.openssl_assert(res != 0)\n        # We purposely disable padding here as it's handled higher up in the\n        # API.\n        self._backend._lib.EVP_CIPHER_CTX_set_padding(ctx, 0)\n        self._ctx = ctx\n\n    def update(self, data: bytes) -> bytes:\n        buf = bytearray(len(data) + self._block_size_bytes - 1)\n        n = self.update_into(data, buf)\n        return bytes(buf[:n])\n\n    def update_into(self, data: bytes, buf) -> int:\n        total_data_len = len(data)\n        if len(buf) < (total_data_len + self._block_size_bytes - 1):\n            raise ValueError(\n                \"buffer must be at least {} bytes for this \"\n                \"payload\".format(len(data) + self._block_size_bytes - 1)\n            )\n\n        data_processed = 0\n        total_out = 0\n        outlen = self._backend._ffi.new(\"int *\")\n        baseoutbuf = self._backend._ffi.from_buffer(buf)\n        baseinbuf = self._backend._ffi.from_buffer(data)\n\n        while data_processed != total_data_len:\n            outbuf = baseoutbuf + total_out\n            inbuf = baseinbuf + data_processed\n            inlen = min(self._MAX_CHUNK_SIZE, total_data_len - data_processed)\n\n            res = self._backend._lib.EVP_CipherUpdate(\n                self._ctx, outbuf, outlen, inbuf, inlen\n            )\n            self._backend.openssl_assert(res != 0)\n            data_processed += inlen\n            total_out += outlen[0]\n\n        return total_out\n\n    def finalize(self) -> bytes:\n        if (\n            self._operation == self._DECRYPT\n            and isinstance(self._mode, modes.ModeWithAuthenticationTag)\n            and self.tag is None\n        ):\n            raise ValueError(\n                \"Authentication tag must be provided when decrypting.\"\n            )\n\n        buf = self._backend._ffi.new(\"unsigned char[]\", self._block_size_bytes)\n        outlen = self._backend._ffi.new(\"int *\")\n        res = self._backend._lib.EVP_CipherFinal_ex(self._ctx, buf, outlen)\n        if res == 0:\n            errors = self._backend._consume_errors()\n\n            if not errors and isinstance(self._mode, modes.GCM):\n                raise InvalidTag\n\n            self._backend.openssl_assert(\n                errors[0]._lib_reason_match(\n                    self._backend._lib.ERR_LIB_EVP,\n                    self._backend._lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH,\n                ),\n                errors=errors,\n            )\n            raise ValueError(\n                \"The length of the provided data is not a multiple of \"\n                \"the block length.\"\n            )\n\n        if (\n            isinstance(self._mode, modes.GCM)\n            and self._operation == self._ENCRYPT\n        ):\n            tag_buf = self._backend._ffi.new(\n                \"unsigned char[]\", self._block_size_bytes\n            )\n            res = self._backend._lib.EVP_CIPHER_CTX_ctrl(\n                self._ctx,\n                self._backend._lib.EVP_CTRL_AEAD_GET_TAG,\n                self._block_size_bytes,\n                tag_buf,\n            )\n            self._backend.openssl_assert(res != 0)\n            self._tag = self._backend._ffi.buffer(tag_buf)[:]\n\n        res = self._backend._lib.EVP_CIPHER_CTX_reset(self._ctx)\n        self._backend.openssl_assert(res == 1)\n        return self._backend._ffi.buffer(buf)[: outlen[0]]\n\n    def finalize_with_tag(self, tag: bytes) -> bytes:\n        if len(tag) < self._mode._min_tag_length:\n            raise ValueError(\n                \"Authentication tag must be {} bytes or longer.\".format(\n                    self._mode._min_tag_length\n                )\n            )\n        res = self._backend._lib.EVP_CIPHER_CTX_ctrl(\n            self._ctx, self._backend._lib.EVP_CTRL_AEAD_SET_TAG, len(tag), tag\n        )\n        self._backend.openssl_assert(res != 0)\n        self._tag = tag\n        return self.finalize()\n\n    def authenticate_additional_data(self, data: bytes) -> None:\n        outlen = self._backend._ffi.new(\"int *\")\n        res = self._backend._lib.EVP_CipherUpdate(\n            self._ctx,\n            self._backend._ffi.NULL,\n            outlen,\n            self._backend._ffi.from_buffer(data),\n            len(data),\n        )\n        self._backend.openssl_assert(res != 0)\n\n    tag = utils.read_only_property(\"_tag\")\n"
  }
]
