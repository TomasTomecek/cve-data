#!/usr/bin/python3
import json
import re
import subprocess
import sys
from pathlib import Path
from subprocess import CalledProcessError
from typing import List


workspace_path = Path(__file__).parent / "workspace"
DJANGO = "django"
DJANGO_PATH = workspace_path.joinpath(DJANGO)
CPYTHON = "cpython"
CPYTHON_PATH = workspace_path.joinpath(CPYTHON)
projects = [
    f"https://github.com/{DJANGO}/{DJANGO}",
    "https://github.com/psf/requests",
    "https://github.com/urllib3/urllib3",
    "https://github.com/pycrypto/pycrypto",
    "https://github.com/pyca/cryptography",
    "https://github.com/pallets/flask",
    f"https://github.com/python/{CPYTHON}",
    "https://github.com/mozillazg/pypy",  # doesnt work: https://foss.heptapod.net/pypy/pypy
    "https://github.com/ansible/ansible",
    "https://github.com/pallets/werkzeug",
    "https://github.com/pallets/jinja",
    "https://github.com/tensorflow/tensorflow",
]
TEST_FILE_RE = re.compile(r".+/test_\w+.py")
CVE_RE = re.compile(r"CVE-\d+-\d+")
BACKPORT_OF = "Backport of "
BACKPORT_OF_RE = re.compile(rf"{BACKPORT_OF}(\w+)")
# (cherry picked from commit 264a0110ffa4e08b0c7b1023e67a6bd7cb9617c6)
CPYTHON_UPSTREAM = "cherry picked from commit"
CPYTHON_UPSTREAM_RE = re.compile(r"cherry picked from commit (\w+)")


def get_cve_commits(git_project: Path) -> List[str]:
    """return a list of commits that probably contain CVE fix:
    string 'CVE' needs to be present in the commit message"""
    s = subprocess.check_output(
        ["git", "log", "--grep=CVE", "--pretty=format:%H"],
        cwd=git_project,
        encoding="utf-8",
    )
    return s.splitlines()


def get_backport_commits(git_project: Path, commit_message: str):
    s = subprocess.check_output(
        ["git", "log", f"--grep={commit_message}", "--pretty=format:%H", "--all"],
        cwd=git_project,
        encoding="utf-8",
        stderr=subprocess.DEVNULL,
    )
    return s.splitlines()


def get_code_changes(git_project: Path, git_hash: str) -> List[str]:
    """return list of patches in .py files"""
    s = subprocess.check_output(
        ["git", "diff", "--name-only", f"{git_hash}^", git_hash],
        cwd=git_project,
        encoding="utf-8",
    )
    return [x for x in s.splitlines() if x.endswith(".py")]


def setup_workspace():
    workspace_path.mkdir(exist_ok=True)
    for p in projects:
        project_name = p.rsplit("/", 1)[1]
        clone_path = workspace_path / project_name
        if clone_path.is_dir():
            continue
        subprocess.check_call(
            ["git", "clone", p, clone_path],
            cwd=workspace_path,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )


def get_patch_from_commit(
    git_project: Path, commit_hash: str, code_file_path: str
) -> str:
    patch = subprocess.check_output(
        [
            "git",
            "diff",
            f"{commit_hash}^",
            commit_hash,
            "--",
            code_file_path,
        ],
        cwd=git_project,
        encoding="utf-8",
        stderr=subprocess.DEVNULL,
    )
    return patch


def get_commit_message(git_project: Path, commit_hash: str) -> str:
    commit_message = subprocess.check_output(
        ["git", "log", "--format=%B", "-n", "1", commit_hash],
        cwd=git_project,
        encoding="utf-8",
        stderr=subprocess.DEVNULL,
    )
    return commit_message


def get_file_from_ref(git_project: Path, commit_hash: str, git_ref: str) -> str:
    code = subprocess.check_output(
        ["git", "show", f"{commit_hash}:{git_ref}"],
        cwd=git_project,
        encoding="utf-8",
        stderr=subprocess.DEVNULL,
    )
    # some files contain non-utf8 chars:
    #   UnicodeDecodeError: 'utf-8' codec can't decode byte
    #   0xfc in position 224: invalid start byte
    return code


def process_project(git_project: Path):
    data = []
    cve_commits = get_cve_commits(git_project)
    for cve_commit in cve_commits:
        code_changes = get_code_changes(git_project, cve_commit)
        # both code and tests
        if code_changes:
            # exclude all tests
            actual_code_changes = [
                x
                for x in code_changes
                if not (
                    x.startswith("test")
                    or x.startswith("doc")
                    or x == "setup.py"
                    or TEST_FILE_RE.match(x)
                )
            ]
            if len(actual_code_changes) != 1:
                # we want simple fixes initially
                continue

            patch = get_patch_from_commit(
                git_project, cve_commit, actual_code_changes[0]
            )
            commit_message = get_commit_message(git_project, cve_commit)
            code_before = get_file_from_ref(
                git_project, f"{cve_commit}^", actual_code_changes[0]
            )
            code_after = get_file_from_ref(
                git_project, cve_commit, actual_code_changes[0]
            )
            possible_cve_ids = CVE_RE.findall(commit_message)
            # pick the first one
            cve_id = possible_cve_ids[0] if possible_cve_ids else ""

            # # one can verify that the patch and code_before/after are valid:
            # import difflib
            # d = difflib.unified_diff(code_before.splitlines(), code_after.splitlines())
            # print('\n'.join(list(d)))
            # print(patch)

            data.append(
                {
                    "cve_id": cve_id,
                    # it's possible multiple commits fix a CVE
                    "upstream_patch": patch,
                    "upstream_commit_hash": cve_commit,
                    "upstream_commit_message": commit_message,
                    "upstream_code_before": code_before,
                    "upstream_code_after": code_after,
                    "upstream_project": git_project.name,
                    "downstream_patch": "TBD",
                }
            )
            if cve_id:
                print(f"{cve_id} {git_project.name} {actual_code_changes} {cve_commit}")
    return data


def get_cve_data():
    data = []
    for p in projects:
        project_name = p.rsplit("/", 1)[1]
        clone_path = workspace_path / project_name
        data += process_project(clone_path)
    return data


def get_backports(
    project: Path, re_to_find_upstream_commit: re.Pattern, backport_message: str
):
    """
    For django:
    9932 commits marked as backports

    "number of python code files changed" -> "number of such commits"
    {
      2: 421,
      1: 2605,
      0: 1083,
      5: 32,
      3: 129,
      4: 54
      6: 16

      63: 2, 64: 1, 136: 1, 683: 1, 27: 1, 37: 1, 8: 7, 9: 4, 10: 3, 29: 2, 7: 8,
      13: 4, 99: 1, 15: 3, 14: 4, 404: 1, 38: 1, 18: 1, 32: 2, 22: 2, 11: 1, 12: 2, 19: 1}
    """
    data = []
    backport_commits = get_backport_commits(project, backport_message)
    for backport_commit in backport_commits:
        code_changes = get_code_changes(project, backport_commit)
        # both code and tests
        if code_changes:
            # exclude all tests
            actual_code_changes = [
                x
                for x in code_changes
                if not (
                    x.startswith("test")
                    or x.startswith("doc")
                    or x == "setup.py"
                    or TEST_FILE_RE.match(x)
                )
            ]
            num_code_files_changed = len(actual_code_changes)
            if num_code_files_changed != 1:
                continue
            try:
                backport_commit_message = get_commit_message(project, backport_commit)
                try:
                    upstream_commit_hash = re_to_find_upstream_commit.findall(
                        backport_commit_message
                    )[0]
                except IndexError:
                    continue
                upstream_patch = get_patch_from_commit(
                    project, backport_commit, actual_code_changes[0]
                )
                backport_before = get_file_from_ref(
                    project, f"{backport_commit}^", actual_code_changes[0]
                )
                backport_patch = get_patch_from_commit(
                    project, upstream_commit_hash, actual_code_changes[0]
                )
                upstream_commit_message = get_commit_message(
                    project, upstream_commit_hash
                )
                upstream_before = get_file_from_ref(
                    project, f"{upstream_commit_hash}^", actual_code_changes[0]
                )
            except (CalledProcessError, UnicodeDecodeError):
                # the commit no longer exists or there is a mistake in the data
                # or the revision is not available
                # in github any more = django moved over the years
                # cpython codebase has some non-utf8 chars
                continue
            if upstream_patch == backport_patch:
                continue
            data.append(
                {
                    "upstream_patch": upstream_patch,
                    "upstream_commit_hash": upstream_commit_hash,
                    "upstream_commit_message": upstream_commit_message,
                    "upstream_before": upstream_before,
                    "backport_patch": backport_patch,
                    "backport_commit_hash": backport_commit,
                    "backport_commit_message": backport_commit_message,
                    "backport_before": backport_before,
                }
            )

    return data


def main() -> int:
    setup_workspace()

    try:
        command = sys.argv[1]
    except IndexError:
        command = "get-cve-data"

    if command == "get-django-backports":
        data = get_backports(DJANGO_PATH, BACKPORT_OF_RE, BACKPORT_OF)
    elif command == "get-cpython-backports":
        data = get_backports(CPYTHON_PATH, CPYTHON_UPSTREAM_RE, CPYTHON_UPSTREAM)
    elif command == "get-cve-data":
        data = get_cve_data()
    else:
        print("Unknown command")
        return -3

    print(f"SUM: {len(data)}")

    print(json.dumps(data, indent=2))
    return 0


if __name__ == "__main__":
    sys.exit(main())
