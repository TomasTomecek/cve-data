[
  {
    "patch": "diff --git a/Lib/test/test_embed.py b/Lib/test/test_embed.py\nindex 174892a22b4..44d2596d9eb 100644\n--- a/Lib/test/test_embed.py\n+++ b/Lib/test/test_embed.py\n@@ -32,7 +32,7 @@\n def debug_build(program):\n     program = os.path.basename(program)\n     name = os.path.splitext(program)[0]\n-    return name.endswith(\"_d\")\n+    return name.casefold().endswith(\"_d\".casefold())\n \n \n def remove_python_envvars():\n@@ -568,7 +568,7 @@ def get_expected_config(self, expected_preconfig, expected, env, api,\n             if expected['stdio_errors'] is self.GET_DEFAULT_CONFIG:\n                 expected['stdio_errors'] = 'surrogateescape'\n \n-        if sys.platform == 'win32':\n+        if MS_WINDOWS:\n             default_executable = self.test_exe\n         elif expected['program_name'] is not self.GET_DEFAULT_CONFIG:\n             default_executable = os.path.abspath(expected['program_name'])\n@@ -603,7 +603,7 @@ def check_pre_config(self, configs, expected):\n         pre_config = dict(configs['pre_config'])\n         for key, value in list(expected.items()):\n             if value is self.IGNORE_CONFIG:\n-                del pre_config[key]\n+                pre_config.pop(key, None)\n                 del expected[key]\n         self.assertEqual(pre_config, expected)\n \n@@ -611,7 +611,7 @@ def check_config(self, configs, expected):\n         config = dict(configs['config'])\n         for key, value in list(expected.items()):\n             if value is self.IGNORE_CONFIG:\n-                del config[key]\n+                config.pop(key, None)\n                 del expected[key]\n         self.assertEqual(config, expected)\n \n@@ -686,6 +686,7 @@ def check_all_configs(self, testname, expected_config=None,\n         self.check_pre_config(configs, expected_preconfig)\n         self.check_config(configs, expected_config)\n         self.check_global_config(configs)\n+        return configs\n \n     def test_init_default_config(self):\n         self.check_all_configs(\"test_init_initialize_config\", api=API_COMPAT)\n@@ -1064,6 +1065,7 @@ def test_init_setpath(self):\n         }\n         self.default_program_name(config)\n         env = {'TESTPATH': os.path.pathsep.join(paths)}\n+\n         self.check_all_configs(\"test_init_setpath\", config,\n                                api=API_COMPAT, env=env,\n                                ignore_stderr=True)\n@@ -1121,12 +1123,18 @@ def tmpdir_with_python(self):\n                 # Copy pythonXY.dll (or pythonXY_d.dll)\n                 ver = sys.version_info\n                 dll = f'python{ver.major}{ver.minor}'\n+                dll3 = f'python{ver.major}'\n                 if debug_build(sys.executable):\n                     dll += '_d'\n+                    dll3 += '_d'\n                 dll += '.dll'\n+                dll3 += '.dll'\n                 dll = os.path.join(os.path.dirname(self.test_exe), dll)\n+                dll3 = os.path.join(os.path.dirname(self.test_exe), dll3)\n                 dll_copy = os.path.join(tmpdir, os.path.basename(dll))\n+                dll3_copy = os.path.join(tmpdir, os.path.basename(dll3))\n                 shutil.copyfile(dll, dll_copy)\n+                shutil.copyfile(dll3, dll3_copy)\n \n             # Copy Python program\n             exec_copy = os.path.join(tmpdir, os.path.basename(self.test_exe))\n@@ -1254,9 +1262,18 @@ def test_init_pyvenv_cfg(self):\n                 config['base_prefix'] = pyvenv_home\n                 config['prefix'] = pyvenv_home\n             env = self.copy_paths_by_env(config)\n-            self.check_all_configs(\"test_init_compat_config\", config,\n-                                   api=API_COMPAT, env=env,\n-                                   ignore_stderr=True, cwd=tmpdir)\n+            actual = self.check_all_configs(\"test_init_compat_config\", config,\n+                                            api=API_COMPAT, env=env,\n+                                            ignore_stderr=True, cwd=tmpdir)\n+            if MS_WINDOWS:\n+                self.assertEqual(\n+                    actual['windows']['python3_dll'],\n+                    os.path.join(\n+                        tmpdir,\n+                        os.path.basename(self.EXPECTED_CONFIG['windows']['python3_dll'])\n+                    )\n+                )\n+\n \n     def test_global_pathconfig(self):\n         # Test C API functions getting the path configuration:\n",
    "commit_message": "bpo-29778: Ensure python3.dll is loaded from correct locations when Python is embedded (GH-21297)\n\nAlso enables using debug build of `python3_d.dll`\nReference: CVE-2020-15523\n",
    "code_before": "# Run the tests in Programs/_testembed.c (tests for the CPython embedding APIs)\nfrom test import support\nimport unittest\n\nfrom collections import namedtuple\nimport contextlib\nimport json\nimport os\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\n\n\nMS_WINDOWS = (os.name == 'nt')\nMACOS = (sys.platform == 'darwin')\n\nPYMEM_ALLOCATOR_NOT_SET = 0\nPYMEM_ALLOCATOR_DEBUG = 2\nPYMEM_ALLOCATOR_MALLOC = 3\n\n# _PyCoreConfig_InitCompatConfig()\nAPI_COMPAT = 1\n# _PyCoreConfig_InitPythonConfig()\nAPI_PYTHON = 2\n# _PyCoreConfig_InitIsolatedConfig()\nAPI_ISOLATED = 3\n\n\ndef debug_build(program):\n    program = os.path.basename(program)\n    name = os.path.splitext(program)[0]\n    return name.endswith(\"_d\")\n\n\ndef remove_python_envvars():\n    env = dict(os.environ)\n    # Remove PYTHON* environment variables to get deterministic environment\n    for key in list(env):\n        if key.startswith('PYTHON'):\n            del env[key]\n    return env\n\n\nclass EmbeddingTestsMixin:\n    def setUp(self):\n        here = os.path.abspath(__file__)\n        basepath = os.path.dirname(os.path.dirname(os.path.dirname(here)))\n        exename = \"_testembed\"\n        if MS_WINDOWS:\n            ext = (\"_d\" if debug_build(sys.executable) else \"\") + \".exe\"\n            exename += ext\n            exepath = os.path.dirname(sys.executable)\n        else:\n            exepath = os.path.join(basepath, \"Programs\")\n        self.test_exe = exe = os.path.join(exepath, exename)\n        if not os.path.exists(exe):\n            self.skipTest(\"%r doesn't exist\" % exe)\n        # This is needed otherwise we get a fatal error:\n        # \"Py_Initialize: Unable to get the locale encoding\n        # LookupError: no codec search functions registered: can't find encoding\"\n        self.oldcwd = os.getcwd()\n        os.chdir(basepath)\n\n    def tearDown(self):\n        os.chdir(self.oldcwd)\n\n    def run_embedded_interpreter(self, *args, env=None,\n                                 timeout=None, returncode=0, input=None,\n                                 cwd=None):\n        \"\"\"Runs a test in the embedded interpreter\"\"\"\n        cmd = [self.test_exe]\n        cmd.extend(args)\n        if env is not None and MS_WINDOWS:\n            # Windows requires at least the SYSTEMROOT environment variable to\n            # start Python.\n            env = env.copy()\n            env['SYSTEMROOT'] = os.environ['SYSTEMROOT']\n\n        p = subprocess.Popen(cmd,\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE,\n                             universal_newlines=True,\n                             env=env,\n                             cwd=cwd)\n        try:\n            (out, err) = p.communicate(input=input, timeout=timeout)\n        except:\n            p.terminate()\n            p.wait()\n            raise\n        if p.returncode != returncode and support.verbose:\n            print(f\"--- {cmd} failed ---\")\n            print(f\"stdout:\\n{out}\")\n            print(f\"stderr:\\n{err}\")\n            print(f\"------\")\n\n        self.assertEqual(p.returncode, returncode,\n                         \"bad returncode %d, stderr is %r\" %\n                         (p.returncode, err))\n        return out, err\n\n    def run_repeated_init_and_subinterpreters(self):\n        out, err = self.run_embedded_interpreter(\"test_repeated_init_and_subinterpreters\")\n        self.assertEqual(err, \"\")\n\n        # The output from _testembed looks like this:\n        # --- Pass 0 ---\n        # interp 0 <0x1cf9330>, thread state <0x1cf9700>: id(modules) = 139650431942728\n        # interp 1 <0x1d4f690>, thread state <0x1d35350>: id(modules) = 139650431165784\n        # interp 2 <0x1d5a690>, thread state <0x1d99ed0>: id(modules) = 139650413140368\n        # interp 3 <0x1d4f690>, thread state <0x1dc3340>: id(modules) = 139650412862200\n        # interp 0 <0x1cf9330>, thread state <0x1cf9700>: id(modules) = 139650431942728\n        # --- Pass 1 ---\n        # ...\n\n        interp_pat = (r\"^interp (\\d+) <(0x[\\dA-F]+)>, \"\n                      r\"thread state <(0x[\\dA-F]+)>: \"\n                      r\"id\\(modules\\) = ([\\d]+)$\")\n        Interp = namedtuple(\"Interp\", \"id interp tstate modules\")\n\n        numloops = 0\n        current_run = []\n        for line in out.splitlines():\n            if line == \"--- Pass {} ---\".format(numloops):\n                self.assertEqual(len(current_run), 0)\n                if support.verbose > 1:\n                    print(line)\n                numloops += 1\n                continue\n\n            self.assertLess(len(current_run), 5)\n            match = re.match(interp_pat, line)\n            if match is None:\n                self.assertRegex(line, interp_pat)\n\n            # Parse the line from the loop.  The first line is the main\n            # interpreter and the 3 afterward are subinterpreters.\n            interp = Interp(*match.groups())\n            if support.verbose > 1:\n                print(interp)\n            self.assertTrue(interp.interp)\n            self.assertTrue(interp.tstate)\n            self.assertTrue(interp.modules)\n            current_run.append(interp)\n\n            # The last line in the loop should be the same as the first.\n            if len(current_run) == 5:\n                main = current_run[0]\n                self.assertEqual(interp, main)\n                yield current_run\n                current_run = []\n\n\nclass EmbeddingTests(EmbeddingTestsMixin, unittest.TestCase):\n    def test_subinterps_main(self):\n        for run in self.run_repeated_init_and_subinterpreters():\n            main = run[0]\n\n            self.assertEqual(main.id, '0')\n\n    def test_subinterps_different_ids(self):\n        for run in self.run_repeated_init_and_subinterpreters():\n            main, *subs, _ = run\n\n            mainid = int(main.id)\n            for i, sub in enumerate(subs):\n                self.assertEqual(sub.id, str(mainid + i + 1))\n\n    def test_subinterps_distinct_state(self):\n        for run in self.run_repeated_init_and_subinterpreters():\n            main, *subs, _ = run\n\n            if '0x0' in main:\n                # XXX Fix on Windows (and other platforms): something\n                # is going on with the pointers in Programs/_testembed.c.\n                # interp.interp is 0x0 and interp.modules is the same\n                # between interpreters.\n                raise unittest.SkipTest('platform prints pointers as 0x0')\n\n            for sub in subs:\n                # A new subinterpreter may have the same\n                # PyInterpreterState pointer as a previous one if\n                # the earlier one has already been destroyed.  So\n                # we compare with the main interpreter.  The same\n                # applies to tstate.\n                self.assertNotEqual(sub.interp, main.interp)\n                self.assertNotEqual(sub.tstate, main.tstate)\n                self.assertNotEqual(sub.modules, main.modules)\n\n    def test_forced_io_encoding(self):\n        # Checks forced configuration of embedded interpreter IO streams\n        env = dict(os.environ, PYTHONIOENCODING=\"utf-8:surrogateescape\")\n        out, err = self.run_embedded_interpreter(\"test_forced_io_encoding\", env=env)\n        if support.verbose > 1:\n            print()\n            print(out)\n            print(err)\n        expected_stream_encoding = \"utf-8\"\n        expected_errors = \"surrogateescape\"\n        expected_output = '\\n'.join([\n        \"--- Use defaults ---\",\n        \"Expected encoding: default\",\n        \"Expected errors: default\",\n        \"stdin: {in_encoding}:{errors}\",\n        \"stdout: {out_encoding}:{errors}\",\n        \"stderr: {out_encoding}:backslashreplace\",\n        \"--- Set errors only ---\",\n        \"Expected encoding: default\",\n        \"Expected errors: ignore\",\n        \"stdin: {in_encoding}:ignore\",\n        \"stdout: {out_encoding}:ignore\",\n        \"stderr: {out_encoding}:backslashreplace\",\n        \"--- Set encoding only ---\",\n        \"Expected encoding: iso8859-1\",\n        \"Expected errors: default\",\n        \"stdin: iso8859-1:{errors}\",\n        \"stdout: iso8859-1:{errors}\",\n        \"stderr: iso8859-1:backslashreplace\",\n        \"--- Set encoding and errors ---\",\n        \"Expected encoding: iso8859-1\",\n        \"Expected errors: replace\",\n        \"stdin: iso8859-1:replace\",\n        \"stdout: iso8859-1:replace\",\n        \"stderr: iso8859-1:backslashreplace\"])\n        expected_output = expected_output.format(\n                                in_encoding=expected_stream_encoding,\n                                out_encoding=expected_stream_encoding,\n                                errors=expected_errors)\n        # This is useful if we ever trip over odd platform behaviour\n        self.maxDiff = None\n        self.assertEqual(out.strip(), expected_output)\n\n    def test_pre_initialization_api(self):\n        \"\"\"\n        Checks some key parts of the C-API that need to work before the runtine\n        is initialized (via Py_Initialize()).\n        \"\"\"\n        env = dict(os.environ, PYTHONPATH=os.pathsep.join(sys.path))\n        out, err = self.run_embedded_interpreter(\"test_pre_initialization_api\", env=env)\n        if MS_WINDOWS:\n            expected_path = self.test_exe\n        else:\n            expected_path = os.path.join(os.getcwd(), \"spam\")\n        expected_output = f\"sys.executable: {expected_path}\\n\"\n        self.assertIn(expected_output, out)\n        self.assertEqual(err, '')\n\n    def test_pre_initialization_sys_options(self):\n        \"\"\"\n        Checks that sys.warnoptions and sys._xoptions can be set before the\n        runtime is initialized (otherwise they won't be effective).\n        \"\"\"\n        env = remove_python_envvars()\n        env['PYTHONPATH'] = os.pathsep.join(sys.path)\n        out, err = self.run_embedded_interpreter(\n                        \"test_pre_initialization_sys_options\", env=env)\n        expected_output = (\n            \"sys.warnoptions: ['once', 'module', 'default']\\n\"\n            \"sys._xoptions: {'not_an_option': '1', 'also_not_an_option': '2'}\\n\"\n            \"warnings.filters[:3]: ['default', 'module', 'once']\\n\"\n        )\n        self.assertIn(expected_output, out)\n        self.assertEqual(err, '')\n\n    def test_bpo20891(self):\n        \"\"\"\n        bpo-20891: Calling PyGILState_Ensure in a non-Python thread must not\n        crash.\n        \"\"\"\n        out, err = self.run_embedded_interpreter(\"test_bpo20891\")\n        self.assertEqual(out, '')\n        self.assertEqual(err, '')\n\n    def test_initialize_twice(self):\n        \"\"\"\n        bpo-33932: Calling Py_Initialize() twice should do nothing (and not\n        crash!).\n        \"\"\"\n        out, err = self.run_embedded_interpreter(\"test_initialize_twice\")\n        self.assertEqual(out, '')\n        self.assertEqual(err, '')\n\n    def test_initialize_pymain(self):\n        \"\"\"\n        bpo-34008: Calling Py_Main() after Py_Initialize() must not fail.\n        \"\"\"\n        out, err = self.run_embedded_interpreter(\"test_initialize_pymain\")\n        self.assertEqual(out.rstrip(), \"Py_Main() after Py_Initialize: sys.argv=['-c', 'arg2']\")\n        self.assertEqual(err, '')\n\n    def test_run_main(self):\n        out, err = self.run_embedded_interpreter(\"test_run_main\")\n        self.assertEqual(out.rstrip(), \"Py_RunMain(): sys.argv=['-c', 'arg2']\")\n        self.assertEqual(err, '')\n\n\nclass InitConfigTests(EmbeddingTestsMixin, unittest.TestCase):\n    maxDiff = 4096\n    UTF8_MODE_ERRORS = ('surrogatepass' if MS_WINDOWS else 'surrogateescape')\n\n    # Marker to read the default configuration: get_default_config()\n    GET_DEFAULT_CONFIG = object()\n\n    # Marker to ignore a configuration parameter\n    IGNORE_CONFIG = object()\n\n    PRE_CONFIG_COMPAT = {\n        '_config_init': API_COMPAT,\n        'allocator': PYMEM_ALLOCATOR_NOT_SET,\n        'parse_argv': 0,\n        'configure_locale': 1,\n        'coerce_c_locale': 0,\n        'coerce_c_locale_warn': 0,\n        'utf8_mode': 0,\n    }\n    if MS_WINDOWS:\n        PRE_CONFIG_COMPAT.update({\n            'legacy_windows_fs_encoding': 0,\n        })\n    PRE_CONFIG_PYTHON = dict(PRE_CONFIG_COMPAT,\n        _config_init=API_PYTHON,\n        parse_argv=1,\n        coerce_c_locale=GET_DEFAULT_CONFIG,\n        utf8_mode=GET_DEFAULT_CONFIG,\n    )\n    PRE_CONFIG_ISOLATED = dict(PRE_CONFIG_COMPAT,\n        _config_init=API_ISOLATED,\n        configure_locale=0,\n        isolated=1,\n        use_environment=0,\n        utf8_mode=0,\n        dev_mode=0,\n        coerce_c_locale=0,\n    )\n\n    COPY_PRE_CONFIG = [\n        'dev_mode',\n        'isolated',\n        'use_environment',\n    ]\n\n    CONFIG_COMPAT = {\n        '_config_init': API_COMPAT,\n        'isolated': 0,\n        'use_environment': 1,\n        'dev_mode': 0,\n\n        'install_signal_handlers': 1,\n        'use_hash_seed': 0,\n        'hash_seed': 0,\n        'faulthandler': 0,\n        'tracemalloc': 0,\n        'import_time': 0,\n        'show_ref_count': 0,\n        'dump_refs': 0,\n        'malloc_stats': 0,\n\n        'filesystem_encoding': GET_DEFAULT_CONFIG,\n        'filesystem_errors': GET_DEFAULT_CONFIG,\n\n        'pycache_prefix': None,\n        'program_name': GET_DEFAULT_CONFIG,\n        'parse_argv': 0,\n        'argv': [\"\"],\n        'orig_argv': [],\n\n        'xoptions': [],\n        'warnoptions': [],\n\n        'pythonpath_env': None,\n        'home': None,\n        'executable': GET_DEFAULT_CONFIG,\n        'base_executable': GET_DEFAULT_CONFIG,\n\n        'prefix': GET_DEFAULT_CONFIG,\n        'base_prefix': GET_DEFAULT_CONFIG,\n        'exec_prefix': GET_DEFAULT_CONFIG,\n        'base_exec_prefix': GET_DEFAULT_CONFIG,\n        'module_search_paths': GET_DEFAULT_CONFIG,\n        'platlibdir': sys.platlibdir,\n\n        'site_import': 1,\n        'bytes_warning': 0,\n        'inspect': 0,\n        'interactive': 0,\n        'optimization_level': 0,\n        'parser_debug': 0,\n        'write_bytecode': 1,\n        'verbose': 0,\n        'quiet': 0,\n        'user_site_directory': 1,\n        'configure_c_stdio': 0,\n        'buffered_stdio': 1,\n\n        'stdio_encoding': GET_DEFAULT_CONFIG,\n        'stdio_errors': GET_DEFAULT_CONFIG,\n\n        'skip_source_first_line': 0,\n        'run_command': None,\n        'run_module': None,\n        'run_filename': None,\n\n        '_install_importlib': 1,\n        'check_hash_pycs_mode': 'default',\n        'pathconfig_warnings': 1,\n        '_init_main': 1,\n        '_isolated_interpreter': 0,\n    }\n    if MS_WINDOWS:\n        CONFIG_COMPAT.update({\n            'legacy_windows_stdio': 0,\n        })\n\n    CONFIG_PYTHON = dict(CONFIG_COMPAT,\n        _config_init=API_PYTHON,\n        configure_c_stdio=1,\n        parse_argv=1,\n    )\n    CONFIG_ISOLATED = dict(CONFIG_COMPAT,\n        _config_init=API_ISOLATED,\n        isolated=1,\n        use_environment=0,\n        user_site_directory=0,\n        dev_mode=0,\n        install_signal_handlers=0,\n        use_hash_seed=0,\n        faulthandler=0,\n        tracemalloc=0,\n        pathconfig_warnings=0,\n    )\n    if MS_WINDOWS:\n        CONFIG_ISOLATED['legacy_windows_stdio'] = 0\n\n    # global config\n    DEFAULT_GLOBAL_CONFIG = {\n        'Py_HasFileSystemDefaultEncoding': 0,\n        'Py_HashRandomizationFlag': 1,\n        '_Py_HasFileSystemDefaultEncodeErrors': 0,\n    }\n    COPY_GLOBAL_PRE_CONFIG = [\n        ('Py_UTF8Mode', 'utf8_mode'),\n    ]\n    COPY_GLOBAL_CONFIG = [\n        # Copy core config to global config for expected values\n        # True means that the core config value is inverted (0 => 1 and 1 => 0)\n        ('Py_BytesWarningFlag', 'bytes_warning'),\n        ('Py_DebugFlag', 'parser_debug'),\n        ('Py_DontWriteBytecodeFlag', 'write_bytecode', True),\n        ('Py_FileSystemDefaultEncodeErrors', 'filesystem_errors'),\n        ('Py_FileSystemDefaultEncoding', 'filesystem_encoding'),\n        ('Py_FrozenFlag', 'pathconfig_warnings', True),\n        ('Py_IgnoreEnvironmentFlag', 'use_environment', True),\n        ('Py_InspectFlag', 'inspect'),\n        ('Py_InteractiveFlag', 'interactive'),\n        ('Py_IsolatedFlag', 'isolated'),\n        ('Py_NoSiteFlag', 'site_import', True),\n        ('Py_NoUserSiteDirectory', 'user_site_directory', True),\n        ('Py_OptimizeFlag', 'optimization_level'),\n        ('Py_QuietFlag', 'quiet'),\n        ('Py_UnbufferedStdioFlag', 'buffered_stdio', True),\n        ('Py_VerboseFlag', 'verbose'),\n    ]\n    if MS_WINDOWS:\n        COPY_GLOBAL_PRE_CONFIG.extend((\n            ('Py_LegacyWindowsFSEncodingFlag', 'legacy_windows_fs_encoding'),\n        ))\n        COPY_GLOBAL_CONFIG.extend((\n            ('Py_LegacyWindowsStdioFlag', 'legacy_windows_stdio'),\n        ))\n\n    EXPECTED_CONFIG = None\n\n    @classmethod\n    def tearDownClass(cls):\n        # clear cache\n        cls.EXPECTED_CONFIG = None\n\n    def main_xoptions(self, xoptions_list):\n        xoptions = {}\n        for opt in xoptions_list:\n            if '=' in opt:\n                key, value = opt.split('=', 1)\n                xoptions[key] = value\n            else:\n                xoptions[opt] = True\n        return xoptions\n\n    def _get_expected_config_impl(self):\n        env = remove_python_envvars()\n        code = textwrap.dedent('''\n            import json\n            import sys\n            import _testinternalcapi\n\n            configs = _testinternalcapi.get_configs()\n\n            data = json.dumps(configs)\n            data = data.encode('utf-8')\n            sys.stdout.buffer.write(data)\n            sys.stdout.buffer.flush()\n        ''')\n\n        # Use -S to not import the site module: get the proper configuration\n        # when test_embed is run from a venv (bpo-35313)\n        args = [sys.executable, '-S', '-c', code]\n        proc = subprocess.run(args, env=env,\n                              stdout=subprocess.PIPE,\n                              stderr=subprocess.PIPE)\n        if proc.returncode:\n            raise Exception(f\"failed to get the default config: \"\n                            f\"stdout={proc.stdout!r} stderr={proc.stderr!r}\")\n        stdout = proc.stdout.decode('utf-8')\n        # ignore stderr\n        try:\n            return json.loads(stdout)\n        except json.JSONDecodeError:\n            self.fail(f\"fail to decode stdout: {stdout!r}\")\n\n    def _get_expected_config(self):\n        cls = InitConfigTests\n        if cls.EXPECTED_CONFIG is None:\n            cls.EXPECTED_CONFIG = self._get_expected_config_impl()\n\n        # get a copy\n        configs = {}\n        for config_key, config_value in cls.EXPECTED_CONFIG.items():\n            config = {}\n            for key, value in config_value.items():\n                if isinstance(value, list):\n                    value = value.copy()\n                config[key] = value\n            configs[config_key] = config\n        return configs\n\n    def get_expected_config(self, expected_preconfig, expected, env, api,\n                            modify_path_cb=None):\n        cls = self.__class__\n        configs = self._get_expected_config()\n\n        pre_config = configs['pre_config']\n        for key, value in expected_preconfig.items():\n            if value is self.GET_DEFAULT_CONFIG:\n                expected_preconfig[key] = pre_config[key]\n\n        if not expected_preconfig['configure_locale'] or api == API_COMPAT:\n            # there is no easy way to get the locale encoding before\n            # setlocale(LC_CTYPE, \"\") is called: don't test encodings\n            for key in ('filesystem_encoding', 'filesystem_errors',\n                        'stdio_encoding', 'stdio_errors'):\n                expected[key] = self.IGNORE_CONFIG\n\n        if not expected_preconfig['configure_locale']:\n            # UTF-8 Mode depends on the locale. There is no easy way\n            # to guess if UTF-8 Mode will be enabled or not if the locale\n            # is not configured.\n            expected_preconfig['utf8_mode'] = self.IGNORE_CONFIG\n\n        if expected_preconfig['utf8_mode'] == 1:\n            if expected['filesystem_encoding'] is self.GET_DEFAULT_CONFIG:\n                expected['filesystem_encoding'] = 'utf-8'\n            if expected['filesystem_errors'] is self.GET_DEFAULT_CONFIG:\n                expected['filesystem_errors'] = self.UTF8_MODE_ERRORS\n            if expected['stdio_encoding'] is self.GET_DEFAULT_CONFIG:\n                expected['stdio_encoding'] = 'utf-8'\n            if expected['stdio_errors'] is self.GET_DEFAULT_CONFIG:\n                expected['stdio_errors'] = 'surrogateescape'\n\n        if sys.platform == 'win32':\n            default_executable = self.test_exe\n        elif expected['program_name'] is not self.GET_DEFAULT_CONFIG:\n            default_executable = os.path.abspath(expected['program_name'])\n        else:\n            default_executable = os.path.join(os.getcwd(), '_testembed')\n        if expected['executable'] is self.GET_DEFAULT_CONFIG:\n            expected['executable'] = default_executable\n        if expected['base_executable'] is self.GET_DEFAULT_CONFIG:\n            expected['base_executable'] = default_executable\n        if expected['program_name'] is self.GET_DEFAULT_CONFIG:\n            expected['program_name'] = './_testembed'\n\n        config = configs['config']\n        for key, value in expected.items():\n            if value is self.GET_DEFAULT_CONFIG:\n                expected[key] = config[key]\n\n        if expected['module_search_paths'] is not self.IGNORE_CONFIG:\n            pythonpath_env = expected['pythonpath_env']\n            if pythonpath_env is not None:\n                paths = pythonpath_env.split(os.path.pathsep)\n                expected['module_search_paths'] = [*paths, *expected['module_search_paths']]\n            if modify_path_cb is not None:\n                expected['module_search_paths'] = expected['module_search_paths'].copy()\n                modify_path_cb(expected['module_search_paths'])\n\n        for key in self.COPY_PRE_CONFIG:\n            if key not in expected_preconfig:\n                expected_preconfig[key] = expected[key]\n\n    def check_pre_config(self, configs, expected):\n        pre_config = dict(configs['pre_config'])\n        for key, value in list(expected.items()):\n            if value is self.IGNORE_CONFIG:\n                del pre_config[key]\n                del expected[key]\n        self.assertEqual(pre_config, expected)\n\n    def check_config(self, configs, expected):\n        config = dict(configs['config'])\n        for key, value in list(expected.items()):\n            if value is self.IGNORE_CONFIG:\n                del config[key]\n                del expected[key]\n        self.assertEqual(config, expected)\n\n    def check_global_config(self, configs):\n        pre_config = configs['pre_config']\n        config = configs['config']\n\n        expected = dict(self.DEFAULT_GLOBAL_CONFIG)\n        for item in self.COPY_GLOBAL_CONFIG:\n            if len(item) == 3:\n                global_key, core_key, opposite = item\n                expected[global_key] = 0 if config[core_key] else 1\n            else:\n                global_key, core_key = item\n                expected[global_key] = config[core_key]\n        for item in self.COPY_GLOBAL_PRE_CONFIG:\n            if len(item) == 3:\n                global_key, core_key, opposite = item\n                expected[global_key] = 0 if pre_config[core_key] else 1\n            else:\n                global_key, core_key = item\n                expected[global_key] = pre_config[core_key]\n\n        self.assertEqual(configs['global_config'], expected)\n\n    def check_all_configs(self, testname, expected_config=None,\n                          expected_preconfig=None, modify_path_cb=None,\n                          stderr=None, *, api, preconfig_api=None,\n                          env=None, ignore_stderr=False, cwd=None):\n        new_env = remove_python_envvars()\n        if env is not None:\n            new_env.update(env)\n        env = new_env\n\n        if preconfig_api is None:\n            preconfig_api = api\n        if preconfig_api == API_ISOLATED:\n            default_preconfig = self.PRE_CONFIG_ISOLATED\n        elif preconfig_api == API_PYTHON:\n            default_preconfig = self.PRE_CONFIG_PYTHON\n        else:\n            default_preconfig = self.PRE_CONFIG_COMPAT\n        if expected_preconfig is None:\n            expected_preconfig = {}\n        expected_preconfig = dict(default_preconfig, **expected_preconfig)\n        if expected_config is None:\n            expected_config = {}\n\n        if api == API_PYTHON:\n            default_config = self.CONFIG_PYTHON\n        elif api == API_ISOLATED:\n            default_config = self.CONFIG_ISOLATED\n        else:\n            default_config = self.CONFIG_COMPAT\n        expected_config = dict(default_config, **expected_config)\n\n        self.get_expected_config(expected_preconfig,\n                                 expected_config, env,\n                                 api, modify_path_cb)\n\n        out, err = self.run_embedded_interpreter(testname,\n                                                 env=env, cwd=cwd)\n        if stderr is None and not expected_config['verbose']:\n            stderr = \"\"\n        if stderr is not None and not ignore_stderr:\n            self.assertEqual(err.rstrip(), stderr)\n        try:\n            configs = json.loads(out)\n        except json.JSONDecodeError:\n            self.fail(f\"fail to decode stdout: {out!r}\")\n\n        self.check_pre_config(configs, expected_preconfig)\n        self.check_config(configs, expected_config)\n        self.check_global_config(configs)\n\n    def test_init_default_config(self):\n        self.check_all_configs(\"test_init_initialize_config\", api=API_COMPAT)\n\n    def test_preinit_compat_config(self):\n        self.check_all_configs(\"test_preinit_compat_config\", api=API_COMPAT)\n\n    def test_init_compat_config(self):\n        self.check_all_configs(\"test_init_compat_config\", api=API_COMPAT)\n\n    def test_init_global_config(self):\n        preconfig = {\n            'utf8_mode': 1,\n        }\n        config = {\n            'program_name': './globalvar',\n            'site_import': 0,\n            'bytes_warning': 1,\n            'warnoptions': ['default::BytesWarning'],\n            'inspect': 1,\n            'interactive': 1,\n            'optimization_level': 2,\n            'write_bytecode': 0,\n            'verbose': 1,\n            'quiet': 1,\n            'buffered_stdio': 0,\n\n            'user_site_directory': 0,\n            'pathconfig_warnings': 0,\n        }\n        self.check_all_configs(\"test_init_global_config\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_from_config(self):\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_MALLOC,\n            'utf8_mode': 1,\n        }\n        config = {\n            'install_signal_handlers': 0,\n            'use_hash_seed': 1,\n            'hash_seed': 123,\n            'tracemalloc': 2,\n            'import_time': 1,\n            'show_ref_count': 1,\n            'malloc_stats': 1,\n\n            'stdio_encoding': 'iso8859-1',\n            'stdio_errors': 'replace',\n\n            'pycache_prefix': 'conf_pycache_prefix',\n            'program_name': './conf_program_name',\n            'argv': ['-c', 'arg2'],\n            'orig_argv': ['python3',\n                          '-W', 'cmdline_warnoption',\n                          '-X', 'cmdline_xoption',\n                          '-c', 'pass',\n                          'arg2'],\n            'parse_argv': 1,\n            'xoptions': [\n                'config_xoption1=3',\n                'config_xoption2=',\n                'config_xoption3',\n                'cmdline_xoption',\n            ],\n            'warnoptions': [\n                'cmdline_warnoption',\n                'default::BytesWarning',\n                'config_warnoption',\n            ],\n            'run_command': 'pass\\n',\n\n            'site_import': 0,\n            'bytes_warning': 1,\n            'inspect': 1,\n            'interactive': 1,\n            'optimization_level': 2,\n            'write_bytecode': 0,\n            'verbose': 1,\n            'quiet': 1,\n            'configure_c_stdio': 1,\n            'buffered_stdio': 0,\n            'user_site_directory': 0,\n            'faulthandler': 1,\n            'platlibdir': 'my_platlibdir',\n            'module_search_paths': self.IGNORE_CONFIG,\n\n            'check_hash_pycs_mode': 'always',\n            'pathconfig_warnings': 0,\n\n            '_isolated_interpreter': 1,\n        }\n        self.check_all_configs(\"test_init_from_config\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_compat_env(self):\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_MALLOC,\n        }\n        config = {\n            'use_hash_seed': 1,\n            'hash_seed': 42,\n            'tracemalloc': 2,\n            'import_time': 1,\n            'malloc_stats': 1,\n            'inspect': 1,\n            'optimization_level': 2,\n            'pythonpath_env': '/my/path',\n            'pycache_prefix': 'env_pycache_prefix',\n            'write_bytecode': 0,\n            'verbose': 1,\n            'buffered_stdio': 0,\n            'stdio_encoding': 'iso8859-1',\n            'stdio_errors': 'replace',\n            'user_site_directory': 0,\n            'faulthandler': 1,\n            'warnoptions': ['EnvVar'],\n            'platlibdir': 'env_platlibdir',\n            'module_search_paths': self.IGNORE_CONFIG,\n        }\n        self.check_all_configs(\"test_init_compat_env\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_python_env(self):\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_MALLOC,\n            'utf8_mode': 1,\n        }\n        config = {\n            'use_hash_seed': 1,\n            'hash_seed': 42,\n            'tracemalloc': 2,\n            'import_time': 1,\n            'malloc_stats': 1,\n            'inspect': 1,\n            'optimization_level': 2,\n            'pythonpath_env': '/my/path',\n            'pycache_prefix': 'env_pycache_prefix',\n            'write_bytecode': 0,\n            'verbose': 1,\n            'buffered_stdio': 0,\n            'stdio_encoding': 'iso8859-1',\n            'stdio_errors': 'replace',\n            'user_site_directory': 0,\n            'faulthandler': 1,\n            'warnoptions': ['EnvVar'],\n            'platlibdir': 'env_platlibdir',\n            'module_search_paths': self.IGNORE_CONFIG,\n        }\n        self.check_all_configs(\"test_init_python_env\", config, preconfig,\n                               api=API_PYTHON)\n\n    def test_init_env_dev_mode(self):\n        preconfig = dict(allocator=PYMEM_ALLOCATOR_DEBUG)\n        config = dict(dev_mode=1,\n                      faulthandler=1,\n                      warnoptions=['default'])\n        self.check_all_configs(\"test_init_env_dev_mode\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_env_dev_mode_alloc(self):\n        preconfig = dict(allocator=PYMEM_ALLOCATOR_MALLOC)\n        config = dict(dev_mode=1,\n                      faulthandler=1,\n                      warnoptions=['default'])\n        self.check_all_configs(\"test_init_env_dev_mode_alloc\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_dev_mode(self):\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_DEBUG,\n        }\n        config = {\n            'faulthandler': 1,\n            'dev_mode': 1,\n            'warnoptions': ['default'],\n        }\n        self.check_all_configs(\"test_init_dev_mode\", config, preconfig,\n                               api=API_PYTHON)\n\n    def test_preinit_parse_argv(self):\n        # Pre-initialize implicitly using argv: make sure that -X dev\n        # is used to configure the allocation in preinitialization\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_DEBUG,\n        }\n        config = {\n            'argv': ['script.py'],\n            'orig_argv': ['python3', '-X', 'dev', 'script.py'],\n            'run_filename': os.path.abspath('script.py'),\n            'dev_mode': 1,\n            'faulthandler': 1,\n            'warnoptions': ['default'],\n            'xoptions': ['dev'],\n        }\n        self.check_all_configs(\"test_preinit_parse_argv\", config, preconfig,\n                               api=API_PYTHON)\n\n    def test_preinit_dont_parse_argv(self):\n        # -X dev must be ignored by isolated preconfiguration\n        preconfig = {\n            'isolated': 0,\n        }\n        argv = [\"python3\",\n               \"-E\", \"-I\",\n               \"-X\", \"dev\",\n               \"-X\", \"utf8\",\n               \"script.py\"]\n        config = {\n            'argv': argv,\n            'orig_argv': argv,\n            'isolated': 0,\n        }\n        self.check_all_configs(\"test_preinit_dont_parse_argv\", config, preconfig,\n                               api=API_ISOLATED)\n\n    def test_init_isolated_flag(self):\n        config = {\n            'isolated': 1,\n            'use_environment': 0,\n            'user_site_directory': 0,\n        }\n        self.check_all_configs(\"test_init_isolated_flag\", config, api=API_PYTHON)\n\n    def test_preinit_isolated1(self):\n        # _PyPreConfig.isolated=1, _PyCoreConfig.isolated not set\n        config = {\n            'isolated': 1,\n            'use_environment': 0,\n            'user_site_directory': 0,\n        }\n        self.check_all_configs(\"test_preinit_isolated1\", config, api=API_COMPAT)\n\n    def test_preinit_isolated2(self):\n        # _PyPreConfig.isolated=0, _PyCoreConfig.isolated=1\n        config = {\n            'isolated': 1,\n            'use_environment': 0,\n            'user_site_directory': 0,\n        }\n        self.check_all_configs(\"test_preinit_isolated2\", config, api=API_COMPAT)\n\n    def test_preinit_isolated_config(self):\n        self.check_all_configs(\"test_preinit_isolated_config\", api=API_ISOLATED)\n\n    def test_init_isolated_config(self):\n        self.check_all_configs(\"test_init_isolated_config\", api=API_ISOLATED)\n\n    def test_preinit_python_config(self):\n        self.check_all_configs(\"test_preinit_python_config\", api=API_PYTHON)\n\n    def test_init_python_config(self):\n        self.check_all_configs(\"test_init_python_config\", api=API_PYTHON)\n\n    def test_init_dont_configure_locale(self):\n        # _PyPreConfig.configure_locale=0\n        preconfig = {\n            'configure_locale': 0,\n            'coerce_c_locale': 0,\n        }\n        self.check_all_configs(\"test_init_dont_configure_locale\", {}, preconfig,\n                               api=API_PYTHON)\n\n    def test_init_read_set(self):\n        config = {\n            'program_name': './init_read_set',\n            'executable': 'my_executable',\n        }\n        def modify_path(path):\n            path.insert(1, \"test_path_insert1\")\n            path.append(\"test_path_append\")\n        self.check_all_configs(\"test_init_read_set\", config,\n                               api=API_PYTHON,\n                               modify_path_cb=modify_path)\n\n    def test_init_sys_add(self):\n        config = {\n            'faulthandler': 1,\n            'xoptions': [\n                'config_xoption',\n                'cmdline_xoption',\n                'sysadd_xoption',\n                'faulthandler',\n            ],\n            'warnoptions': [\n                'ignore:::cmdline_warnoption',\n                'ignore:::sysadd_warnoption',\n                'ignore:::config_warnoption',\n            ],\n            'orig_argv': ['python3',\n                          '-W', 'ignore:::cmdline_warnoption',\n                          '-X', 'cmdline_xoption'],\n        }\n        self.check_all_configs(\"test_init_sys_add\", config, api=API_PYTHON)\n\n    def test_init_run_main(self):\n        code = ('import _testinternalcapi, json; '\n                'print(json.dumps(_testinternalcapi.get_configs()))')\n        config = {\n            'argv': ['-c', 'arg2'],\n            'orig_argv': ['python3', '-c', code, 'arg2'],\n            'program_name': './python3',\n            'run_command': code + '\\n',\n            'parse_argv': 1,\n        }\n        self.check_all_configs(\"test_init_run_main\", config, api=API_PYTHON)\n\n    def test_init_main(self):\n        code = ('import _testinternalcapi, json; '\n                'print(json.dumps(_testinternalcapi.get_configs()))')\n        config = {\n            'argv': ['-c', 'arg2'],\n            'orig_argv': ['python3',\n                          '-c', code,\n                          'arg2'],\n            'program_name': './python3',\n            'run_command': code + '\\n',\n            'parse_argv': 1,\n            '_init_main': 0,\n        }\n        self.check_all_configs(\"test_init_main\", config,\n                               api=API_PYTHON,\n                               stderr=\"Run Python code before _Py_InitializeMain\")\n\n    def test_init_parse_argv(self):\n        config = {\n            'parse_argv': 1,\n            'argv': ['-c', 'arg1', '-v', 'arg3'],\n            'orig_argv': ['./argv0', '-E', '-c', 'pass', 'arg1', '-v', 'arg3'],\n            'program_name': './argv0',\n            'run_command': 'pass\\n',\n            'use_environment': 0,\n        }\n        self.check_all_configs(\"test_init_parse_argv\", config, api=API_PYTHON)\n\n    def test_init_dont_parse_argv(self):\n        pre_config = {\n            'parse_argv': 0,\n        }\n        config = {\n            'parse_argv': 0,\n            'argv': ['./argv0', '-E', '-c', 'pass', 'arg1', '-v', 'arg3'],\n            'orig_argv': ['./argv0', '-E', '-c', 'pass', 'arg1', '-v', 'arg3'],\n            'program_name': './argv0',\n        }\n        self.check_all_configs(\"test_init_dont_parse_argv\", config, pre_config,\n                               api=API_PYTHON)\n\n    def default_program_name(self, config):\n        if MS_WINDOWS:\n            program_name = 'python'\n            executable = self.test_exe\n        else:\n            program_name = 'python3'\n            if MACOS:\n                executable = self.test_exe\n            else:\n                executable = shutil.which(program_name) or ''\n        config.update({\n            'program_name': program_name,\n            'base_executable': executable,\n            'executable': executable,\n        })\n\n    def test_init_setpath(self):\n        # Test Py_SetPath()\n        config = self._get_expected_config()\n        paths = config['config']['module_search_paths']\n\n        config = {\n            'module_search_paths': paths,\n            'prefix': '',\n            'base_prefix': '',\n            'exec_prefix': '',\n            'base_exec_prefix': '',\n        }\n        self.default_program_name(config)\n        env = {'TESTPATH': os.path.pathsep.join(paths)}\n        self.check_all_configs(\"test_init_setpath\", config,\n                               api=API_COMPAT, env=env,\n                               ignore_stderr=True)\n\n    def test_init_setpath_config(self):\n        # Test Py_SetPath() with PyConfig\n        config = self._get_expected_config()\n        paths = config['config']['module_search_paths']\n\n        config = {\n            # set by Py_SetPath()\n            'module_search_paths': paths,\n            'prefix': '',\n            'base_prefix': '',\n            'exec_prefix': '',\n            'base_exec_prefix': '',\n            # overriden by PyConfig\n            'program_name': 'conf_program_name',\n            'base_executable': 'conf_executable',\n            'executable': 'conf_executable',\n        }\n        env = {'TESTPATH': os.path.pathsep.join(paths)}\n        self.check_all_configs(\"test_init_setpath_config\", config,\n                               api=API_PYTHON, env=env, ignore_stderr=True)\n\n    def module_search_paths(self, prefix=None, exec_prefix=None):\n        config = self._get_expected_config()\n        if prefix is None:\n            prefix = config['config']['prefix']\n        if exec_prefix is None:\n            exec_prefix = config['config']['prefix']\n        if MS_WINDOWS:\n            return config['config']['module_search_paths']\n        else:\n            ver = sys.version_info\n            return [\n                os.path.join(prefix, sys.platlibdir,\n                             f'python{ver.major}{ver.minor}.zip'),\n                os.path.join(prefix, sys.platlibdir,\n                             f'python{ver.major}.{ver.minor}'),\n                os.path.join(exec_prefix, sys.platlibdir,\n                             f'python{ver.major}.{ver.minor}', 'lib-dynload'),\n            ]\n\n    @contextlib.contextmanager\n    def tmpdir_with_python(self):\n        # Temporary directory with a copy of the Python program\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # bpo-38234: On macOS and FreeBSD, the temporary directory\n            # can be symbolic link. For example, /tmp can be a symbolic link\n            # to /var/tmp. Call realpath() to resolve all symbolic links.\n            tmpdir = os.path.realpath(tmpdir)\n\n            if MS_WINDOWS:\n                # Copy pythonXY.dll (or pythonXY_d.dll)\n                ver = sys.version_info\n                dll = f'python{ver.major}{ver.minor}'\n                if debug_build(sys.executable):\n                    dll += '_d'\n                dll += '.dll'\n                dll = os.path.join(os.path.dirname(self.test_exe), dll)\n                dll_copy = os.path.join(tmpdir, os.path.basename(dll))\n                shutil.copyfile(dll, dll_copy)\n\n            # Copy Python program\n            exec_copy = os.path.join(tmpdir, os.path.basename(self.test_exe))\n            shutil.copyfile(self.test_exe, exec_copy)\n            shutil.copystat(self.test_exe, exec_copy)\n            self.test_exe = exec_copy\n\n            yield tmpdir\n\n    def test_init_setpythonhome(self):\n        # Test Py_SetPythonHome(home) with PYTHONPATH env var\n        config = self._get_expected_config()\n        paths = config['config']['module_search_paths']\n        paths_str = os.path.pathsep.join(paths)\n\n        for path in paths:\n            if not os.path.isdir(path):\n                continue\n            if os.path.exists(os.path.join(path, 'os.py')):\n                home = os.path.dirname(path)\n                break\n        else:\n            self.fail(f\"Unable to find home in {paths!r}\")\n\n        prefix = exec_prefix = home\n        ver = sys.version_info\n        expected_paths = self.module_search_paths(prefix=home, exec_prefix=home)\n\n        config = {\n            'home': home,\n            'module_search_paths': expected_paths,\n            'prefix': prefix,\n            'base_prefix': prefix,\n            'exec_prefix': exec_prefix,\n            'base_exec_prefix': exec_prefix,\n            'pythonpath_env': paths_str,\n        }\n        self.default_program_name(config)\n        env = {'TESTHOME': home, 'PYTHONPATH': paths_str}\n        self.check_all_configs(\"test_init_setpythonhome\", config,\n                               api=API_COMPAT, env=env)\n\n    def copy_paths_by_env(self, config):\n        all_configs = self._get_expected_config()\n        paths = all_configs['config']['module_search_paths']\n        paths_str = os.path.pathsep.join(paths)\n        config['pythonpath_env'] = paths_str\n        env = {'PYTHONPATH': paths_str}\n        return env\n\n    @unittest.skipIf(MS_WINDOWS, 'Windows does not use pybuilddir.txt')\n    def test_init_pybuilddir(self):\n        # Test path configuration with pybuilddir.txt configuration file\n\n        with self.tmpdir_with_python() as tmpdir:\n            # pybuilddir.txt is a sub-directory relative to the current\n            # directory (tmpdir)\n            subdir = 'libdir'\n            libdir = os.path.join(tmpdir, subdir)\n            os.mkdir(libdir)\n\n            filename = os.path.join(tmpdir, 'pybuilddir.txt')\n            with open(filename, \"w\", encoding=\"utf8\") as fp:\n                fp.write(subdir)\n\n            module_search_paths = self.module_search_paths()\n            module_search_paths[-1] = libdir\n\n            executable = self.test_exe\n            config = {\n                'base_executable': executable,\n                'executable': executable,\n                'module_search_paths': module_search_paths,\n            }\n            env = self.copy_paths_by_env(config)\n            self.check_all_configs(\"test_init_compat_config\", config,\n                                   api=API_COMPAT, env=env,\n                                   ignore_stderr=True, cwd=tmpdir)\n\n    def test_init_pyvenv_cfg(self):\n        # Test path configuration with pyvenv.cfg configuration file\n\n        with self.tmpdir_with_python() as tmpdir, \\\n             tempfile.TemporaryDirectory() as pyvenv_home:\n            ver = sys.version_info\n\n            if not MS_WINDOWS:\n                lib_dynload = os.path.join(pyvenv_home,\n                                           sys.platlibdir,\n                                           f'python{ver.major}.{ver.minor}',\n                                           'lib-dynload')\n                os.makedirs(lib_dynload)\n            else:\n                lib_dynload = os.path.join(pyvenv_home, 'lib')\n                os.makedirs(lib_dynload)\n                # getpathp.c uses Lib\\os.py as the LANDMARK\n                shutil.copyfile(os.__file__, os.path.join(lib_dynload, 'os.py'))\n\n            filename = os.path.join(tmpdir, 'pyvenv.cfg')\n            with open(filename, \"w\", encoding=\"utf8\") as fp:\n                print(\"home = %s\" % pyvenv_home, file=fp)\n                print(\"include-system-site-packages = false\", file=fp)\n\n            paths = self.module_search_paths()\n            if not MS_WINDOWS:\n                paths[-1] = lib_dynload\n            else:\n                for index, path in enumerate(paths):\n                    if index == 0:\n                        paths[index] = os.path.join(tmpdir, os.path.basename(path))\n                    else:\n                        paths[index] = os.path.join(pyvenv_home, os.path.basename(path))\n                paths[-1] = pyvenv_home\n\n            executable = self.test_exe\n            exec_prefix = pyvenv_home\n            config = {\n                'base_exec_prefix': exec_prefix,\n                'exec_prefix': exec_prefix,\n                'base_executable': executable,\n                'executable': executable,\n                'module_search_paths': paths,\n            }\n            if MS_WINDOWS:\n                config['base_prefix'] = pyvenv_home\n                config['prefix'] = pyvenv_home\n            env = self.copy_paths_by_env(config)\n            self.check_all_configs(\"test_init_compat_config\", config,\n                                   api=API_COMPAT, env=env,\n                                   ignore_stderr=True, cwd=tmpdir)\n\n    def test_global_pathconfig(self):\n        # Test C API functions getting the path configuration:\n        #\n        # - Py_GetExecPrefix()\n        # - Py_GetPath()\n        # - Py_GetPrefix()\n        # - Py_GetProgramFullPath()\n        # - Py_GetProgramName()\n        # - Py_GetPythonHome()\n        #\n        # The global path configuration (_Py_path_config) must be a copy\n        # of the path configuration of PyInterpreter.config (PyConfig).\n        ctypes = support.import_module('ctypes')\n        _testinternalcapi = support.import_module('_testinternalcapi')\n\n        def get_func(name):\n            func = getattr(ctypes.pythonapi, name)\n            func.argtypes = ()\n            func.restype = ctypes.c_wchar_p\n            return func\n\n        Py_GetPath = get_func('Py_GetPath')\n        Py_GetPrefix = get_func('Py_GetPrefix')\n        Py_GetExecPrefix = get_func('Py_GetExecPrefix')\n        Py_GetProgramName = get_func('Py_GetProgramName')\n        Py_GetProgramFullPath = get_func('Py_GetProgramFullPath')\n        Py_GetPythonHome = get_func('Py_GetPythonHome')\n\n        config = _testinternalcapi.get_configs()['config']\n\n        self.assertEqual(Py_GetPath().split(os.path.pathsep),\n                         config['module_search_paths'])\n        self.assertEqual(Py_GetPrefix(), config['prefix'])\n        self.assertEqual(Py_GetExecPrefix(), config['exec_prefix'])\n        self.assertEqual(Py_GetProgramName(), config['program_name'])\n        self.assertEqual(Py_GetProgramFullPath(), config['executable'])\n        self.assertEqual(Py_GetPythonHome(), config['home'])\n\n    def test_init_warnoptions(self):\n        # lowest to highest priority\n        warnoptions = [\n            'ignore:::PyConfig_Insert0',      # PyWideStringList_Insert(0)\n            'default',                        # PyConfig.dev_mode=1\n            'ignore:::env1',                  # PYTHONWARNINGS env var\n            'ignore:::env2',                  # PYTHONWARNINGS env var\n            'ignore:::cmdline1',              # -W opt command line option\n            'ignore:::cmdline2',              # -W opt command line option\n            'default::BytesWarning',          # PyConfig.bytes_warnings=1\n            'ignore:::PySys_AddWarnOption1',  # PySys_AddWarnOption()\n            'ignore:::PySys_AddWarnOption2',  # PySys_AddWarnOption()\n            'ignore:::PyConfig_BeforeRead',   # PyConfig.warnoptions\n            'ignore:::PyConfig_AfterRead']    # PyWideStringList_Append()\n        preconfig = dict(allocator=PYMEM_ALLOCATOR_DEBUG)\n        config = {\n            'dev_mode': 1,\n            'faulthandler': 1,\n            'bytes_warning': 1,\n            'warnoptions': warnoptions,\n            'orig_argv': ['python3',\n                          '-Wignore:::cmdline1',\n                          '-Wignore:::cmdline2'],\n        }\n        self.check_all_configs(\"test_init_warnoptions\", config, preconfig,\n                               api=API_PYTHON)\n\n    def test_get_argc_argv(self):\n        self.run_embedded_interpreter(\"test_get_argc_argv\")\n        # ignore output\n\n\nclass AuditingTests(EmbeddingTestsMixin, unittest.TestCase):\n    def test_open_code_hook(self):\n        self.run_embedded_interpreter(\"test_open_code_hook\")\n\n    def test_audit(self):\n        self.run_embedded_interpreter(\"test_audit\")\n\n    def test_audit_subinterpreter(self):\n        self.run_embedded_interpreter(\"test_audit_subinterpreter\")\n\n    def test_audit_run_command(self):\n        self.run_embedded_interpreter(\"test_audit_run_command\",\n                                      timeout=support.SHORT_TIMEOUT,\n                                      returncode=1)\n\n    def test_audit_run_file(self):\n        self.run_embedded_interpreter(\"test_audit_run_file\",\n                                      timeout=support.SHORT_TIMEOUT,\n                                      returncode=1)\n\n    def test_audit_run_interactivehook(self):\n        startup = os.path.join(self.oldcwd, support.TESTFN) + \".py\"\n        with open(startup, \"w\", encoding=\"utf-8\") as f:\n            print(\"import sys\", file=f)\n            print(\"sys.__interactivehook__ = lambda: None\", file=f)\n        try:\n            env = {**remove_python_envvars(), \"PYTHONSTARTUP\": startup}\n            self.run_embedded_interpreter(\"test_audit_run_interactivehook\",\n                                          timeout=support.SHORT_TIMEOUT,\n                                          returncode=10, env=env)\n        finally:\n            os.unlink(startup)\n\n    def test_audit_run_startup(self):\n        startup = os.path.join(self.oldcwd, support.TESTFN) + \".py\"\n        with open(startup, \"w\", encoding=\"utf-8\") as f:\n            print(\"pass\", file=f)\n        try:\n            env = {**remove_python_envvars(), \"PYTHONSTARTUP\": startup}\n            self.run_embedded_interpreter(\"test_audit_run_startup\",\n                                          timeout=support.SHORT_TIMEOUT,\n                                          returncode=10, env=env)\n        finally:\n            os.unlink(startup)\n\n    def test_audit_run_stdin(self):\n        self.run_embedded_interpreter(\"test_audit_run_stdin\",\n                                      timeout=support.SHORT_TIMEOUT,\n                                      returncode=1)\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
    "code_after": "# Run the tests in Programs/_testembed.c (tests for the CPython embedding APIs)\nfrom test import support\nimport unittest\n\nfrom collections import namedtuple\nimport contextlib\nimport json\nimport os\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\n\n\nMS_WINDOWS = (os.name == 'nt')\nMACOS = (sys.platform == 'darwin')\n\nPYMEM_ALLOCATOR_NOT_SET = 0\nPYMEM_ALLOCATOR_DEBUG = 2\nPYMEM_ALLOCATOR_MALLOC = 3\n\n# _PyCoreConfig_InitCompatConfig()\nAPI_COMPAT = 1\n# _PyCoreConfig_InitPythonConfig()\nAPI_PYTHON = 2\n# _PyCoreConfig_InitIsolatedConfig()\nAPI_ISOLATED = 3\n\n\ndef debug_build(program):\n    program = os.path.basename(program)\n    name = os.path.splitext(program)[0]\n    return name.casefold().endswith(\"_d\".casefold())\n\n\ndef remove_python_envvars():\n    env = dict(os.environ)\n    # Remove PYTHON* environment variables to get deterministic environment\n    for key in list(env):\n        if key.startswith('PYTHON'):\n            del env[key]\n    return env\n\n\nclass EmbeddingTestsMixin:\n    def setUp(self):\n        here = os.path.abspath(__file__)\n        basepath = os.path.dirname(os.path.dirname(os.path.dirname(here)))\n        exename = \"_testembed\"\n        if MS_WINDOWS:\n            ext = (\"_d\" if debug_build(sys.executable) else \"\") + \".exe\"\n            exename += ext\n            exepath = os.path.dirname(sys.executable)\n        else:\n            exepath = os.path.join(basepath, \"Programs\")\n        self.test_exe = exe = os.path.join(exepath, exename)\n        if not os.path.exists(exe):\n            self.skipTest(\"%r doesn't exist\" % exe)\n        # This is needed otherwise we get a fatal error:\n        # \"Py_Initialize: Unable to get the locale encoding\n        # LookupError: no codec search functions registered: can't find encoding\"\n        self.oldcwd = os.getcwd()\n        os.chdir(basepath)\n\n    def tearDown(self):\n        os.chdir(self.oldcwd)\n\n    def run_embedded_interpreter(self, *args, env=None,\n                                 timeout=None, returncode=0, input=None,\n                                 cwd=None):\n        \"\"\"Runs a test in the embedded interpreter\"\"\"\n        cmd = [self.test_exe]\n        cmd.extend(args)\n        if env is not None and MS_WINDOWS:\n            # Windows requires at least the SYSTEMROOT environment variable to\n            # start Python.\n            env = env.copy()\n            env['SYSTEMROOT'] = os.environ['SYSTEMROOT']\n\n        p = subprocess.Popen(cmd,\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE,\n                             universal_newlines=True,\n                             env=env,\n                             cwd=cwd)\n        try:\n            (out, err) = p.communicate(input=input, timeout=timeout)\n        except:\n            p.terminate()\n            p.wait()\n            raise\n        if p.returncode != returncode and support.verbose:\n            print(f\"--- {cmd} failed ---\")\n            print(f\"stdout:\\n{out}\")\n            print(f\"stderr:\\n{err}\")\n            print(f\"------\")\n\n        self.assertEqual(p.returncode, returncode,\n                         \"bad returncode %d, stderr is %r\" %\n                         (p.returncode, err))\n        return out, err\n\n    def run_repeated_init_and_subinterpreters(self):\n        out, err = self.run_embedded_interpreter(\"test_repeated_init_and_subinterpreters\")\n        self.assertEqual(err, \"\")\n\n        # The output from _testembed looks like this:\n        # --- Pass 0 ---\n        # interp 0 <0x1cf9330>, thread state <0x1cf9700>: id(modules) = 139650431942728\n        # interp 1 <0x1d4f690>, thread state <0x1d35350>: id(modules) = 139650431165784\n        # interp 2 <0x1d5a690>, thread state <0x1d99ed0>: id(modules) = 139650413140368\n        # interp 3 <0x1d4f690>, thread state <0x1dc3340>: id(modules) = 139650412862200\n        # interp 0 <0x1cf9330>, thread state <0x1cf9700>: id(modules) = 139650431942728\n        # --- Pass 1 ---\n        # ...\n\n        interp_pat = (r\"^interp (\\d+) <(0x[\\dA-F]+)>, \"\n                      r\"thread state <(0x[\\dA-F]+)>: \"\n                      r\"id\\(modules\\) = ([\\d]+)$\")\n        Interp = namedtuple(\"Interp\", \"id interp tstate modules\")\n\n        numloops = 0\n        current_run = []\n        for line in out.splitlines():\n            if line == \"--- Pass {} ---\".format(numloops):\n                self.assertEqual(len(current_run), 0)\n                if support.verbose > 1:\n                    print(line)\n                numloops += 1\n                continue\n\n            self.assertLess(len(current_run), 5)\n            match = re.match(interp_pat, line)\n            if match is None:\n                self.assertRegex(line, interp_pat)\n\n            # Parse the line from the loop.  The first line is the main\n            # interpreter and the 3 afterward are subinterpreters.\n            interp = Interp(*match.groups())\n            if support.verbose > 1:\n                print(interp)\n            self.assertTrue(interp.interp)\n            self.assertTrue(interp.tstate)\n            self.assertTrue(interp.modules)\n            current_run.append(interp)\n\n            # The last line in the loop should be the same as the first.\n            if len(current_run) == 5:\n                main = current_run[0]\n                self.assertEqual(interp, main)\n                yield current_run\n                current_run = []\n\n\nclass EmbeddingTests(EmbeddingTestsMixin, unittest.TestCase):\n    def test_subinterps_main(self):\n        for run in self.run_repeated_init_and_subinterpreters():\n            main = run[0]\n\n            self.assertEqual(main.id, '0')\n\n    def test_subinterps_different_ids(self):\n        for run in self.run_repeated_init_and_subinterpreters():\n            main, *subs, _ = run\n\n            mainid = int(main.id)\n            for i, sub in enumerate(subs):\n                self.assertEqual(sub.id, str(mainid + i + 1))\n\n    def test_subinterps_distinct_state(self):\n        for run in self.run_repeated_init_and_subinterpreters():\n            main, *subs, _ = run\n\n            if '0x0' in main:\n                # XXX Fix on Windows (and other platforms): something\n                # is going on with the pointers in Programs/_testembed.c.\n                # interp.interp is 0x0 and interp.modules is the same\n                # between interpreters.\n                raise unittest.SkipTest('platform prints pointers as 0x0')\n\n            for sub in subs:\n                # A new subinterpreter may have the same\n                # PyInterpreterState pointer as a previous one if\n                # the earlier one has already been destroyed.  So\n                # we compare with the main interpreter.  The same\n                # applies to tstate.\n                self.assertNotEqual(sub.interp, main.interp)\n                self.assertNotEqual(sub.tstate, main.tstate)\n                self.assertNotEqual(sub.modules, main.modules)\n\n    def test_forced_io_encoding(self):\n        # Checks forced configuration of embedded interpreter IO streams\n        env = dict(os.environ, PYTHONIOENCODING=\"utf-8:surrogateescape\")\n        out, err = self.run_embedded_interpreter(\"test_forced_io_encoding\", env=env)\n        if support.verbose > 1:\n            print()\n            print(out)\n            print(err)\n        expected_stream_encoding = \"utf-8\"\n        expected_errors = \"surrogateescape\"\n        expected_output = '\\n'.join([\n        \"--- Use defaults ---\",\n        \"Expected encoding: default\",\n        \"Expected errors: default\",\n        \"stdin: {in_encoding}:{errors}\",\n        \"stdout: {out_encoding}:{errors}\",\n        \"stderr: {out_encoding}:backslashreplace\",\n        \"--- Set errors only ---\",\n        \"Expected encoding: default\",\n        \"Expected errors: ignore\",\n        \"stdin: {in_encoding}:ignore\",\n        \"stdout: {out_encoding}:ignore\",\n        \"stderr: {out_encoding}:backslashreplace\",\n        \"--- Set encoding only ---\",\n        \"Expected encoding: iso8859-1\",\n        \"Expected errors: default\",\n        \"stdin: iso8859-1:{errors}\",\n        \"stdout: iso8859-1:{errors}\",\n        \"stderr: iso8859-1:backslashreplace\",\n        \"--- Set encoding and errors ---\",\n        \"Expected encoding: iso8859-1\",\n        \"Expected errors: replace\",\n        \"stdin: iso8859-1:replace\",\n        \"stdout: iso8859-1:replace\",\n        \"stderr: iso8859-1:backslashreplace\"])\n        expected_output = expected_output.format(\n                                in_encoding=expected_stream_encoding,\n                                out_encoding=expected_stream_encoding,\n                                errors=expected_errors)\n        # This is useful if we ever trip over odd platform behaviour\n        self.maxDiff = None\n        self.assertEqual(out.strip(), expected_output)\n\n    def test_pre_initialization_api(self):\n        \"\"\"\n        Checks some key parts of the C-API that need to work before the runtine\n        is initialized (via Py_Initialize()).\n        \"\"\"\n        env = dict(os.environ, PYTHONPATH=os.pathsep.join(sys.path))\n        out, err = self.run_embedded_interpreter(\"test_pre_initialization_api\", env=env)\n        if MS_WINDOWS:\n            expected_path = self.test_exe\n        else:\n            expected_path = os.path.join(os.getcwd(), \"spam\")\n        expected_output = f\"sys.executable: {expected_path}\\n\"\n        self.assertIn(expected_output, out)\n        self.assertEqual(err, '')\n\n    def test_pre_initialization_sys_options(self):\n        \"\"\"\n        Checks that sys.warnoptions and sys._xoptions can be set before the\n        runtime is initialized (otherwise they won't be effective).\n        \"\"\"\n        env = remove_python_envvars()\n        env['PYTHONPATH'] = os.pathsep.join(sys.path)\n        out, err = self.run_embedded_interpreter(\n                        \"test_pre_initialization_sys_options\", env=env)\n        expected_output = (\n            \"sys.warnoptions: ['once', 'module', 'default']\\n\"\n            \"sys._xoptions: {'not_an_option': '1', 'also_not_an_option': '2'}\\n\"\n            \"warnings.filters[:3]: ['default', 'module', 'once']\\n\"\n        )\n        self.assertIn(expected_output, out)\n        self.assertEqual(err, '')\n\n    def test_bpo20891(self):\n        \"\"\"\n        bpo-20891: Calling PyGILState_Ensure in a non-Python thread must not\n        crash.\n        \"\"\"\n        out, err = self.run_embedded_interpreter(\"test_bpo20891\")\n        self.assertEqual(out, '')\n        self.assertEqual(err, '')\n\n    def test_initialize_twice(self):\n        \"\"\"\n        bpo-33932: Calling Py_Initialize() twice should do nothing (and not\n        crash!).\n        \"\"\"\n        out, err = self.run_embedded_interpreter(\"test_initialize_twice\")\n        self.assertEqual(out, '')\n        self.assertEqual(err, '')\n\n    def test_initialize_pymain(self):\n        \"\"\"\n        bpo-34008: Calling Py_Main() after Py_Initialize() must not fail.\n        \"\"\"\n        out, err = self.run_embedded_interpreter(\"test_initialize_pymain\")\n        self.assertEqual(out.rstrip(), \"Py_Main() after Py_Initialize: sys.argv=['-c', 'arg2']\")\n        self.assertEqual(err, '')\n\n    def test_run_main(self):\n        out, err = self.run_embedded_interpreter(\"test_run_main\")\n        self.assertEqual(out.rstrip(), \"Py_RunMain(): sys.argv=['-c', 'arg2']\")\n        self.assertEqual(err, '')\n\n\nclass InitConfigTests(EmbeddingTestsMixin, unittest.TestCase):\n    maxDiff = 4096\n    UTF8_MODE_ERRORS = ('surrogatepass' if MS_WINDOWS else 'surrogateescape')\n\n    # Marker to read the default configuration: get_default_config()\n    GET_DEFAULT_CONFIG = object()\n\n    # Marker to ignore a configuration parameter\n    IGNORE_CONFIG = object()\n\n    PRE_CONFIG_COMPAT = {\n        '_config_init': API_COMPAT,\n        'allocator': PYMEM_ALLOCATOR_NOT_SET,\n        'parse_argv': 0,\n        'configure_locale': 1,\n        'coerce_c_locale': 0,\n        'coerce_c_locale_warn': 0,\n        'utf8_mode': 0,\n    }\n    if MS_WINDOWS:\n        PRE_CONFIG_COMPAT.update({\n            'legacy_windows_fs_encoding': 0,\n        })\n    PRE_CONFIG_PYTHON = dict(PRE_CONFIG_COMPAT,\n        _config_init=API_PYTHON,\n        parse_argv=1,\n        coerce_c_locale=GET_DEFAULT_CONFIG,\n        utf8_mode=GET_DEFAULT_CONFIG,\n    )\n    PRE_CONFIG_ISOLATED = dict(PRE_CONFIG_COMPAT,\n        _config_init=API_ISOLATED,\n        configure_locale=0,\n        isolated=1,\n        use_environment=0,\n        utf8_mode=0,\n        dev_mode=0,\n        coerce_c_locale=0,\n    )\n\n    COPY_PRE_CONFIG = [\n        'dev_mode',\n        'isolated',\n        'use_environment',\n    ]\n\n    CONFIG_COMPAT = {\n        '_config_init': API_COMPAT,\n        'isolated': 0,\n        'use_environment': 1,\n        'dev_mode': 0,\n\n        'install_signal_handlers': 1,\n        'use_hash_seed': 0,\n        'hash_seed': 0,\n        'faulthandler': 0,\n        'tracemalloc': 0,\n        'import_time': 0,\n        'show_ref_count': 0,\n        'dump_refs': 0,\n        'malloc_stats': 0,\n\n        'filesystem_encoding': GET_DEFAULT_CONFIG,\n        'filesystem_errors': GET_DEFAULT_CONFIG,\n\n        'pycache_prefix': None,\n        'program_name': GET_DEFAULT_CONFIG,\n        'parse_argv': 0,\n        'argv': [\"\"],\n        'orig_argv': [],\n\n        'xoptions': [],\n        'warnoptions': [],\n\n        'pythonpath_env': None,\n        'home': None,\n        'executable': GET_DEFAULT_CONFIG,\n        'base_executable': GET_DEFAULT_CONFIG,\n\n        'prefix': GET_DEFAULT_CONFIG,\n        'base_prefix': GET_DEFAULT_CONFIG,\n        'exec_prefix': GET_DEFAULT_CONFIG,\n        'base_exec_prefix': GET_DEFAULT_CONFIG,\n        'module_search_paths': GET_DEFAULT_CONFIG,\n        'platlibdir': sys.platlibdir,\n\n        'site_import': 1,\n        'bytes_warning': 0,\n        'inspect': 0,\n        'interactive': 0,\n        'optimization_level': 0,\n        'parser_debug': 0,\n        'write_bytecode': 1,\n        'verbose': 0,\n        'quiet': 0,\n        'user_site_directory': 1,\n        'configure_c_stdio': 0,\n        'buffered_stdio': 1,\n\n        'stdio_encoding': GET_DEFAULT_CONFIG,\n        'stdio_errors': GET_DEFAULT_CONFIG,\n\n        'skip_source_first_line': 0,\n        'run_command': None,\n        'run_module': None,\n        'run_filename': None,\n\n        '_install_importlib': 1,\n        'check_hash_pycs_mode': 'default',\n        'pathconfig_warnings': 1,\n        '_init_main': 1,\n        '_isolated_interpreter': 0,\n    }\n    if MS_WINDOWS:\n        CONFIG_COMPAT.update({\n            'legacy_windows_stdio': 0,\n        })\n\n    CONFIG_PYTHON = dict(CONFIG_COMPAT,\n        _config_init=API_PYTHON,\n        configure_c_stdio=1,\n        parse_argv=1,\n    )\n    CONFIG_ISOLATED = dict(CONFIG_COMPAT,\n        _config_init=API_ISOLATED,\n        isolated=1,\n        use_environment=0,\n        user_site_directory=0,\n        dev_mode=0,\n        install_signal_handlers=0,\n        use_hash_seed=0,\n        faulthandler=0,\n        tracemalloc=0,\n        pathconfig_warnings=0,\n    )\n    if MS_WINDOWS:\n        CONFIG_ISOLATED['legacy_windows_stdio'] = 0\n\n    # global config\n    DEFAULT_GLOBAL_CONFIG = {\n        'Py_HasFileSystemDefaultEncoding': 0,\n        'Py_HashRandomizationFlag': 1,\n        '_Py_HasFileSystemDefaultEncodeErrors': 0,\n    }\n    COPY_GLOBAL_PRE_CONFIG = [\n        ('Py_UTF8Mode', 'utf8_mode'),\n    ]\n    COPY_GLOBAL_CONFIG = [\n        # Copy core config to global config for expected values\n        # True means that the core config value is inverted (0 => 1 and 1 => 0)\n        ('Py_BytesWarningFlag', 'bytes_warning'),\n        ('Py_DebugFlag', 'parser_debug'),\n        ('Py_DontWriteBytecodeFlag', 'write_bytecode', True),\n        ('Py_FileSystemDefaultEncodeErrors', 'filesystem_errors'),\n        ('Py_FileSystemDefaultEncoding', 'filesystem_encoding'),\n        ('Py_FrozenFlag', 'pathconfig_warnings', True),\n        ('Py_IgnoreEnvironmentFlag', 'use_environment', True),\n        ('Py_InspectFlag', 'inspect'),\n        ('Py_InteractiveFlag', 'interactive'),\n        ('Py_IsolatedFlag', 'isolated'),\n        ('Py_NoSiteFlag', 'site_import', True),\n        ('Py_NoUserSiteDirectory', 'user_site_directory', True),\n        ('Py_OptimizeFlag', 'optimization_level'),\n        ('Py_QuietFlag', 'quiet'),\n        ('Py_UnbufferedStdioFlag', 'buffered_stdio', True),\n        ('Py_VerboseFlag', 'verbose'),\n    ]\n    if MS_WINDOWS:\n        COPY_GLOBAL_PRE_CONFIG.extend((\n            ('Py_LegacyWindowsFSEncodingFlag', 'legacy_windows_fs_encoding'),\n        ))\n        COPY_GLOBAL_CONFIG.extend((\n            ('Py_LegacyWindowsStdioFlag', 'legacy_windows_stdio'),\n        ))\n\n    EXPECTED_CONFIG = None\n\n    @classmethod\n    def tearDownClass(cls):\n        # clear cache\n        cls.EXPECTED_CONFIG = None\n\n    def main_xoptions(self, xoptions_list):\n        xoptions = {}\n        for opt in xoptions_list:\n            if '=' in opt:\n                key, value = opt.split('=', 1)\n                xoptions[key] = value\n            else:\n                xoptions[opt] = True\n        return xoptions\n\n    def _get_expected_config_impl(self):\n        env = remove_python_envvars()\n        code = textwrap.dedent('''\n            import json\n            import sys\n            import _testinternalcapi\n\n            configs = _testinternalcapi.get_configs()\n\n            data = json.dumps(configs)\n            data = data.encode('utf-8')\n            sys.stdout.buffer.write(data)\n            sys.stdout.buffer.flush()\n        ''')\n\n        # Use -S to not import the site module: get the proper configuration\n        # when test_embed is run from a venv (bpo-35313)\n        args = [sys.executable, '-S', '-c', code]\n        proc = subprocess.run(args, env=env,\n                              stdout=subprocess.PIPE,\n                              stderr=subprocess.PIPE)\n        if proc.returncode:\n            raise Exception(f\"failed to get the default config: \"\n                            f\"stdout={proc.stdout!r} stderr={proc.stderr!r}\")\n        stdout = proc.stdout.decode('utf-8')\n        # ignore stderr\n        try:\n            return json.loads(stdout)\n        except json.JSONDecodeError:\n            self.fail(f\"fail to decode stdout: {stdout!r}\")\n\n    def _get_expected_config(self):\n        cls = InitConfigTests\n        if cls.EXPECTED_CONFIG is None:\n            cls.EXPECTED_CONFIG = self._get_expected_config_impl()\n\n        # get a copy\n        configs = {}\n        for config_key, config_value in cls.EXPECTED_CONFIG.items():\n            config = {}\n            for key, value in config_value.items():\n                if isinstance(value, list):\n                    value = value.copy()\n                config[key] = value\n            configs[config_key] = config\n        return configs\n\n    def get_expected_config(self, expected_preconfig, expected, env, api,\n                            modify_path_cb=None):\n        cls = self.__class__\n        configs = self._get_expected_config()\n\n        pre_config = configs['pre_config']\n        for key, value in expected_preconfig.items():\n            if value is self.GET_DEFAULT_CONFIG:\n                expected_preconfig[key] = pre_config[key]\n\n        if not expected_preconfig['configure_locale'] or api == API_COMPAT:\n            # there is no easy way to get the locale encoding before\n            # setlocale(LC_CTYPE, \"\") is called: don't test encodings\n            for key in ('filesystem_encoding', 'filesystem_errors',\n                        'stdio_encoding', 'stdio_errors'):\n                expected[key] = self.IGNORE_CONFIG\n\n        if not expected_preconfig['configure_locale']:\n            # UTF-8 Mode depends on the locale. There is no easy way\n            # to guess if UTF-8 Mode will be enabled or not if the locale\n            # is not configured.\n            expected_preconfig['utf8_mode'] = self.IGNORE_CONFIG\n\n        if expected_preconfig['utf8_mode'] == 1:\n            if expected['filesystem_encoding'] is self.GET_DEFAULT_CONFIG:\n                expected['filesystem_encoding'] = 'utf-8'\n            if expected['filesystem_errors'] is self.GET_DEFAULT_CONFIG:\n                expected['filesystem_errors'] = self.UTF8_MODE_ERRORS\n            if expected['stdio_encoding'] is self.GET_DEFAULT_CONFIG:\n                expected['stdio_encoding'] = 'utf-8'\n            if expected['stdio_errors'] is self.GET_DEFAULT_CONFIG:\n                expected['stdio_errors'] = 'surrogateescape'\n\n        if MS_WINDOWS:\n            default_executable = self.test_exe\n        elif expected['program_name'] is not self.GET_DEFAULT_CONFIG:\n            default_executable = os.path.abspath(expected['program_name'])\n        else:\n            default_executable = os.path.join(os.getcwd(), '_testembed')\n        if expected['executable'] is self.GET_DEFAULT_CONFIG:\n            expected['executable'] = default_executable\n        if expected['base_executable'] is self.GET_DEFAULT_CONFIG:\n            expected['base_executable'] = default_executable\n        if expected['program_name'] is self.GET_DEFAULT_CONFIG:\n            expected['program_name'] = './_testembed'\n\n        config = configs['config']\n        for key, value in expected.items():\n            if value is self.GET_DEFAULT_CONFIG:\n                expected[key] = config[key]\n\n        if expected['module_search_paths'] is not self.IGNORE_CONFIG:\n            pythonpath_env = expected['pythonpath_env']\n            if pythonpath_env is not None:\n                paths = pythonpath_env.split(os.path.pathsep)\n                expected['module_search_paths'] = [*paths, *expected['module_search_paths']]\n            if modify_path_cb is not None:\n                expected['module_search_paths'] = expected['module_search_paths'].copy()\n                modify_path_cb(expected['module_search_paths'])\n\n        for key in self.COPY_PRE_CONFIG:\n            if key not in expected_preconfig:\n                expected_preconfig[key] = expected[key]\n\n    def check_pre_config(self, configs, expected):\n        pre_config = dict(configs['pre_config'])\n        for key, value in list(expected.items()):\n            if value is self.IGNORE_CONFIG:\n                pre_config.pop(key, None)\n                del expected[key]\n        self.assertEqual(pre_config, expected)\n\n    def check_config(self, configs, expected):\n        config = dict(configs['config'])\n        for key, value in list(expected.items()):\n            if value is self.IGNORE_CONFIG:\n                config.pop(key, None)\n                del expected[key]\n        self.assertEqual(config, expected)\n\n    def check_global_config(self, configs):\n        pre_config = configs['pre_config']\n        config = configs['config']\n\n        expected = dict(self.DEFAULT_GLOBAL_CONFIG)\n        for item in self.COPY_GLOBAL_CONFIG:\n            if len(item) == 3:\n                global_key, core_key, opposite = item\n                expected[global_key] = 0 if config[core_key] else 1\n            else:\n                global_key, core_key = item\n                expected[global_key] = config[core_key]\n        for item in self.COPY_GLOBAL_PRE_CONFIG:\n            if len(item) == 3:\n                global_key, core_key, opposite = item\n                expected[global_key] = 0 if pre_config[core_key] else 1\n            else:\n                global_key, core_key = item\n                expected[global_key] = pre_config[core_key]\n\n        self.assertEqual(configs['global_config'], expected)\n\n    def check_all_configs(self, testname, expected_config=None,\n                          expected_preconfig=None, modify_path_cb=None,\n                          stderr=None, *, api, preconfig_api=None,\n                          env=None, ignore_stderr=False, cwd=None):\n        new_env = remove_python_envvars()\n        if env is not None:\n            new_env.update(env)\n        env = new_env\n\n        if preconfig_api is None:\n            preconfig_api = api\n        if preconfig_api == API_ISOLATED:\n            default_preconfig = self.PRE_CONFIG_ISOLATED\n        elif preconfig_api == API_PYTHON:\n            default_preconfig = self.PRE_CONFIG_PYTHON\n        else:\n            default_preconfig = self.PRE_CONFIG_COMPAT\n        if expected_preconfig is None:\n            expected_preconfig = {}\n        expected_preconfig = dict(default_preconfig, **expected_preconfig)\n        if expected_config is None:\n            expected_config = {}\n\n        if api == API_PYTHON:\n            default_config = self.CONFIG_PYTHON\n        elif api == API_ISOLATED:\n            default_config = self.CONFIG_ISOLATED\n        else:\n            default_config = self.CONFIG_COMPAT\n        expected_config = dict(default_config, **expected_config)\n\n        self.get_expected_config(expected_preconfig,\n                                 expected_config, env,\n                                 api, modify_path_cb)\n\n        out, err = self.run_embedded_interpreter(testname,\n                                                 env=env, cwd=cwd)\n        if stderr is None and not expected_config['verbose']:\n            stderr = \"\"\n        if stderr is not None and not ignore_stderr:\n            self.assertEqual(err.rstrip(), stderr)\n        try:\n            configs = json.loads(out)\n        except json.JSONDecodeError:\n            self.fail(f\"fail to decode stdout: {out!r}\")\n\n        self.check_pre_config(configs, expected_preconfig)\n        self.check_config(configs, expected_config)\n        self.check_global_config(configs)\n        return configs\n\n    def test_init_default_config(self):\n        self.check_all_configs(\"test_init_initialize_config\", api=API_COMPAT)\n\n    def test_preinit_compat_config(self):\n        self.check_all_configs(\"test_preinit_compat_config\", api=API_COMPAT)\n\n    def test_init_compat_config(self):\n        self.check_all_configs(\"test_init_compat_config\", api=API_COMPAT)\n\n    def test_init_global_config(self):\n        preconfig = {\n            'utf8_mode': 1,\n        }\n        config = {\n            'program_name': './globalvar',\n            'site_import': 0,\n            'bytes_warning': 1,\n            'warnoptions': ['default::BytesWarning'],\n            'inspect': 1,\n            'interactive': 1,\n            'optimization_level': 2,\n            'write_bytecode': 0,\n            'verbose': 1,\n            'quiet': 1,\n            'buffered_stdio': 0,\n\n            'user_site_directory': 0,\n            'pathconfig_warnings': 0,\n        }\n        self.check_all_configs(\"test_init_global_config\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_from_config(self):\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_MALLOC,\n            'utf8_mode': 1,\n        }\n        config = {\n            'install_signal_handlers': 0,\n            'use_hash_seed': 1,\n            'hash_seed': 123,\n            'tracemalloc': 2,\n            'import_time': 1,\n            'show_ref_count': 1,\n            'malloc_stats': 1,\n\n            'stdio_encoding': 'iso8859-1',\n            'stdio_errors': 'replace',\n\n            'pycache_prefix': 'conf_pycache_prefix',\n            'program_name': './conf_program_name',\n            'argv': ['-c', 'arg2'],\n            'orig_argv': ['python3',\n                          '-W', 'cmdline_warnoption',\n                          '-X', 'cmdline_xoption',\n                          '-c', 'pass',\n                          'arg2'],\n            'parse_argv': 1,\n            'xoptions': [\n                'config_xoption1=3',\n                'config_xoption2=',\n                'config_xoption3',\n                'cmdline_xoption',\n            ],\n            'warnoptions': [\n                'cmdline_warnoption',\n                'default::BytesWarning',\n                'config_warnoption',\n            ],\n            'run_command': 'pass\\n',\n\n            'site_import': 0,\n            'bytes_warning': 1,\n            'inspect': 1,\n            'interactive': 1,\n            'optimization_level': 2,\n            'write_bytecode': 0,\n            'verbose': 1,\n            'quiet': 1,\n            'configure_c_stdio': 1,\n            'buffered_stdio': 0,\n            'user_site_directory': 0,\n            'faulthandler': 1,\n            'platlibdir': 'my_platlibdir',\n            'module_search_paths': self.IGNORE_CONFIG,\n\n            'check_hash_pycs_mode': 'always',\n            'pathconfig_warnings': 0,\n\n            '_isolated_interpreter': 1,\n        }\n        self.check_all_configs(\"test_init_from_config\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_compat_env(self):\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_MALLOC,\n        }\n        config = {\n            'use_hash_seed': 1,\n            'hash_seed': 42,\n            'tracemalloc': 2,\n            'import_time': 1,\n            'malloc_stats': 1,\n            'inspect': 1,\n            'optimization_level': 2,\n            'pythonpath_env': '/my/path',\n            'pycache_prefix': 'env_pycache_prefix',\n            'write_bytecode': 0,\n            'verbose': 1,\n            'buffered_stdio': 0,\n            'stdio_encoding': 'iso8859-1',\n            'stdio_errors': 'replace',\n            'user_site_directory': 0,\n            'faulthandler': 1,\n            'warnoptions': ['EnvVar'],\n            'platlibdir': 'env_platlibdir',\n            'module_search_paths': self.IGNORE_CONFIG,\n        }\n        self.check_all_configs(\"test_init_compat_env\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_python_env(self):\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_MALLOC,\n            'utf8_mode': 1,\n        }\n        config = {\n            'use_hash_seed': 1,\n            'hash_seed': 42,\n            'tracemalloc': 2,\n            'import_time': 1,\n            'malloc_stats': 1,\n            'inspect': 1,\n            'optimization_level': 2,\n            'pythonpath_env': '/my/path',\n            'pycache_prefix': 'env_pycache_prefix',\n            'write_bytecode': 0,\n            'verbose': 1,\n            'buffered_stdio': 0,\n            'stdio_encoding': 'iso8859-1',\n            'stdio_errors': 'replace',\n            'user_site_directory': 0,\n            'faulthandler': 1,\n            'warnoptions': ['EnvVar'],\n            'platlibdir': 'env_platlibdir',\n            'module_search_paths': self.IGNORE_CONFIG,\n        }\n        self.check_all_configs(\"test_init_python_env\", config, preconfig,\n                               api=API_PYTHON)\n\n    def test_init_env_dev_mode(self):\n        preconfig = dict(allocator=PYMEM_ALLOCATOR_DEBUG)\n        config = dict(dev_mode=1,\n                      faulthandler=1,\n                      warnoptions=['default'])\n        self.check_all_configs(\"test_init_env_dev_mode\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_env_dev_mode_alloc(self):\n        preconfig = dict(allocator=PYMEM_ALLOCATOR_MALLOC)\n        config = dict(dev_mode=1,\n                      faulthandler=1,\n                      warnoptions=['default'])\n        self.check_all_configs(\"test_init_env_dev_mode_alloc\", config, preconfig,\n                               api=API_COMPAT)\n\n    def test_init_dev_mode(self):\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_DEBUG,\n        }\n        config = {\n            'faulthandler': 1,\n            'dev_mode': 1,\n            'warnoptions': ['default'],\n        }\n        self.check_all_configs(\"test_init_dev_mode\", config, preconfig,\n                               api=API_PYTHON)\n\n    def test_preinit_parse_argv(self):\n        # Pre-initialize implicitly using argv: make sure that -X dev\n        # is used to configure the allocation in preinitialization\n        preconfig = {\n            'allocator': PYMEM_ALLOCATOR_DEBUG,\n        }\n        config = {\n            'argv': ['script.py'],\n            'orig_argv': ['python3', '-X', 'dev', 'script.py'],\n            'run_filename': os.path.abspath('script.py'),\n            'dev_mode': 1,\n            'faulthandler': 1,\n            'warnoptions': ['default'],\n            'xoptions': ['dev'],\n        }\n        self.check_all_configs(\"test_preinit_parse_argv\", config, preconfig,\n                               api=API_PYTHON)\n\n    def test_preinit_dont_parse_argv(self):\n        # -X dev must be ignored by isolated preconfiguration\n        preconfig = {\n            'isolated': 0,\n        }\n        argv = [\"python3\",\n               \"-E\", \"-I\",\n               \"-X\", \"dev\",\n               \"-X\", \"utf8\",\n               \"script.py\"]\n        config = {\n            'argv': argv,\n            'orig_argv': argv,\n            'isolated': 0,\n        }\n        self.check_all_configs(\"test_preinit_dont_parse_argv\", config, preconfig,\n                               api=API_ISOLATED)\n\n    def test_init_isolated_flag(self):\n        config = {\n            'isolated': 1,\n            'use_environment': 0,\n            'user_site_directory': 0,\n        }\n        self.check_all_configs(\"test_init_isolated_flag\", config, api=API_PYTHON)\n\n    def test_preinit_isolated1(self):\n        # _PyPreConfig.isolated=1, _PyCoreConfig.isolated not set\n        config = {\n            'isolated': 1,\n            'use_environment': 0,\n            'user_site_directory': 0,\n        }\n        self.check_all_configs(\"test_preinit_isolated1\", config, api=API_COMPAT)\n\n    def test_preinit_isolated2(self):\n        # _PyPreConfig.isolated=0, _PyCoreConfig.isolated=1\n        config = {\n            'isolated': 1,\n            'use_environment': 0,\n            'user_site_directory': 0,\n        }\n        self.check_all_configs(\"test_preinit_isolated2\", config, api=API_COMPAT)\n\n    def test_preinit_isolated_config(self):\n        self.check_all_configs(\"test_preinit_isolated_config\", api=API_ISOLATED)\n\n    def test_init_isolated_config(self):\n        self.check_all_configs(\"test_init_isolated_config\", api=API_ISOLATED)\n\n    def test_preinit_python_config(self):\n        self.check_all_configs(\"test_preinit_python_config\", api=API_PYTHON)\n\n    def test_init_python_config(self):\n        self.check_all_configs(\"test_init_python_config\", api=API_PYTHON)\n\n    def test_init_dont_configure_locale(self):\n        # _PyPreConfig.configure_locale=0\n        preconfig = {\n            'configure_locale': 0,\n            'coerce_c_locale': 0,\n        }\n        self.check_all_configs(\"test_init_dont_configure_locale\", {}, preconfig,\n                               api=API_PYTHON)\n\n    def test_init_read_set(self):\n        config = {\n            'program_name': './init_read_set',\n            'executable': 'my_executable',\n        }\n        def modify_path(path):\n            path.insert(1, \"test_path_insert1\")\n            path.append(\"test_path_append\")\n        self.check_all_configs(\"test_init_read_set\", config,\n                               api=API_PYTHON,\n                               modify_path_cb=modify_path)\n\n    def test_init_sys_add(self):\n        config = {\n            'faulthandler': 1,\n            'xoptions': [\n                'config_xoption',\n                'cmdline_xoption',\n                'sysadd_xoption',\n                'faulthandler',\n            ],\n            'warnoptions': [\n                'ignore:::cmdline_warnoption',\n                'ignore:::sysadd_warnoption',\n                'ignore:::config_warnoption',\n            ],\n            'orig_argv': ['python3',\n                          '-W', 'ignore:::cmdline_warnoption',\n                          '-X', 'cmdline_xoption'],\n        }\n        self.check_all_configs(\"test_init_sys_add\", config, api=API_PYTHON)\n\n    def test_init_run_main(self):\n        code = ('import _testinternalcapi, json; '\n                'print(json.dumps(_testinternalcapi.get_configs()))')\n        config = {\n            'argv': ['-c', 'arg2'],\n            'orig_argv': ['python3', '-c', code, 'arg2'],\n            'program_name': './python3',\n            'run_command': code + '\\n',\n            'parse_argv': 1,\n        }\n        self.check_all_configs(\"test_init_run_main\", config, api=API_PYTHON)\n\n    def test_init_main(self):\n        code = ('import _testinternalcapi, json; '\n                'print(json.dumps(_testinternalcapi.get_configs()))')\n        config = {\n            'argv': ['-c', 'arg2'],\n            'orig_argv': ['python3',\n                          '-c', code,\n                          'arg2'],\n            'program_name': './python3',\n            'run_command': code + '\\n',\n            'parse_argv': 1,\n            '_init_main': 0,\n        }\n        self.check_all_configs(\"test_init_main\", config,\n                               api=API_PYTHON,\n                               stderr=\"Run Python code before _Py_InitializeMain\")\n\n    def test_init_parse_argv(self):\n        config = {\n            'parse_argv': 1,\n            'argv': ['-c', 'arg1', '-v', 'arg3'],\n            'orig_argv': ['./argv0', '-E', '-c', 'pass', 'arg1', '-v', 'arg3'],\n            'program_name': './argv0',\n            'run_command': 'pass\\n',\n            'use_environment': 0,\n        }\n        self.check_all_configs(\"test_init_parse_argv\", config, api=API_PYTHON)\n\n    def test_init_dont_parse_argv(self):\n        pre_config = {\n            'parse_argv': 0,\n        }\n        config = {\n            'parse_argv': 0,\n            'argv': ['./argv0', '-E', '-c', 'pass', 'arg1', '-v', 'arg3'],\n            'orig_argv': ['./argv0', '-E', '-c', 'pass', 'arg1', '-v', 'arg3'],\n            'program_name': './argv0',\n        }\n        self.check_all_configs(\"test_init_dont_parse_argv\", config, pre_config,\n                               api=API_PYTHON)\n\n    def default_program_name(self, config):\n        if MS_WINDOWS:\n            program_name = 'python'\n            executable = self.test_exe\n        else:\n            program_name = 'python3'\n            if MACOS:\n                executable = self.test_exe\n            else:\n                executable = shutil.which(program_name) or ''\n        config.update({\n            'program_name': program_name,\n            'base_executable': executable,\n            'executable': executable,\n        })\n\n    def test_init_setpath(self):\n        # Test Py_SetPath()\n        config = self._get_expected_config()\n        paths = config['config']['module_search_paths']\n\n        config = {\n            'module_search_paths': paths,\n            'prefix': '',\n            'base_prefix': '',\n            'exec_prefix': '',\n            'base_exec_prefix': '',\n        }\n        self.default_program_name(config)\n        env = {'TESTPATH': os.path.pathsep.join(paths)}\n\n        self.check_all_configs(\"test_init_setpath\", config,\n                               api=API_COMPAT, env=env,\n                               ignore_stderr=True)\n\n    def test_init_setpath_config(self):\n        # Test Py_SetPath() with PyConfig\n        config = self._get_expected_config()\n        paths = config['config']['module_search_paths']\n\n        config = {\n            # set by Py_SetPath()\n            'module_search_paths': paths,\n            'prefix': '',\n            'base_prefix': '',\n            'exec_prefix': '',\n            'base_exec_prefix': '',\n            # overriden by PyConfig\n            'program_name': 'conf_program_name',\n            'base_executable': 'conf_executable',\n            'executable': 'conf_executable',\n        }\n        env = {'TESTPATH': os.path.pathsep.join(paths)}\n        self.check_all_configs(\"test_init_setpath_config\", config,\n                               api=API_PYTHON, env=env, ignore_stderr=True)\n\n    def module_search_paths(self, prefix=None, exec_prefix=None):\n        config = self._get_expected_config()\n        if prefix is None:\n            prefix = config['config']['prefix']\n        if exec_prefix is None:\n            exec_prefix = config['config']['prefix']\n        if MS_WINDOWS:\n            return config['config']['module_search_paths']\n        else:\n            ver = sys.version_info\n            return [\n                os.path.join(prefix, sys.platlibdir,\n                             f'python{ver.major}{ver.minor}.zip'),\n                os.path.join(prefix, sys.platlibdir,\n                             f'python{ver.major}.{ver.minor}'),\n                os.path.join(exec_prefix, sys.platlibdir,\n                             f'python{ver.major}.{ver.minor}', 'lib-dynload'),\n            ]\n\n    @contextlib.contextmanager\n    def tmpdir_with_python(self):\n        # Temporary directory with a copy of the Python program\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # bpo-38234: On macOS and FreeBSD, the temporary directory\n            # can be symbolic link. For example, /tmp can be a symbolic link\n            # to /var/tmp. Call realpath() to resolve all symbolic links.\n            tmpdir = os.path.realpath(tmpdir)\n\n            if MS_WINDOWS:\n                # Copy pythonXY.dll (or pythonXY_d.dll)\n                ver = sys.version_info\n                dll = f'python{ver.major}{ver.minor}'\n                dll3 = f'python{ver.major}'\n                if debug_build(sys.executable):\n                    dll += '_d'\n                    dll3 += '_d'\n                dll += '.dll'\n                dll3 += '.dll'\n                dll = os.path.join(os.path.dirname(self.test_exe), dll)\n                dll3 = os.path.join(os.path.dirname(self.test_exe), dll3)\n                dll_copy = os.path.join(tmpdir, os.path.basename(dll))\n                dll3_copy = os.path.join(tmpdir, os.path.basename(dll3))\n                shutil.copyfile(dll, dll_copy)\n                shutil.copyfile(dll3, dll3_copy)\n\n            # Copy Python program\n            exec_copy = os.path.join(tmpdir, os.path.basename(self.test_exe))\n            shutil.copyfile(self.test_exe, exec_copy)\n            shutil.copystat(self.test_exe, exec_copy)\n            self.test_exe = exec_copy\n\n            yield tmpdir\n\n    def test_init_setpythonhome(self):\n        # Test Py_SetPythonHome(home) with PYTHONPATH env var\n        config = self._get_expected_config()\n        paths = config['config']['module_search_paths']\n        paths_str = os.path.pathsep.join(paths)\n\n        for path in paths:\n            if not os.path.isdir(path):\n                continue\n            if os.path.exists(os.path.join(path, 'os.py')):\n                home = os.path.dirname(path)\n                break\n        else:\n            self.fail(f\"Unable to find home in {paths!r}\")\n\n        prefix = exec_prefix = home\n        ver = sys.version_info\n        expected_paths = self.module_search_paths(prefix=home, exec_prefix=home)\n\n        config = {\n            'home': home,\n            'module_search_paths': expected_paths,\n            'prefix': prefix,\n            'base_prefix': prefix,\n            'exec_prefix': exec_prefix,\n            'base_exec_prefix': exec_prefix,\n            'pythonpath_env': paths_str,\n        }\n        self.default_program_name(config)\n        env = {'TESTHOME': home, 'PYTHONPATH': paths_str}\n        self.check_all_configs(\"test_init_setpythonhome\", config,\n                               api=API_COMPAT, env=env)\n\n    def copy_paths_by_env(self, config):\n        all_configs = self._get_expected_config()\n        paths = all_configs['config']['module_search_paths']\n        paths_str = os.path.pathsep.join(paths)\n        config['pythonpath_env'] = paths_str\n        env = {'PYTHONPATH': paths_str}\n        return env\n\n    @unittest.skipIf(MS_WINDOWS, 'Windows does not use pybuilddir.txt')\n    def test_init_pybuilddir(self):\n        # Test path configuration with pybuilddir.txt configuration file\n\n        with self.tmpdir_with_python() as tmpdir:\n            # pybuilddir.txt is a sub-directory relative to the current\n            # directory (tmpdir)\n            subdir = 'libdir'\n            libdir = os.path.join(tmpdir, subdir)\n            os.mkdir(libdir)\n\n            filename = os.path.join(tmpdir, 'pybuilddir.txt')\n            with open(filename, \"w\", encoding=\"utf8\") as fp:\n                fp.write(subdir)\n\n            module_search_paths = self.module_search_paths()\n            module_search_paths[-1] = libdir\n\n            executable = self.test_exe\n            config = {\n                'base_executable': executable,\n                'executable': executable,\n                'module_search_paths': module_search_paths,\n            }\n            env = self.copy_paths_by_env(config)\n            self.check_all_configs(\"test_init_compat_config\", config,\n                                   api=API_COMPAT, env=env,\n                                   ignore_stderr=True, cwd=tmpdir)\n\n    def test_init_pyvenv_cfg(self):\n        # Test path configuration with pyvenv.cfg configuration file\n\n        with self.tmpdir_with_python() as tmpdir, \\\n             tempfile.TemporaryDirectory() as pyvenv_home:\n            ver = sys.version_info\n\n            if not MS_WINDOWS:\n                lib_dynload = os.path.join(pyvenv_home,\n                                           sys.platlibdir,\n                                           f'python{ver.major}.{ver.minor}',\n                                           'lib-dynload')\n                os.makedirs(lib_dynload)\n            else:\n                lib_dynload = os.path.join(pyvenv_home, 'lib')\n                os.makedirs(lib_dynload)\n                # getpathp.c uses Lib\\os.py as the LANDMARK\n                shutil.copyfile(os.__file__, os.path.join(lib_dynload, 'os.py'))\n\n            filename = os.path.join(tmpdir, 'pyvenv.cfg')\n            with open(filename, \"w\", encoding=\"utf8\") as fp:\n                print(\"home = %s\" % pyvenv_home, file=fp)\n                print(\"include-system-site-packages = false\", file=fp)\n\n            paths = self.module_search_paths()\n            if not MS_WINDOWS:\n                paths[-1] = lib_dynload\n            else:\n                for index, path in enumerate(paths):\n                    if index == 0:\n                        paths[index] = os.path.join(tmpdir, os.path.basename(path))\n                    else:\n                        paths[index] = os.path.join(pyvenv_home, os.path.basename(path))\n                paths[-1] = pyvenv_home\n\n            executable = self.test_exe\n            exec_prefix = pyvenv_home\n            config = {\n                'base_exec_prefix': exec_prefix,\n                'exec_prefix': exec_prefix,\n                'base_executable': executable,\n                'executable': executable,\n                'module_search_paths': paths,\n            }\n            if MS_WINDOWS:\n                config['base_prefix'] = pyvenv_home\n                config['prefix'] = pyvenv_home\n            env = self.copy_paths_by_env(config)\n            actual = self.check_all_configs(\"test_init_compat_config\", config,\n                                            api=API_COMPAT, env=env,\n                                            ignore_stderr=True, cwd=tmpdir)\n            if MS_WINDOWS:\n                self.assertEqual(\n                    actual['windows']['python3_dll'],\n                    os.path.join(\n                        tmpdir,\n                        os.path.basename(self.EXPECTED_CONFIG['windows']['python3_dll'])\n                    )\n                )\n\n\n    def test_global_pathconfig(self):\n        # Test C API functions getting the path configuration:\n        #\n        # - Py_GetExecPrefix()\n        # - Py_GetPath()\n        # - Py_GetPrefix()\n        # - Py_GetProgramFullPath()\n        # - Py_GetProgramName()\n        # - Py_GetPythonHome()\n        #\n        # The global path configuration (_Py_path_config) must be a copy\n        # of the path configuration of PyInterpreter.config (PyConfig).\n        ctypes = support.import_module('ctypes')\n        _testinternalcapi = support.import_module('_testinternalcapi')\n\n        def get_func(name):\n            func = getattr(ctypes.pythonapi, name)\n            func.argtypes = ()\n            func.restype = ctypes.c_wchar_p\n            return func\n\n        Py_GetPath = get_func('Py_GetPath')\n        Py_GetPrefix = get_func('Py_GetPrefix')\n        Py_GetExecPrefix = get_func('Py_GetExecPrefix')\n        Py_GetProgramName = get_func('Py_GetProgramName')\n        Py_GetProgramFullPath = get_func('Py_GetProgramFullPath')\n        Py_GetPythonHome = get_func('Py_GetPythonHome')\n\n        config = _testinternalcapi.get_configs()['config']\n\n        self.assertEqual(Py_GetPath().split(os.path.pathsep),\n                         config['module_search_paths'])\n        self.assertEqual(Py_GetPrefix(), config['prefix'])\n        self.assertEqual(Py_GetExecPrefix(), config['exec_prefix'])\n        self.assertEqual(Py_GetProgramName(), config['program_name'])\n        self.assertEqual(Py_GetProgramFullPath(), config['executable'])\n        self.assertEqual(Py_GetPythonHome(), config['home'])\n\n    def test_init_warnoptions(self):\n        # lowest to highest priority\n        warnoptions = [\n            'ignore:::PyConfig_Insert0',      # PyWideStringList_Insert(0)\n            'default',                        # PyConfig.dev_mode=1\n            'ignore:::env1',                  # PYTHONWARNINGS env var\n            'ignore:::env2',                  # PYTHONWARNINGS env var\n            'ignore:::cmdline1',              # -W opt command line option\n            'ignore:::cmdline2',              # -W opt command line option\n            'default::BytesWarning',          # PyConfig.bytes_warnings=1\n            'ignore:::PySys_AddWarnOption1',  # PySys_AddWarnOption()\n            'ignore:::PySys_AddWarnOption2',  # PySys_AddWarnOption()\n            'ignore:::PyConfig_BeforeRead',   # PyConfig.warnoptions\n            'ignore:::PyConfig_AfterRead']    # PyWideStringList_Append()\n        preconfig = dict(allocator=PYMEM_ALLOCATOR_DEBUG)\n        config = {\n            'dev_mode': 1,\n            'faulthandler': 1,\n            'bytes_warning': 1,\n            'warnoptions': warnoptions,\n            'orig_argv': ['python3',\n                          '-Wignore:::cmdline1',\n                          '-Wignore:::cmdline2'],\n        }\n        self.check_all_configs(\"test_init_warnoptions\", config, preconfig,\n                               api=API_PYTHON)\n\n    def test_get_argc_argv(self):\n        self.run_embedded_interpreter(\"test_get_argc_argv\")\n        # ignore output\n\n\nclass AuditingTests(EmbeddingTestsMixin, unittest.TestCase):\n    def test_open_code_hook(self):\n        self.run_embedded_interpreter(\"test_open_code_hook\")\n\n    def test_audit(self):\n        self.run_embedded_interpreter(\"test_audit\")\n\n    def test_audit_subinterpreter(self):\n        self.run_embedded_interpreter(\"test_audit_subinterpreter\")\n\n    def test_audit_run_command(self):\n        self.run_embedded_interpreter(\"test_audit_run_command\",\n                                      timeout=support.SHORT_TIMEOUT,\n                                      returncode=1)\n\n    def test_audit_run_file(self):\n        self.run_embedded_interpreter(\"test_audit_run_file\",\n                                      timeout=support.SHORT_TIMEOUT,\n                                      returncode=1)\n\n    def test_audit_run_interactivehook(self):\n        startup = os.path.join(self.oldcwd, support.TESTFN) + \".py\"\n        with open(startup, \"w\", encoding=\"utf-8\") as f:\n            print(\"import sys\", file=f)\n            print(\"sys.__interactivehook__ = lambda: None\", file=f)\n        try:\n            env = {**remove_python_envvars(), \"PYTHONSTARTUP\": startup}\n            self.run_embedded_interpreter(\"test_audit_run_interactivehook\",\n                                          timeout=support.SHORT_TIMEOUT,\n                                          returncode=10, env=env)\n        finally:\n            os.unlink(startup)\n\n    def test_audit_run_startup(self):\n        startup = os.path.join(self.oldcwd, support.TESTFN) + \".py\"\n        with open(startup, \"w\", encoding=\"utf-8\") as f:\n            print(\"pass\", file=f)\n        try:\n            env = {**remove_python_envvars(), \"PYTHONSTARTUP\": startup}\n            self.run_embedded_interpreter(\"test_audit_run_startup\",\n                                          timeout=support.SHORT_TIMEOUT,\n                                          returncode=10, env=env)\n        finally:\n            os.unlink(startup)\n\n    def test_audit_run_stdin(self):\n        self.run_embedded_interpreter(\"test_audit_run_stdin\",\n                                      timeout=support.SHORT_TIMEOUT,\n                                      returncode=1)\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
  },
  {
    "patch": "diff --git a/Lib/test/test_ssl.py b/Lib/test/test_ssl.py\nindex 8d98b805b49..36580d55b9e 100644\n--- a/Lib/test/test_ssl.py\n+++ b/Lib/test/test_ssl.py\n@@ -1660,6 +1660,9 @@ def test_bad_server_hostname(self):\n         with self.assertRaises(ValueError):\n             ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO(),\n                          server_hostname=\".example.org\")\n+        with self.assertRaises(TypeError):\n+            ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO(),\n+                         server_hostname=\"example.org\\x00evil.com\")\n \n \n class MemoryBIOTests(unittest.TestCase):\n",
    "commit_message": "bpo-33136: Harden ssl module against CVE-2018-8970 (GH-6229)\n\nHarden ssl module against LibreSSL CVE-2018-8970.\nX509_VERIFY_PARAM_set1_host() is called with an explicit namelen. A new test\nensures that NULL bytes are not allowed.\n\nSigned-off-by: Christian Heimes <christian@python.org>\n",
    "code_before": "# Test the support for SSL and sockets\n\nimport sys\nimport unittest\nfrom test import support\nimport socket\nimport select\nimport time\nimport datetime\nimport gc\nimport os\nimport errno\nimport pprint\nimport urllib.request\nimport threading\nimport traceback\nimport asyncore\nimport weakref\nimport platform\nimport functools\nimport sysconfig\ntry:\n    import ctypes\nexcept ImportError:\n    ctypes = None\n\nssl = support.import_module(\"ssl\")\n\n\nPROTOCOLS = sorted(ssl._PROTOCOL_NAMES)\nHOST = support.HOST\nIS_LIBRESSL = ssl.OPENSSL_VERSION.startswith('LibreSSL')\nIS_OPENSSL_1_1_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0)\nIS_OPENSSL_1_1_1 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 1)\nPY_SSL_DEFAULT_CIPHERS = sysconfig.get_config_var('PY_SSL_DEFAULT_CIPHERS')\n\ndef data_file(*name):\n    return os.path.join(os.path.dirname(__file__), *name)\n\n# The custom key and certificate files used in test_ssl are generated\n# using Lib/test/make_ssl_certs.py.\n# Other certificates are simply fetched from the Internet servers they\n# are meant to authenticate.\n\nCERTFILE = data_file(\"keycert.pem\")\nBYTES_CERTFILE = os.fsencode(CERTFILE)\nONLYCERT = data_file(\"ssl_cert.pem\")\nONLYKEY = data_file(\"ssl_key.pem\")\nBYTES_ONLYCERT = os.fsencode(ONLYCERT)\nBYTES_ONLYKEY = os.fsencode(ONLYKEY)\nCERTFILE_PROTECTED = data_file(\"keycert.passwd.pem\")\nONLYKEY_PROTECTED = data_file(\"ssl_key.passwd.pem\")\nKEY_PASSWORD = \"somepass\"\nCAPATH = data_file(\"capath\")\nBYTES_CAPATH = os.fsencode(CAPATH)\nCAFILE_NEURONIO = data_file(\"capath\", \"4e1295a3.0\")\nCAFILE_CACERT = data_file(\"capath\", \"5ed36f99.0\")\nWRONG_CERT = data_file(\"wrongcert.pem\")\n\nCERTFILE_INFO = {\n    'issuer': ((('countryName', 'XY'),),\n               (('localityName', 'Castle Anthrax'),),\n               (('organizationName', 'Python Software Foundation'),),\n               (('commonName', 'localhost'),)),\n    'notAfter': 'Jan 17 19:09:06 2028 GMT',\n    'notBefore': 'Jan 19 19:09:06 2018 GMT',\n    'serialNumber': 'F9BA076D5B6ABD9B',\n    'subject': ((('countryName', 'XY'),),\n             (('localityName', 'Castle Anthrax'),),\n             (('organizationName', 'Python Software Foundation'),),\n             (('commonName', 'localhost'),)),\n    'subjectAltName': (('DNS', 'localhost'),),\n    'version': 3\n}\n\n# empty CRL\nCRLFILE = data_file(\"revocation.crl\")\n\n# Two keys and certs signed by the same CA (for SNI tests)\nSIGNED_CERTFILE = data_file(\"keycert3.pem\")\nSIGNED_CERTFILE_HOSTNAME = 'localhost'\n\nSIGNED_CERTFILE_INFO = {\n    'OCSP': ('http://testca.pythontest.net/testca/ocsp/',),\n    'caIssuers': ('http://testca.pythontest.net/testca/pycacert.cer',),\n    'crlDistributionPoints': ('http://testca.pythontest.net/testca/revocation.crl',),\n    'issuer': ((('countryName', 'XY'),),\n            (('organizationName', 'Python Software Foundation CA'),),\n            (('commonName', 'our-ca-server'),)),\n    'notAfter': 'Nov 28 19:09:06 2027 GMT',\n    'notBefore': 'Jan 19 19:09:06 2018 GMT',\n    'serialNumber': '82EDBF41C880919C',\n    'subject': ((('countryName', 'XY'),),\n             (('localityName', 'Castle Anthrax'),),\n             (('organizationName', 'Python Software Foundation'),),\n             (('commonName', 'localhost'),)),\n    'subjectAltName': (('DNS', 'localhost'),),\n    'version': 3\n}\n\nSIGNED_CERTFILE2 = data_file(\"keycert4.pem\")\nSIGNED_CERTFILE2_HOSTNAME = 'fakehostname'\nSIGNED_CERTFILE_ECC = data_file(\"keycertecc.pem\")\nSIGNED_CERTFILE_ECC_HOSTNAME = 'localhost-ecc'\n\n# Same certificate as pycacert.pem, but without extra text in file\nSIGNING_CA = data_file(\"capath\", \"ceff1710.0\")\n# cert with all kinds of subject alt names\nALLSANFILE = data_file(\"allsans.pem\")\nIDNSANSFILE = data_file(\"idnsans.pem\")\n\nREMOTE_HOST = \"self-signed.pythontest.net\"\n\nEMPTYCERT = data_file(\"nullcert.pem\")\nBADCERT = data_file(\"badcert.pem\")\nNONEXISTINGCERT = data_file(\"XXXnonexisting.pem\")\nBADKEY = data_file(\"badkey.pem\")\nNOKIACERT = data_file(\"nokia.pem\")\nNULLBYTECERT = data_file(\"nullbytecert.pem\")\n\nDHFILE = data_file(\"dh1024.pem\")\nBYTES_DHFILE = os.fsencode(DHFILE)\n\n# Not defined in all versions of OpenSSL\nOP_NO_COMPRESSION = getattr(ssl, \"OP_NO_COMPRESSION\", 0)\nOP_SINGLE_DH_USE = getattr(ssl, \"OP_SINGLE_DH_USE\", 0)\nOP_SINGLE_ECDH_USE = getattr(ssl, \"OP_SINGLE_ECDH_USE\", 0)\nOP_CIPHER_SERVER_PREFERENCE = getattr(ssl, \"OP_CIPHER_SERVER_PREFERENCE\", 0)\nOP_ENABLE_MIDDLEBOX_COMPAT = getattr(ssl, \"OP_ENABLE_MIDDLEBOX_COMPAT\", 0)\n\n\ndef handle_error(prefix):\n    exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))\n    if support.verbose:\n        sys.stdout.write(prefix + exc_format)\n\ndef can_clear_options():\n    # 0.9.8m or higher\n    return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)\n\ndef no_sslv2_implies_sslv3_hello():\n    # 0.9.7h or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)\n\ndef have_verify_flags():\n    # 0.9.8 or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 8, 0, 15)\n\ndef _have_secp_curves():\n    if not ssl.HAS_ECDH:\n        return False\n    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    try:\n        ctx.set_ecdh_curve(\"secp384r1\")\n    except ValueError:\n        return False\n    else:\n        return True\n\n\nHAVE_SECP_CURVES = _have_secp_curves()\n\n\ndef utc_offset(): #NOTE: ignore issues like #1647654\n    # local time = utc time + utc offset\n    if time.daylight and time.localtime().tm_isdst > 0:\n        return -time.altzone  # seconds\n    return -time.timezone\n\ndef asn1time(cert_time):\n    # Some versions of OpenSSL ignore seconds, see #18207\n    # 0.9.8.i\n    if ssl._OPENSSL_API_VERSION == (0, 9, 8, 9, 15):\n        fmt = \"%b %d %H:%M:%S %Y GMT\"\n        dt = datetime.datetime.strptime(cert_time, fmt)\n        dt = dt.replace(second=0)\n        cert_time = dt.strftime(fmt)\n        # %d adds leading zero but ASN1_TIME_print() uses leading space\n        if cert_time[4] == \"0\":\n            cert_time = cert_time[:4] + \" \" + cert_time[5:]\n\n    return cert_time\n\n# Issue #9415: Ubuntu hijacks their OpenSSL and forcefully disables SSLv2\ndef skip_if_broken_ubuntu_ssl(func):\n    if hasattr(ssl, 'PROTOCOL_SSLv2'):\n        @functools.wraps(func)\n        def f(*args, **kwargs):\n            try:\n                ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n            except ssl.SSLError:\n                if (ssl.OPENSSL_VERSION_INFO == (0, 9, 8, 15, 15) and\n                    platform.linux_distribution() == ('debian', 'squeeze/sid', '')):\n                    raise unittest.SkipTest(\"Patched Ubuntu OpenSSL breaks behaviour\")\n            return func(*args, **kwargs)\n        return f\n    else:\n        return func\n\nneeds_sni = unittest.skipUnless(ssl.HAS_SNI, \"SNI support needed for this test\")\n\n\ndef test_wrap_socket(sock, ssl_version=ssl.PROTOCOL_TLS, *,\n                     cert_reqs=ssl.CERT_NONE, ca_certs=None,\n                     ciphers=None, certfile=None, keyfile=None,\n                     **kwargs):\n    context = ssl.SSLContext(ssl_version)\n    if cert_reqs is not None:\n        if cert_reqs == ssl.CERT_NONE:\n            context.check_hostname = False\n        context.verify_mode = cert_reqs\n    if ca_certs is not None:\n        context.load_verify_locations(ca_certs)\n    if certfile is not None or keyfile is not None:\n        context.load_cert_chain(certfile, keyfile)\n    if ciphers is not None:\n        context.set_ciphers(ciphers)\n    return context.wrap_socket(sock, **kwargs)\n\n\ndef testing_context(server_cert=SIGNED_CERTFILE):\n    \"\"\"Create context\n\n    client_context, server_context, hostname = testing_context()\n    \"\"\"\n    if server_cert == SIGNED_CERTFILE:\n        hostname = SIGNED_CERTFILE_HOSTNAME\n    elif server_cert == SIGNED_CERTFILE2:\n        hostname = SIGNED_CERTFILE2_HOSTNAME\n    else:\n        raise ValueError(server_cert)\n\n    client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n    client_context.load_verify_locations(SIGNING_CA)\n\n    server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    server_context.load_cert_chain(server_cert)\n    client_context.load_verify_locations(SIGNING_CA)\n\n    return client_context, server_context, hostname\n\n\nclass BasicSocketTests(unittest.TestCase):\n\n    def test_constants(self):\n        ssl.CERT_NONE\n        ssl.CERT_OPTIONAL\n        ssl.CERT_REQUIRED\n        ssl.OP_CIPHER_SERVER_PREFERENCE\n        ssl.OP_SINGLE_DH_USE\n        if ssl.HAS_ECDH:\n            ssl.OP_SINGLE_ECDH_USE\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0):\n            ssl.OP_NO_COMPRESSION\n        self.assertIn(ssl.HAS_SNI, {True, False})\n        self.assertIn(ssl.HAS_ECDH, {True, False})\n        ssl.OP_NO_SSLv2\n        ssl.OP_NO_SSLv3\n        ssl.OP_NO_TLSv1\n        ssl.OP_NO_TLSv1_3\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0, 1):\n            ssl.OP_NO_TLSv1_1\n            ssl.OP_NO_TLSv1_2\n        self.assertEqual(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv23)\n\n    def test_private_init(self):\n        with self.assertRaisesRegex(TypeError, \"public constructor\"):\n            with socket.socket() as s:\n                ssl.SSLSocket(s)\n\n    def test_str_for_enums(self):\n        # Make sure that the PROTOCOL_* constants have enum-like string\n        # reprs.\n        proto = ssl.PROTOCOL_TLS\n        self.assertEqual(str(proto), '_SSLMethod.PROTOCOL_TLS')\n        ctx = ssl.SSLContext(proto)\n        self.assertIs(ctx.protocol, proto)\n\n    def test_random(self):\n        v = ssl.RAND_status()\n        if support.verbose:\n            sys.stdout.write(\"\\n RAND_status is %d (%s)\\n\"\n                             % (v, (v and \"sufficient randomness\") or\n                                \"insufficient randomness\"))\n\n        data, is_cryptographic = ssl.RAND_pseudo_bytes(16)\n        self.assertEqual(len(data), 16)\n        self.assertEqual(is_cryptographic, v == 1)\n        if v:\n            data = ssl.RAND_bytes(16)\n            self.assertEqual(len(data), 16)\n        else:\n            self.assertRaises(ssl.SSLError, ssl.RAND_bytes, 16)\n\n        # negative num is invalid\n        self.assertRaises(ValueError, ssl.RAND_bytes, -5)\n        self.assertRaises(ValueError, ssl.RAND_pseudo_bytes, -5)\n\n        if hasattr(ssl, 'RAND_egd'):\n            self.assertRaises(TypeError, ssl.RAND_egd, 1)\n            self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)\n        ssl.RAND_add(\"this is a random string\", 75.0)\n        ssl.RAND_add(b\"this is a random bytes object\", 75.0)\n        ssl.RAND_add(bytearray(b\"this is a random bytearray object\"), 75.0)\n\n    @unittest.skipUnless(os.name == 'posix', 'requires posix')\n    def test_random_fork(self):\n        status = ssl.RAND_status()\n        if not status:\n            self.fail(\"OpenSSL's PRNG has insufficient randomness\")\n\n        rfd, wfd = os.pipe()\n        pid = os.fork()\n        if pid == 0:\n            try:\n                os.close(rfd)\n                child_random = ssl.RAND_pseudo_bytes(16)[0]\n                self.assertEqual(len(child_random), 16)\n                os.write(wfd, child_random)\n                os.close(wfd)\n            except BaseException:\n                os._exit(1)\n            else:\n                os._exit(0)\n        else:\n            os.close(wfd)\n            self.addCleanup(os.close, rfd)\n            _, status = os.waitpid(pid, 0)\n            self.assertEqual(status, 0)\n\n            child_random = os.read(rfd, 16)\n            self.assertEqual(len(child_random), 16)\n            parent_random = ssl.RAND_pseudo_bytes(16)[0]\n            self.assertEqual(len(parent_random), 16)\n\n            self.assertNotEqual(child_random, parent_random)\n\n    def test_parse_cert(self):\n        # note that this uses an 'unofficial' function in _ssl.c,\n        # provided solely for this test, to exercise the certificate\n        # parsing code\n        self.assertEqual(\n            ssl._ssl._test_decode_cert(CERTFILE),\n            CERTFILE_INFO\n        )\n        self.assertEqual(\n            ssl._ssl._test_decode_cert(SIGNED_CERTFILE),\n            SIGNED_CERTFILE_INFO\n        )\n\n        # Issue #13034: the subjectAltName in some certificates\n        # (notably projects.developer.nokia.com:443) wasn't parsed\n        p = ssl._ssl._test_decode_cert(NOKIACERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'projects.developer.nokia.com'),\n                          ('DNS', 'projects.forum.nokia.com'))\n                        )\n        # extra OCSP and AIA fields\n        self.assertEqual(p['OCSP'], ('http://ocsp.verisign.com',))\n        self.assertEqual(p['caIssuers'],\n                         ('http://SVRIntl-G3-aia.verisign.com/SVRIntlG3.cer',))\n        self.assertEqual(p['crlDistributionPoints'],\n                         ('http://SVRIntl-G3-crl.verisign.com/SVRIntlG3.crl',))\n\n    def test_parse_cert_CVE_2013_4238(self):\n        p = ssl._ssl._test_decode_cert(NULLBYTECERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        subject = ((('countryName', 'US'),),\n                   (('stateOrProvinceName', 'Oregon'),),\n                   (('localityName', 'Beaverton'),),\n                   (('organizationName', 'Python Software Foundation'),),\n                   (('organizationalUnitName', 'Python Core Development'),),\n                   (('commonName', 'null.python.org\\x00example.org'),),\n                   (('emailAddress', 'python-dev@python.org'),))\n        self.assertEqual(p['subject'], subject)\n        self.assertEqual(p['issuer'], subject)\n        if ssl._OPENSSL_API_VERSION >= (0, 9, 8):\n            san = (('DNS', 'altnull.python.org\\x00example.com'),\n                   ('email', 'null@python.org\\x00user@example.org'),\n                   ('URI', 'http://null.python.org\\x00http://example.org'),\n                   ('IP Address', '192.0.2.1'),\n                   ('IP Address', '2001:DB8:0:0:0:0:0:1\\n'))\n        else:\n            # OpenSSL 0.9.7 doesn't support IPv6 addresses in subjectAltName\n            san = (('DNS', 'altnull.python.org\\x00example.com'),\n                   ('email', 'null@python.org\\x00user@example.org'),\n                   ('URI', 'http://null.python.org\\x00http://example.org'),\n                   ('IP Address', '192.0.2.1'),\n                   ('IP Address', '<invalid>'))\n\n        self.assertEqual(p['subjectAltName'], san)\n\n    def test_parse_all_sans(self):\n        p = ssl._ssl._test_decode_cert(ALLSANFILE)\n        self.assertEqual(p['subjectAltName'],\n            (\n                ('DNS', 'allsans'),\n                ('othername', '<unsupported>'),\n                ('othername', '<unsupported>'),\n                ('email', 'user@example.org'),\n                ('DNS', 'www.example.org'),\n                ('DirName',\n                    ((('countryName', 'XY'),),\n                    (('localityName', 'Castle Anthrax'),),\n                    (('organizationName', 'Python Software Foundation'),),\n                    (('commonName', 'dirname example'),))),\n                ('URI', 'https://www.python.org/'),\n                ('IP Address', '127.0.0.1'),\n                ('IP Address', '0:0:0:0:0:0:0:1\\n'),\n                ('Registered ID', '1.2.3.4.5')\n            )\n        )\n\n    def test_DER_to_PEM(self):\n        with open(CAFILE_CACERT, 'r') as f:\n            pem = f.read()\n        d1 = ssl.PEM_cert_to_DER_cert(pem)\n        p2 = ssl.DER_cert_to_PEM_cert(d1)\n        d2 = ssl.PEM_cert_to_DER_cert(p2)\n        self.assertEqual(d1, d2)\n        if not p2.startswith(ssl.PEM_HEADER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct header:\\n%r\\n\" % p2)\n        if not p2.endswith('\\n' + ssl.PEM_FOOTER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct footer:\\n%r\\n\" % p2)\n\n    def test_openssl_version(self):\n        n = ssl.OPENSSL_VERSION_NUMBER\n        t = ssl.OPENSSL_VERSION_INFO\n        s = ssl.OPENSSL_VERSION\n        self.assertIsInstance(n, int)\n        self.assertIsInstance(t, tuple)\n        self.assertIsInstance(s, str)\n        # Some sanity checks follow\n        # >= 0.9\n        self.assertGreaterEqual(n, 0x900000)\n        # < 3.0\n        self.assertLess(n, 0x30000000)\n        major, minor, fix, patch, status = t\n        self.assertGreaterEqual(major, 0)\n        self.assertLess(major, 3)\n        self.assertGreaterEqual(minor, 0)\n        self.assertLess(minor, 256)\n        self.assertGreaterEqual(fix, 0)\n        self.assertLess(fix, 256)\n        self.assertGreaterEqual(patch, 0)\n        self.assertLessEqual(patch, 63)\n        self.assertGreaterEqual(status, 0)\n        self.assertLessEqual(status, 15)\n        # Version string as returned by {Open,Libre}SSL, the format might change\n        if IS_LIBRESSL:\n            self.assertTrue(s.startswith(\"LibreSSL {:d}\".format(major)),\n                            (s, t, hex(n)))\n        else:\n            self.assertTrue(s.startswith(\"OpenSSL {:d}.{:d}.{:d}\".format(major, minor, fix)),\n                            (s, t, hex(n)))\n\n    @support.cpython_only\n    def test_refcycle(self):\n        # Issue #7943: an SSL object doesn't create reference cycles with\n        # itself.\n        s = socket.socket(socket.AF_INET)\n        ss = test_wrap_socket(s)\n        wr = weakref.ref(ss)\n        with support.check_warnings((\"\", ResourceWarning)):\n            del ss\n        self.assertEqual(wr(), None)\n\n    def test_wrapped_unconnected(self):\n        # Methods on an unconnected SSLSocket propagate the original\n        # OSError raise by the underlying socket object.\n        s = socket.socket(socket.AF_INET)\n        with test_wrap_socket(s) as ss:\n            self.assertRaises(OSError, ss.recv, 1)\n            self.assertRaises(OSError, ss.recv_into, bytearray(b'x'))\n            self.assertRaises(OSError, ss.recvfrom, 1)\n            self.assertRaises(OSError, ss.recvfrom_into, bytearray(b'x'), 1)\n            self.assertRaises(OSError, ss.send, b'x')\n            self.assertRaises(OSError, ss.sendto, b'x', ('0.0.0.0', 0))\n            self.assertRaises(NotImplementedError, ss.sendmsg,\n                              [b'x'], (), 0, ('0.0.0.0', 0))\n\n    def test_timeout(self):\n        # Issue #8524: when creating an SSL socket, the timeout of the\n        # original socket should be retained.\n        for timeout in (None, 0.0, 5.0):\n            s = socket.socket(socket.AF_INET)\n            s.settimeout(timeout)\n            with test_wrap_socket(s) as ss:\n                self.assertEqual(timeout, ss.gettimeout())\n\n    def test_errors_sslwrap(self):\n        sock = socket.socket()\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified\",\n                        ssl.wrap_socket, sock, keyfile=CERTFILE)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                         ssl.wrap_socket, sock, server_side=True, certfile=\"\")\n        with ssl.wrap_socket(sock, server_side=True, certfile=CERTFILE) as s:\n            self.assertRaisesRegex(ValueError, \"can't connect in server-side mode\",\n                                     s.connect, (HOST, 8080))\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock,\n                    certfile=CERTFILE, keyfile=NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock,\n                    certfile=NONEXISTINGCERT, keyfile=NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n\n    def bad_cert_test(self, certfile):\n        \"\"\"Check that trying to use the given client certificate fails\"\"\"\n        certfile = os.path.join(os.path.dirname(__file__) or os.curdir,\n                                   certfile)\n        sock = socket.socket()\n        self.addCleanup(sock.close)\n        with self.assertRaises(ssl.SSLError):\n            test_wrap_socket(sock,\n                             certfile=certfile)\n\n    def test_empty_cert(self):\n        \"\"\"Wrapping with an empty cert file\"\"\"\n        self.bad_cert_test(\"nullcert.pem\")\n\n    def test_malformed_cert(self):\n        \"\"\"Wrapping with a badly formatted certificate (syntax error)\"\"\"\n        self.bad_cert_test(\"badcert.pem\")\n\n    def test_malformed_key(self):\n        \"\"\"Wrapping with a badly formatted key (syntax error)\"\"\"\n        self.bad_cert_test(\"badkey.pem\")\n\n    def test_match_hostname(self):\n        def ok(cert, hostname):\n            ssl.match_hostname(cert, hostname)\n        def fail(cert, hostname):\n            self.assertRaises(ssl.CertificateError,\n                              ssl.match_hostname, cert, hostname)\n\n        # -- Hostname matching --\n\n        cert = {'subject': ((('commonName', 'example.com'),),)}\n        ok(cert, 'example.com')\n        ok(cert, 'ExAmple.cOm')\n        fail(cert, 'www.example.com')\n        fail(cert, '.example.com')\n        fail(cert, 'example.org')\n        fail(cert, 'exampleXcom')\n\n        cert = {'subject': ((('commonName', '*.a.com'),),)}\n        ok(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        # only match wildcards when they are the only thing\n        # in left-most segment\n        cert = {'subject': ((('commonName', 'f*.com'),),)}\n        fail(cert, 'foo.com')\n        fail(cert, 'f.com')\n        fail(cert, 'bar.com')\n        fail(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.com')\n\n        # NULL bytes are bad, CVE-2013-4073\n        cert = {'subject': ((('commonName',\n                              'null.python.org\\x00example.org'),),)}\n        ok(cert, 'null.python.org\\x00example.org') # or raise an error?\n        fail(cert, 'example.org')\n        fail(cert, 'null.python.org')\n\n        # error cases with wildcards\n        cert = {'subject': ((('commonName', '*.*.a.com'),),)}\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        cert = {'subject': ((('commonName', 'a.*.com'),),)}\n        fail(cert, 'a.foo.com')\n        fail(cert, 'a..com')\n        fail(cert, 'a.com')\n\n        # wildcard doesn't match IDNA prefix 'xn--'\n        idna = 'p\u00fcthon.python.org'.encode(\"idna\").decode(\"ascii\")\n        cert = {'subject': ((('commonName', idna),),)}\n        ok(cert, idna)\n        cert = {'subject': ((('commonName', 'x*.python.org'),),)}\n        fail(cert, idna)\n        cert = {'subject': ((('commonName', 'xn--p*.python.org'),),)}\n        fail(cert, idna)\n\n        # wildcard in first fragment and  IDNA A-labels in sequent fragments\n        # are supported.\n        idna = 'www*.pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\")\n        cert = {'subject': ((('commonName', idna),),)}\n        fail(cert, 'www.pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\"))\n        fail(cert, 'www1.pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\"))\n        fail(cert, 'ftp.pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\"))\n        fail(cert, 'pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\"))\n\n        # Slightly fake real-world example\n        cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                'subject': ((('commonName', 'linuxfrz.org'),),),\n                'subjectAltName': (('DNS', 'linuxfr.org'),\n                                   ('DNS', 'linuxfr.com'),\n                                   ('othername', '<unsupported>'))}\n        ok(cert, 'linuxfr.org')\n        ok(cert, 'linuxfr.com')\n        # Not a \"DNS\" entry\n        fail(cert, '<unsupported>')\n        # When there is a subjectAltName, commonName isn't used\n        fail(cert, 'linuxfrz.org')\n\n        # A pristine real-world example\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),),\n                            (('commonName', 'mail.google.com'),))}\n        ok(cert, 'mail.google.com')\n        fail(cert, 'gmail.com')\n        # Only commonName is considered\n        fail(cert, 'California')\n\n        # -- IPv4 matching --\n        cert = {'subject': ((('commonName', 'example.com'),),),\n                'subjectAltName': (('DNS', 'example.com'),\n                                   ('IP Address', '10.11.12.13'),\n                                   ('IP Address', '14.15.16.17'))}\n        ok(cert, '10.11.12.13')\n        ok(cert, '14.15.16.17')\n        fail(cert, '14.15.16.18')\n        fail(cert, 'example.net')\n\n        # -- IPv6 matching --\n        if hasattr(socket, 'AF_INET6'):\n            cert = {'subject': ((('commonName', 'example.com'),),),\n                    'subjectAltName': (\n                        ('DNS', 'example.com'),\n                        ('IP Address', '2001:0:0:0:0:0:0:CAFE\\n'),\n                        ('IP Address', '2003:0:0:0:0:0:0:BABA\\n'))}\n            ok(cert, '2001::cafe')\n            ok(cert, '2003::baba')\n            fail(cert, '2003::bebe')\n            fail(cert, 'example.net')\n\n        # -- Miscellaneous --\n\n        # Neither commonName nor subjectAltName\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),))}\n        fail(cert, 'mail.google.com')\n\n        # No DNS entry in subjectAltName but a commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('commonName', 'mail.google.com'),)),\n                'subjectAltName': (('othername', 'blabla'), )}\n        ok(cert, 'mail.google.com')\n\n        # No DNS entry subjectAltName and no commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),)),\n                'subjectAltName': (('othername', 'blabla'),)}\n        fail(cert, 'google.com')\n\n        # Empty cert / no cert\n        self.assertRaises(ValueError, ssl.match_hostname, None, 'example.com')\n        self.assertRaises(ValueError, ssl.match_hostname, {}, 'example.com')\n\n        # Issue #17980: avoid denials of service by refusing more than one\n        # wildcard per fragment.\n        cert = {'subject': ((('commonName', 'a*b.example.com'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                \"partial wildcards in leftmost label are not supported\"):\n            ssl.match_hostname(cert, 'axxb.example.com')\n\n        cert = {'subject': ((('commonName', 'www.*.example.com'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                \"wildcard can only be present in the leftmost label\"):\n            ssl.match_hostname(cert, 'www.sub.example.com')\n\n        cert = {'subject': ((('commonName', 'a*b*.example.com'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                \"too many wildcards\"):\n            ssl.match_hostname(cert, 'axxbxxc.example.com')\n\n        cert = {'subject': ((('commonName', '*'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                \"sole wildcard without additional labels are not support\"):\n            ssl.match_hostname(cert, 'host')\n\n        cert = {'subject': ((('commonName', '*.com'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                r\"hostname 'com' doesn't match '\\*.com'\"):\n            ssl.match_hostname(cert, 'com')\n\n        # extra checks for _inet_paton()\n        for invalid in ['1', '', '1.2.3', '256.0.0.1', '127.0.0.1/24']:\n            with self.assertRaises(ValueError):\n                ssl._inet_paton(invalid)\n        for ipaddr in ['127.0.0.1', '192.168.0.1']:\n            self.assertTrue(ssl._inet_paton(ipaddr))\n        if hasattr(socket, 'AF_INET6'):\n            for ipaddr in ['::1', '2001:db8:85a3::8a2e:370:7334']:\n                self.assertTrue(ssl._inet_paton(ipaddr))\n\n    def test_server_side(self):\n        # server_hostname doesn't work for server sockets\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        with socket.socket() as sock:\n            self.assertRaises(ValueError, ctx.wrap_socket, sock, True,\n                              server_hostname=\"some.hostname\")\n\n    def test_unknown_channel_binding(self):\n        # should raise ValueError for unknown type\n        s = socket.socket(socket.AF_INET)\n        s.bind(('127.0.0.1', 0))\n        s.listen()\n        c = socket.socket(socket.AF_INET)\n        c.connect(s.getsockname())\n        with test_wrap_socket(c, do_handshake_on_connect=False) as ss:\n            with self.assertRaises(ValueError):\n                ss.get_channel_binding(\"unknown-type\")\n        s.close()\n\n    @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                         \"'tls-unique' channel binding not available\")\n    def test_tls_unique_channel_binding(self):\n        # unconnected should return None for known type\n        s = socket.socket(socket.AF_INET)\n        with test_wrap_socket(s) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n        # the same for server-side\n        s = socket.socket(socket.AF_INET)\n        with test_wrap_socket(s, server_side=True, certfile=CERTFILE) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n\n    def test_dealloc_warn(self):\n        ss = test_wrap_socket(socket.socket(socket.AF_INET))\n        r = repr(ss)\n        with self.assertWarns(ResourceWarning) as cm:\n            ss = None\n            support.gc_collect()\n        self.assertIn(r, str(cm.warning.args[0]))\n\n    def test_get_default_verify_paths(self):\n        paths = ssl.get_default_verify_paths()\n        self.assertEqual(len(paths), 6)\n        self.assertIsInstance(paths, ssl.DefaultVerifyPaths)\n\n        with support.EnvironmentVarGuard() as env:\n            env[\"SSL_CERT_DIR\"] = CAPATH\n            env[\"SSL_CERT_FILE\"] = CERTFILE\n            paths = ssl.get_default_verify_paths()\n            self.assertEqual(paths.cafile, CERTFILE)\n            self.assertEqual(paths.capath, CAPATH)\n\n    @unittest.skipUnless(sys.platform == \"win32\", \"Windows specific\")\n    def test_enum_certificates(self):\n        self.assertTrue(ssl.enum_certificates(\"CA\"))\n        self.assertTrue(ssl.enum_certificates(\"ROOT\"))\n\n        self.assertRaises(TypeError, ssl.enum_certificates)\n        self.assertRaises(WindowsError, ssl.enum_certificates, \"\")\n\n        trust_oids = set()\n        for storename in (\"CA\", \"ROOT\"):\n            store = ssl.enum_certificates(storename)\n            self.assertIsInstance(store, list)\n            for element in store:\n                self.assertIsInstance(element, tuple)\n                self.assertEqual(len(element), 3)\n                cert, enc, trust = element\n                self.assertIsInstance(cert, bytes)\n                self.assertIn(enc, {\"x509_asn\", \"pkcs_7_asn\"})\n                self.assertIsInstance(trust, (set, bool))\n                if isinstance(trust, set):\n                    trust_oids.update(trust)\n\n        serverAuth = \"1.3.6.1.5.5.7.3.1\"\n        self.assertIn(serverAuth, trust_oids)\n\n    @unittest.skipUnless(sys.platform == \"win32\", \"Windows specific\")\n    def test_enum_crls(self):\n        self.assertTrue(ssl.enum_crls(\"CA\"))\n        self.assertRaises(TypeError, ssl.enum_crls)\n        self.assertRaises(WindowsError, ssl.enum_crls, \"\")\n\n        crls = ssl.enum_crls(\"CA\")\n        self.assertIsInstance(crls, list)\n        for element in crls:\n            self.assertIsInstance(element, tuple)\n            self.assertEqual(len(element), 2)\n            self.assertIsInstance(element[0], bytes)\n            self.assertIn(element[1], {\"x509_asn\", \"pkcs_7_asn\"})\n\n\n    def test_asn1object(self):\n        expected = (129, 'serverAuth', 'TLS Web Server Authentication',\n                    '1.3.6.1.5.5.7.3.1')\n\n        val = ssl._ASN1Object('1.3.6.1.5.5.7.3.1')\n        self.assertEqual(val, expected)\n        self.assertEqual(val.nid, 129)\n        self.assertEqual(val.shortname, 'serverAuth')\n        self.assertEqual(val.longname, 'TLS Web Server Authentication')\n        self.assertEqual(val.oid, '1.3.6.1.5.5.7.3.1')\n        self.assertIsInstance(val, ssl._ASN1Object)\n        self.assertRaises(ValueError, ssl._ASN1Object, 'serverAuth')\n\n        val = ssl._ASN1Object.fromnid(129)\n        self.assertEqual(val, expected)\n        self.assertIsInstance(val, ssl._ASN1Object)\n        self.assertRaises(ValueError, ssl._ASN1Object.fromnid, -1)\n        with self.assertRaisesRegex(ValueError, \"unknown NID 100000\"):\n            ssl._ASN1Object.fromnid(100000)\n        for i in range(1000):\n            try:\n                obj = ssl._ASN1Object.fromnid(i)\n            except ValueError:\n                pass\n            else:\n                self.assertIsInstance(obj.nid, int)\n                self.assertIsInstance(obj.shortname, str)\n                self.assertIsInstance(obj.longname, str)\n                self.assertIsInstance(obj.oid, (str, type(None)))\n\n        val = ssl._ASN1Object.fromname('TLS Web Server Authentication')\n        self.assertEqual(val, expected)\n        self.assertIsInstance(val, ssl._ASN1Object)\n        self.assertEqual(ssl._ASN1Object.fromname('serverAuth'), expected)\n        self.assertEqual(ssl._ASN1Object.fromname('1.3.6.1.5.5.7.3.1'),\n                         expected)\n        with self.assertRaisesRegex(ValueError, \"unknown object 'serverauth'\"):\n            ssl._ASN1Object.fromname('serverauth')\n\n    def test_purpose_enum(self):\n        val = ssl._ASN1Object('1.3.6.1.5.5.7.3.1')\n        self.assertIsInstance(ssl.Purpose.SERVER_AUTH, ssl._ASN1Object)\n        self.assertEqual(ssl.Purpose.SERVER_AUTH, val)\n        self.assertEqual(ssl.Purpose.SERVER_AUTH.nid, 129)\n        self.assertEqual(ssl.Purpose.SERVER_AUTH.shortname, 'serverAuth')\n        self.assertEqual(ssl.Purpose.SERVER_AUTH.oid,\n                              '1.3.6.1.5.5.7.3.1')\n\n        val = ssl._ASN1Object('1.3.6.1.5.5.7.3.2')\n        self.assertIsInstance(ssl.Purpose.CLIENT_AUTH, ssl._ASN1Object)\n        self.assertEqual(ssl.Purpose.CLIENT_AUTH, val)\n        self.assertEqual(ssl.Purpose.CLIENT_AUTH.nid, 130)\n        self.assertEqual(ssl.Purpose.CLIENT_AUTH.shortname, 'clientAuth')\n        self.assertEqual(ssl.Purpose.CLIENT_AUTH.oid,\n                              '1.3.6.1.5.5.7.3.2')\n\n    def test_unsupported_dtls(self):\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.addCleanup(s.close)\n        with self.assertRaises(NotImplementedError) as cx:\n            test_wrap_socket(s, cert_reqs=ssl.CERT_NONE)\n        self.assertEqual(str(cx.exception), \"only stream sockets are supported\")\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        with self.assertRaises(NotImplementedError) as cx:\n            ctx.wrap_socket(s)\n        self.assertEqual(str(cx.exception), \"only stream sockets are supported\")\n\n    def cert_time_ok(self, timestring, timestamp):\n        self.assertEqual(ssl.cert_time_to_seconds(timestring), timestamp)\n\n    def cert_time_fail(self, timestring):\n        with self.assertRaises(ValueError):\n            ssl.cert_time_to_seconds(timestring)\n\n    @unittest.skipUnless(utc_offset(),\n                         'local time needs to be different from UTC')\n    def test_cert_time_to_seconds_timezone(self):\n        # Issue #19940: ssl.cert_time_to_seconds() returns wrong\n        #               results if local timezone is not UTC\n        self.cert_time_ok(\"May  9 00:00:00 2007 GMT\", 1178668800.0)\n        self.cert_time_ok(\"Jan  5 09:34:43 2018 GMT\", 1515144883.0)\n\n    def test_cert_time_to_seconds(self):\n        timestring = \"Jan  5 09:34:43 2018 GMT\"\n        ts = 1515144883.0\n        self.cert_time_ok(timestring, ts)\n        # accept keyword parameter, assert its name\n        self.assertEqual(ssl.cert_time_to_seconds(cert_time=timestring), ts)\n        # accept both %e and %d (space or zero generated by strftime)\n        self.cert_time_ok(\"Jan 05 09:34:43 2018 GMT\", ts)\n        # case-insensitive\n        self.cert_time_ok(\"JaN  5 09:34:43 2018 GmT\", ts)\n        self.cert_time_fail(\"Jan  5 09:34 2018 GMT\")     # no seconds\n        self.cert_time_fail(\"Jan  5 09:34:43 2018\")      # no GMT\n        self.cert_time_fail(\"Jan  5 09:34:43 2018 UTC\")  # not GMT timezone\n        self.cert_time_fail(\"Jan 35 09:34:43 2018 GMT\")  # invalid day\n        self.cert_time_fail(\"Jon  5 09:34:43 2018 GMT\")  # invalid month\n        self.cert_time_fail(\"Jan  5 24:00:00 2018 GMT\")  # invalid hour\n        self.cert_time_fail(\"Jan  5 09:60:43 2018 GMT\")  # invalid minute\n\n        newyear_ts = 1230768000.0\n        # leap seconds\n        self.cert_time_ok(\"Dec 31 23:59:60 2008 GMT\", newyear_ts)\n        # same timestamp\n        self.cert_time_ok(\"Jan  1 00:00:00 2009 GMT\", newyear_ts)\n\n        self.cert_time_ok(\"Jan  5 09:34:59 2018 GMT\", 1515144899)\n        #  allow 60th second (even if it is not a leap second)\n        self.cert_time_ok(\"Jan  5 09:34:60 2018 GMT\", 1515144900)\n        #  allow 2nd leap second for compatibility with time.strptime()\n        self.cert_time_ok(\"Jan  5 09:34:61 2018 GMT\", 1515144901)\n        self.cert_time_fail(\"Jan  5 09:34:62 2018 GMT\")  # invalid seconds\n\n        # no special treatment for the special value:\n        #   99991231235959Z (rfc 5280)\n        self.cert_time_ok(\"Dec 31 23:59:59 9999 GMT\", 253402300799.0)\n\n    @support.run_with_locale('LC_ALL', '')\n    def test_cert_time_to_seconds_locale(self):\n        # `cert_time_to_seconds()` should be locale independent\n\n        def local_february_name():\n            return time.strftime('%b', (1, 2, 3, 4, 5, 6, 0, 0, 0))\n\n        if local_february_name().lower() == 'feb':\n            self.skipTest(\"locale-specific month name needs to be \"\n                          \"different from C locale\")\n\n        # locale-independent\n        self.cert_time_ok(\"Feb  9 00:00:00 2007 GMT\", 1170979200.0)\n        self.cert_time_fail(local_february_name() + \"  9 00:00:00 2007 GMT\")\n\n    def test_connect_ex_error(self):\n        server = socket.socket(socket.AF_INET)\n        self.addCleanup(server.close)\n        port = support.bind_port(server)  # Reserve port but don't listen\n        s = test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED)\n        self.addCleanup(s.close)\n        rc = s.connect_ex((HOST, port))\n        # Issue #19919: Windows machines or VMs hosted on Windows\n        # machines sometimes return EWOULDBLOCK.\n        errors = (\n            errno.ECONNREFUSED, errno.EHOSTUNREACH, errno.ETIMEDOUT,\n            errno.EWOULDBLOCK,\n        )\n        self.assertIn(rc, errors)\n\n\nclass ContextTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_constructor(self):\n        for protocol in PROTOCOLS:\n            ssl.SSLContext(protocol)\n        ctx = ssl.SSLContext()\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertRaises(ValueError, ssl.SSLContext, -1)\n        self.assertRaises(ValueError, ssl.SSLContext, 42)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.protocol, proto)\n\n    def test_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.set_ciphers(\"ALL\")\n        ctx.set_ciphers(\"DEFAULT\")\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            ctx.set_ciphers(\"^$:,;?*'dorothyx\")\n\n    @unittest.skipUnless(PY_SSL_DEFAULT_CIPHERS == 1,\n                         \"Test applies only to Python default ciphers\")\n    def test_python_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ciphers = ctx.get_ciphers()\n        for suite in ciphers:\n            name = suite['name']\n            self.assertNotIn(\"PSK\", name)\n            self.assertNotIn(\"SRP\", name)\n            self.assertNotIn(\"MD5\", name)\n            self.assertNotIn(\"RC4\", name)\n            self.assertNotIn(\"3DES\", name)\n\n    @unittest.skipIf(ssl.OPENSSL_VERSION_INFO < (1, 0, 2, 0, 0), 'OpenSSL too old')\n    def test_get_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.set_ciphers('AESGCM')\n        names = set(d['name'] for d in ctx.get_ciphers())\n        self.assertIn('AES256-GCM-SHA384', names)\n        self.assertIn('AES128-GCM-SHA256', names)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_options(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        # OP_ALL | OP_NO_SSLv2 | OP_NO_SSLv3 is the default value\n        default = (ssl.OP_ALL | ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n        # SSLContext also enables these by default\n        default |= (OP_NO_COMPRESSION | OP_CIPHER_SERVER_PREFERENCE |\n                    OP_SINGLE_DH_USE | OP_SINGLE_ECDH_USE |\n                    OP_ENABLE_MIDDLEBOX_COMPAT)\n        self.assertEqual(default, ctx.options)\n        ctx.options |= ssl.OP_NO_TLSv1\n        self.assertEqual(default | ssl.OP_NO_TLSv1, ctx.options)\n        if can_clear_options():\n            ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)\n            self.assertEqual(default, ctx.options)\n            ctx.options = 0\n            # Ubuntu has OP_NO_SSLv3 forced on by default\n            self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)\n        else:\n            with self.assertRaises(ValueError):\n                ctx.options = 0\n\n    def test_verify_mode_protocol(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        # Default value\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        with self.assertRaises(TypeError):\n            ctx.verify_mode = None\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = 42\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self.assertFalse(ctx.check_hostname)\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        self.assertTrue(ctx.check_hostname)\n\n    def test_hostname_checks_common_name(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertTrue(ctx.hostname_checks_common_name)\n        if ssl.HAS_NEVER_CHECK_COMMON_NAME:\n            ctx.hostname_checks_common_name = True\n            self.assertTrue(ctx.hostname_checks_common_name)\n            ctx.hostname_checks_common_name = False\n            self.assertFalse(ctx.hostname_checks_common_name)\n            ctx.hostname_checks_common_name = True\n            self.assertTrue(ctx.hostname_checks_common_name)\n        else:\n            with self.assertRaises(AttributeError):\n                ctx.hostname_checks_common_name = True\n\n    @unittest.skipUnless(hasattr(ssl.SSLContext, 'minimum_version'),\n                         \"required OpenSSL 1.1.0g\")\n    def test_min_max_version(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        self.assertEqual(\n            ctx.minimum_version, ssl.TLSVersion.MINIMUM_SUPPORTED\n        )\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.MAXIMUM_SUPPORTED\n        )\n\n        ctx.minimum_version = ssl.TLSVersion.TLSv1_1\n        ctx.maximum_version = ssl.TLSVersion.TLSv1_2\n        self.assertEqual(\n            ctx.minimum_version, ssl.TLSVersion.TLSv1_1\n        )\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.TLSv1_2\n        )\n\n        ctx.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED\n        ctx.maximum_version = ssl.TLSVersion.TLSv1\n        self.assertEqual(\n            ctx.minimum_version, ssl.TLSVersion.MINIMUM_SUPPORTED\n        )\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.TLSv1\n        )\n\n        ctx.maximum_version = ssl.TLSVersion.MAXIMUM_SUPPORTED\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.MAXIMUM_SUPPORTED\n        )\n\n        ctx.maximum_version = ssl.TLSVersion.MINIMUM_SUPPORTED\n        self.assertIn(\n            ctx.maximum_version,\n            {ssl.TLSVersion.TLSv1, ssl.TLSVersion.SSLv3}\n        )\n\n        ctx.minimum_version = ssl.TLSVersion.MAXIMUM_SUPPORTED\n        self.assertIn(\n            ctx.minimum_version,\n            {ssl.TLSVersion.TLSv1_2, ssl.TLSVersion.TLSv1_3}\n        )\n\n        with self.assertRaises(ValueError):\n            ctx.minimum_version = 42\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1_1)\n\n        self.assertEqual(\n            ctx.minimum_version, ssl.TLSVersion.MINIMUM_SUPPORTED\n        )\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.MAXIMUM_SUPPORTED\n        )\n        with self.assertRaises(ValueError):\n            ctx.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED\n        with self.assertRaises(ValueError):\n            ctx.maximum_version = ssl.TLSVersion.TLSv1\n\n\n    @unittest.skipUnless(have_verify_flags(),\n                         \"verify_flags need OpenSSL > 0.9.8\")\n    def test_verify_flags(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        # default value\n        tf = getattr(ssl, \"VERIFY_X509_TRUSTED_FIRST\", 0)\n        self.assertEqual(ctx.verify_flags, ssl.VERIFY_DEFAULT | tf)\n        ctx.verify_flags = ssl.VERIFY_CRL_CHECK_LEAF\n        self.assertEqual(ctx.verify_flags, ssl.VERIFY_CRL_CHECK_LEAF)\n        ctx.verify_flags = ssl.VERIFY_CRL_CHECK_CHAIN\n        self.assertEqual(ctx.verify_flags, ssl.VERIFY_CRL_CHECK_CHAIN)\n        ctx.verify_flags = ssl.VERIFY_DEFAULT\n        self.assertEqual(ctx.verify_flags, ssl.VERIFY_DEFAULT)\n        # supports any value\n        ctx.verify_flags = ssl.VERIFY_CRL_CHECK_LEAF | ssl.VERIFY_X509_STRICT\n        self.assertEqual(ctx.verify_flags,\n                         ssl.VERIFY_CRL_CHECK_LEAF | ssl.VERIFY_X509_STRICT)\n        with self.assertRaises(TypeError):\n            ctx.verify_flags = None\n\n    def test_load_cert_chain(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        # Combined key and cert in a single file\n        ctx.load_cert_chain(CERTFILE, keyfile=None)\n        ctx.load_cert_chain(CERTFILE, keyfile=CERTFILE)\n        self.assertRaises(TypeError, ctx.load_cert_chain, keyfile=CERTFILE)\n        with self.assertRaises(OSError) as cm:\n            ctx.load_cert_chain(NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(BADCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(EMPTYCERT)\n        # Separate key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY)\n        ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)\n        ctx.load_cert_chain(certfile=BYTES_ONLYCERT, keyfile=BYTES_ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)\n        # Mismatching key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        with self.assertRaisesRegex(ssl.SSLError, \"key values mismatch\"):\n            ctx.load_cert_chain(CAFILE_CACERT, ONLYKEY)\n        # Password protected key and cert\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD.encode())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=bytearray(KEY_PASSWORD.encode()))\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD.encode())\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED,\n                            bytearray(KEY_PASSWORD.encode()))\n        with self.assertRaisesRegex(TypeError, \"should be a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=True)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=\"badpass\")\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            # openssl has a fixed limit on the password buffer.\n            # PEM_BUFSIZE is generally set to 1kb.\n            # Return a string larger than this.\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=b'a' * 102400)\n        # Password callback\n        def getpass_unicode():\n            return KEY_PASSWORD\n        def getpass_bytes():\n            return KEY_PASSWORD.encode()\n        def getpass_bytearray():\n            return bytearray(KEY_PASSWORD.encode())\n        def getpass_badpass():\n            return \"badpass\"\n        def getpass_huge():\n            return b'a' * (1024 * 1024)\n        def getpass_bad_type():\n            return 9\n        def getpass_exception():\n            raise Exception('getpass error')\n        class GetPassCallable:\n            def __call__(self):\n                return KEY_PASSWORD\n            def getpass(self):\n                return KEY_PASSWORD\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_unicode)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytes)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytearray)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=GetPassCallable())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=GetPassCallable().getpass)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_badpass)\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_huge)\n        with self.assertRaisesRegex(TypeError, \"must return a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bad_type)\n        with self.assertRaisesRegex(Exception, \"getpass error\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_exception)\n        # Make sure the password function isn't called if it isn't needed\n        ctx.load_cert_chain(CERTFILE, password=getpass_exception)\n\n    def test_load_verify_locations(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.load_verify_locations(CERTFILE)\n        ctx.load_verify_locations(cafile=CERTFILE, capath=None)\n        ctx.load_verify_locations(BYTES_CERTFILE)\n        ctx.load_verify_locations(cafile=BYTES_CERTFILE, capath=None)\n        self.assertRaises(TypeError, ctx.load_verify_locations)\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, None, None)\n        with self.assertRaises(OSError) as cm:\n            ctx.load_verify_locations(NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_verify_locations(BADCERT)\n        ctx.load_verify_locations(CERTFILE, CAPATH)\n        ctx.load_verify_locations(CERTFILE, capath=BYTES_CAPATH)\n\n        # Issue #10989: crash if the second argument type is invalid\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, True)\n\n    def test_load_verify_cadata(self):\n        # test cadata\n        with open(CAFILE_CACERT) as f:\n            cacert_pem = f.read()\n        cacert_der = ssl.PEM_cert_to_DER_cert(cacert_pem)\n        with open(CAFILE_NEURONIO) as f:\n            neuronio_pem = f.read()\n        neuronio_der = ssl.PEM_cert_to_DER_cert(neuronio_pem)\n\n        # test PEM\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 0)\n        ctx.load_verify_locations(cadata=cacert_pem)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 1)\n        ctx.load_verify_locations(cadata=neuronio_pem)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n        # cert already in hash table\n        ctx.load_verify_locations(cadata=neuronio_pem)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # combined\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        combined = \"\\n\".join((cacert_pem, neuronio_pem))\n        ctx.load_verify_locations(cadata=combined)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # with junk around the certs\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        combined = [\"head\", cacert_pem, \"other\", neuronio_pem, \"again\",\n                    neuronio_pem, \"tail\"]\n        ctx.load_verify_locations(cadata=\"\\n\".join(combined))\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # test DER\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_verify_locations(cadata=cacert_der)\n        ctx.load_verify_locations(cadata=neuronio_der)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n        # cert already in hash table\n        ctx.load_verify_locations(cadata=cacert_der)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # combined\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        combined = b\"\".join((cacert_der, neuronio_der))\n        ctx.load_verify_locations(cadata=combined)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # error cases\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertRaises(TypeError, ctx.load_verify_locations, cadata=object)\n\n        with self.assertRaisesRegex(ssl.SSLError, \"no start line\"):\n            ctx.load_verify_locations(cadata=\"broken\")\n        with self.assertRaisesRegex(ssl.SSLError, \"not enough data\"):\n            ctx.load_verify_locations(cadata=b\"broken\")\n\n\n    def test_load_dh_params(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.load_dh_params(DHFILE)\n        if os.name != 'nt':\n            ctx.load_dh_params(BYTES_DHFILE)\n        self.assertRaises(TypeError, ctx.load_dh_params)\n        self.assertRaises(TypeError, ctx.load_dh_params, None)\n        with self.assertRaises(FileNotFoundError) as cm:\n            ctx.load_dh_params(NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_session_stats(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.session_stats(), {\n                'number': 0,\n                'connect': 0,\n                'connect_good': 0,\n                'connect_renegotiate': 0,\n                'accept': 0,\n                'accept_good': 0,\n                'accept_renegotiate': 0,\n                'hits': 0,\n                'misses': 0,\n                'timeouts': 0,\n                'cache_full': 0,\n            })\n\n    def test_set_default_verify_paths(self):\n        # There's not much we can do to test that it acts as expected,\n        # so just check it doesn't crash or raise an exception.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.set_default_verify_paths()\n\n    @unittest.skipUnless(ssl.HAS_ECDH, \"ECDH disabled on this OpenSSL build\")\n    def test_set_ecdh_curve(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.set_ecdh_curve(\"prime256v1\")\n        ctx.set_ecdh_curve(b\"prime256v1\")\n        self.assertRaises(TypeError, ctx.set_ecdh_curve)\n        self.assertRaises(TypeError, ctx.set_ecdh_curve, None)\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, \"foo\")\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, b\"foo\")\n\n    @needs_sni\n    def test_sni_callback(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n\n        # set_servername_callback expects a callable, or None\n        self.assertRaises(TypeError, ctx.set_servername_callback)\n        self.assertRaises(TypeError, ctx.set_servername_callback, 4)\n        self.assertRaises(TypeError, ctx.set_servername_callback, \"\")\n        self.assertRaises(TypeError, ctx.set_servername_callback, ctx)\n\n        def dummycallback(sock, servername, ctx):\n            pass\n        ctx.set_servername_callback(None)\n        ctx.set_servername_callback(dummycallback)\n\n    @needs_sni\n    def test_sni_callback_refcycle(self):\n        # Reference cycles through the servername callback are detected\n        # and cleared.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        def dummycallback(sock, servername, ctx, cycle=ctx):\n            pass\n        ctx.set_servername_callback(dummycallback)\n        wr = weakref.ref(ctx)\n        del ctx, dummycallback\n        gc.collect()\n        self.assertIs(wr(), None)\n\n    def test_cert_store_stats(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 0})\n        ctx.load_cert_chain(CERTFILE)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 0})\n        ctx.load_verify_locations(CERTFILE)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 1})\n        ctx.load_verify_locations(CAFILE_CACERT)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 1, 'crl': 0, 'x509': 2})\n\n    def test_get_ca_certs(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        # CERTFILE is not flagged as X509v3 Basic Constraints: CA:TRUE\n        ctx.load_verify_locations(CERTFILE)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        # but CAFILE_CACERT is a CA cert\n        ctx.load_verify_locations(CAFILE_CACERT)\n        self.assertEqual(ctx.get_ca_certs(),\n            [{'issuer': ((('organizationName', 'Root CA'),),\n                         (('organizationalUnitName', 'http://www.cacert.org'),),\n                         (('commonName', 'CA Cert Signing Authority'),),\n                         (('emailAddress', 'support@cacert.org'),)),\n              'notAfter': asn1time('Mar 29 12:29:49 2033 GMT'),\n              'notBefore': asn1time('Mar 30 12:29:49 2003 GMT'),\n              'serialNumber': '00',\n              'crlDistributionPoints': ('https://www.cacert.org/revoke.crl',),\n              'subject': ((('organizationName', 'Root CA'),),\n                          (('organizationalUnitName', 'http://www.cacert.org'),),\n                          (('commonName', 'CA Cert Signing Authority'),),\n                          (('emailAddress', 'support@cacert.org'),)),\n              'version': 3}])\n\n        with open(CAFILE_CACERT) as f:\n            pem = f.read()\n        der = ssl.PEM_cert_to_DER_cert(pem)\n        self.assertEqual(ctx.get_ca_certs(True), [der])\n\n    def test_load_default_certs(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_default_certs()\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_default_certs(ssl.Purpose.SERVER_AUTH)\n        ctx.load_default_certs()\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_default_certs(ssl.Purpose.CLIENT_AUTH)\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertRaises(TypeError, ctx.load_default_certs, None)\n        self.assertRaises(TypeError, ctx.load_default_certs, 'SERVER_AUTH')\n\n    @unittest.skipIf(sys.platform == \"win32\", \"not-Windows specific\")\n    @unittest.skipIf(IS_LIBRESSL, \"LibreSSL doesn't support env vars\")\n    def test_load_default_certs_env(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        with support.EnvironmentVarGuard() as env:\n            env[\"SSL_CERT_DIR\"] = CAPATH\n            env[\"SSL_CERT_FILE\"] = CERTFILE\n            ctx.load_default_certs()\n            self.assertEqual(ctx.cert_store_stats(), {\"crl\": 0, \"x509\": 1, \"x509_ca\": 0})\n\n    @unittest.skipUnless(sys.platform == \"win32\", \"Windows specific\")\n    @unittest.skipIf(hasattr(sys, \"gettotalrefcount\"), \"Debug build does not share environment between CRTs\")\n    def test_load_default_certs_env_windows(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_default_certs()\n        stats = ctx.cert_store_stats()\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        with support.EnvironmentVarGuard() as env:\n            env[\"SSL_CERT_DIR\"] = CAPATH\n            env[\"SSL_CERT_FILE\"] = CERTFILE\n            ctx.load_default_certs()\n            stats[\"x509\"] += 1\n            self.assertEqual(ctx.cert_store_stats(), stats)\n\n    def _assert_context_options(self, ctx):\n        self.assertEqual(ctx.options & ssl.OP_NO_SSLv2, ssl.OP_NO_SSLv2)\n        if OP_NO_COMPRESSION != 0:\n            self.assertEqual(ctx.options & OP_NO_COMPRESSION,\n                             OP_NO_COMPRESSION)\n        if OP_SINGLE_DH_USE != 0:\n            self.assertEqual(ctx.options & OP_SINGLE_DH_USE,\n                             OP_SINGLE_DH_USE)\n        if OP_SINGLE_ECDH_USE != 0:\n            self.assertEqual(ctx.options & OP_SINGLE_ECDH_USE,\n                             OP_SINGLE_ECDH_USE)\n        if OP_CIPHER_SERVER_PREFERENCE != 0:\n            self.assertEqual(ctx.options & OP_CIPHER_SERVER_PREFERENCE,\n                             OP_CIPHER_SERVER_PREFERENCE)\n\n    def test_create_default_context(self):\n        ctx = ssl.create_default_context()\n\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        self.assertTrue(ctx.check_hostname)\n        self._assert_context_options(ctx)\n\n        with open(SIGNING_CA) as f:\n            cadata = f.read()\n        ctx = ssl.create_default_context(cafile=SIGNING_CA, capath=CAPATH,\n                                         cadata=cadata)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        self._assert_context_options(ctx)\n\n        ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self._assert_context_options(ctx)\n\n    def test__create_stdlib_context(self):\n        ctx = ssl._create_stdlib_context()\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self.assertFalse(ctx.check_hostname)\n        self._assert_context_options(ctx)\n\n        ctx = ssl._create_stdlib_context(ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self._assert_context_options(ctx)\n\n        ctx = ssl._create_stdlib_context(ssl.PROTOCOL_TLSv1,\n                                         cert_reqs=ssl.CERT_REQUIRED,\n                                         check_hostname=True)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        self.assertTrue(ctx.check_hostname)\n        self._assert_context_options(ctx)\n\n        ctx = ssl._create_stdlib_context(purpose=ssl.Purpose.CLIENT_AUTH)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self._assert_context_options(ctx)\n\n    def test_check_hostname(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n\n        # Auto set CERT_REQUIRED\n        ctx.check_hostname = True\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.check_hostname = False\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n\n        # Changing verify_mode does not affect check_hostname\n        ctx.check_hostname = False\n        ctx.verify_mode = ssl.CERT_NONE\n        ctx.check_hostname = False\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        # Auto set\n        ctx.check_hostname = True\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n\n        ctx.check_hostname = False\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        ctx.check_hostname = False\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        # keep CERT_OPTIONAL\n        ctx.check_hostname = True\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n\n        # Cannot set CERT_NONE with check_hostname enabled\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = ssl.CERT_NONE\n        ctx.check_hostname = False\n        self.assertFalse(ctx.check_hostname)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n\n    def test_context_client_server(self):\n        # PROTOCOL_TLS_CLIENT has sane defaults\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n\n        # PROTOCOL_TLS_SERVER has different but also sane defaults\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n\n    def test_context_custom_class(self):\n        class MySSLSocket(ssl.SSLSocket):\n            pass\n\n        class MySSLObject(ssl.SSLObject):\n            pass\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.sslsocket_class = MySSLSocket\n        ctx.sslobject_class = MySSLObject\n\n        with ctx.wrap_socket(socket.socket(), server_side=True) as sock:\n            self.assertIsInstance(sock, MySSLSocket)\n        obj = ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO())\n        self.assertIsInstance(obj, MySSLObject)\n\n\nclass SSLErrorTests(unittest.TestCase):\n\n    def test_str(self):\n        # The str() of a SSLError doesn't include the errno\n        e = ssl.SSLError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n        # Same for a subclass\n        e = ssl.SSLZeroReturnError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n\n    def test_lib_reason(self):\n        # Test the library and reason attributes\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n        self.assertEqual(cm.exception.library, 'PEM')\n        self.assertEqual(cm.exception.reason, 'NO_START_LINE')\n        s = str(cm.exception)\n        self.assertTrue(s.startswith(\"[PEM: NO_START_LINE] no start line\"), s)\n\n    def test_subclass(self):\n        # Check that the appropriate SSLError subclass is raised\n        # (this only tests one of them)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.check_hostname = False\n        ctx.verify_mode = ssl.CERT_NONE\n        with socket.socket() as s:\n            s.bind((\"127.0.0.1\", 0))\n            s.listen()\n            c = socket.socket()\n            c.connect(s.getsockname())\n            c.setblocking(False)\n            with ctx.wrap_socket(c, False, do_handshake_on_connect=False) as c:\n                with self.assertRaises(ssl.SSLWantReadError) as cm:\n                    c.do_handshake()\n                s = str(cm.exception)\n                self.assertTrue(s.startswith(\"The operation did not complete (read)\"), s)\n                # For compatibility\n                self.assertEqual(cm.exception.errno, ssl.SSL_ERROR_WANT_READ)\n\n\n    def test_bad_server_hostname(self):\n        ctx = ssl.create_default_context()\n        with self.assertRaises(ValueError):\n            ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO(),\n                         server_hostname=\"\")\n        with self.assertRaises(ValueError):\n            ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO(),\n                         server_hostname=\".example.org\")\n\n\nclass MemoryBIOTests(unittest.TestCase):\n\n    def test_read_write(self):\n        bio = ssl.MemoryBIO()\n        bio.write(b'foo')\n        self.assertEqual(bio.read(), b'foo')\n        self.assertEqual(bio.read(), b'')\n        bio.write(b'foo')\n        bio.write(b'bar')\n        self.assertEqual(bio.read(), b'foobar')\n        self.assertEqual(bio.read(), b'')\n        bio.write(b'baz')\n        self.assertEqual(bio.read(2), b'ba')\n        self.assertEqual(bio.read(1), b'z')\n        self.assertEqual(bio.read(1), b'')\n\n    def test_eof(self):\n        bio = ssl.MemoryBIO()\n        self.assertFalse(bio.eof)\n        self.assertEqual(bio.read(), b'')\n        self.assertFalse(bio.eof)\n        bio.write(b'foo')\n        self.assertFalse(bio.eof)\n        bio.write_eof()\n        self.assertFalse(bio.eof)\n        self.assertEqual(bio.read(2), b'fo')\n        self.assertFalse(bio.eof)\n        self.assertEqual(bio.read(1), b'o')\n        self.assertTrue(bio.eof)\n        self.assertEqual(bio.read(), b'')\n        self.assertTrue(bio.eof)\n\n    def test_pending(self):\n        bio = ssl.MemoryBIO()\n        self.assertEqual(bio.pending, 0)\n        bio.write(b'foo')\n        self.assertEqual(bio.pending, 3)\n        for i in range(3):\n            bio.read(1)\n            self.assertEqual(bio.pending, 3-i-1)\n        for i in range(3):\n            bio.write(b'x')\n            self.assertEqual(bio.pending, i+1)\n        bio.read()\n        self.assertEqual(bio.pending, 0)\n\n    def test_buffer_types(self):\n        bio = ssl.MemoryBIO()\n        bio.write(b'foo')\n        self.assertEqual(bio.read(), b'foo')\n        bio.write(bytearray(b'bar'))\n        self.assertEqual(bio.read(), b'bar')\n        bio.write(memoryview(b'baz'))\n        self.assertEqual(bio.read(), b'baz')\n\n    def test_error_types(self):\n        bio = ssl.MemoryBIO()\n        self.assertRaises(TypeError, bio.write, 'foo')\n        self.assertRaises(TypeError, bio.write, None)\n        self.assertRaises(TypeError, bio.write, True)\n        self.assertRaises(TypeError, bio.write, 1)\n\n\nclass SSLObjectTests(unittest.TestCase):\n    def test_private_init(self):\n        bio = ssl.MemoryBIO()\n        with self.assertRaisesRegex(TypeError, \"public constructor\"):\n            ssl.SSLObject(bio, bio)\n\n\nclass SimpleBackgroundTests(unittest.TestCase):\n    \"\"\"Tests that connect to a simple server running in the background\"\"\"\n\n    def setUp(self):\n        server = ThreadedEchoServer(SIGNED_CERTFILE)\n        self.server_addr = (HOST, server.port)\n        server.__enter__()\n        self.addCleanup(server.__exit__, None, None, None)\n\n    def test_connect(self):\n        with test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_NONE) as s:\n            s.connect(self.server_addr)\n            self.assertEqual({}, s.getpeercert())\n            self.assertFalse(s.server_side)\n\n        # this should succeed because we specify the root cert\n        with test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED,\n                            ca_certs=SIGNING_CA) as s:\n            s.connect(self.server_addr)\n            self.assertTrue(s.getpeercert())\n            self.assertFalse(s.server_side)\n\n    def test_connect_fail(self):\n        # This should fail because we have no verification certs. Connection\n        # failure crashes ThreadedEchoServer, so run this in an independent\n        # test method.\n        s = test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED)\n        self.addCleanup(s.close)\n        self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                               s.connect, self.server_addr)\n\n    def test_connect_ex(self):\n        # Issue #11326: check connect_ex() implementation\n        s = test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED,\n                            ca_certs=SIGNING_CA)\n        self.addCleanup(s.close)\n        self.assertEqual(0, s.connect_ex(self.server_addr))\n        self.assertTrue(s.getpeercert())\n\n    def test_non_blocking_connect_ex(self):\n        # Issue #11326: non-blocking connect_ex() should allow handshake\n        # to proceed after the socket gets ready.\n        s = test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED,\n                            ca_certs=SIGNING_CA,\n                            do_handshake_on_connect=False)\n        self.addCleanup(s.close)\n        s.setblocking(False)\n        rc = s.connect_ex(self.server_addr)\n        # EWOULDBLOCK under Windows, EINPROGRESS elsewhere\n        self.assertIn(rc, (0, errno.EINPROGRESS, errno.EWOULDBLOCK))\n        # Wait for connect to finish\n        select.select([], [s], [], 5.0)\n        # Non-blocking handshake\n        while True:\n            try:\n                s.do_handshake()\n                break\n            except ssl.SSLWantReadError:\n                select.select([s], [], [], 5.0)\n            except ssl.SSLWantWriteError:\n                select.select([], [s], [], 5.0)\n        # SSL established\n        self.assertTrue(s.getpeercert())\n\n    def test_connect_with_context(self):\n        # Same as test_connect, but with a separately created context\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            self.assertEqual({}, s.getpeercert())\n        # Same with a server hostname\n        with ctx.wrap_socket(socket.socket(socket.AF_INET),\n                            server_hostname=\"dummy\") as s:\n            s.connect(self.server_addr)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        # This should succeed because we specify the root cert\n        ctx.load_verify_locations(SIGNING_CA)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n\n    def test_connect_with_context_fail(self):\n        # This should fail because we have no verification certs. Connection\n        # failure crashes ThreadedEchoServer, so run this in an independent\n        # test method.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n        self.addCleanup(s.close)\n        self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                s.connect, self.server_addr)\n\n    def test_connect_capath(self):\n        # Verify server certificates using the `capath` argument\n        # NOTE: the subject hashing algorithm has been changed between\n        # OpenSSL 0.9.8n and 1.0.0, as a result the capath directory must\n        # contain both versions of each certificate (same content, different\n        # filename) for this test to be portable across OpenSSL releases.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        ctx.load_verify_locations(capath=CAPATH)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n        # Same with a bytes `capath` argument\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        ctx.load_verify_locations(capath=BYTES_CAPATH)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n\n    def test_connect_cadata(self):\n        with open(SIGNING_CA) as f:\n            pem = f.read()\n        der = ssl.PEM_cert_to_DER_cert(pem)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        # TODO: fix TLSv1.3 support\n        ctx.options |= ssl.OP_NO_TLSv1_3\n        ctx.load_verify_locations(cadata=pem)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n\n        # same with DER\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        # TODO: fix TLSv1.3 support\n        ctx.options |= ssl.OP_NO_TLSv1_3\n        ctx.load_verify_locations(cadata=der)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n\n    @unittest.skipIf(os.name == \"nt\", \"Can't use a socket as a file under Windows\")\n    def test_makefile_close(self):\n        # Issue #5238: creating a file-like object with makefile() shouldn't\n        # delay closing the underlying \"real socket\" (here tested with its\n        # file descriptor, hence skipping the test under Windows).\n        ss = test_wrap_socket(socket.socket(socket.AF_INET))\n        ss.connect(self.server_addr)\n        fd = ss.fileno()\n        f = ss.makefile()\n        f.close()\n        # The fd is still open\n        os.read(fd, 0)\n        # Closing the SSL socket should close the fd too\n        ss.close()\n        gc.collect()\n        with self.assertRaises(OSError) as e:\n            os.read(fd, 0)\n        self.assertEqual(e.exception.errno, errno.EBADF)\n\n    def test_non_blocking_handshake(self):\n        s = socket.socket(socket.AF_INET)\n        s.connect(self.server_addr)\n        s.setblocking(False)\n        s = test_wrap_socket(s,\n                            cert_reqs=ssl.CERT_NONE,\n                            do_handshake_on_connect=False)\n        self.addCleanup(s.close)\n        count = 0\n        while True:\n            try:\n                count += 1\n                s.do_handshake()\n                break\n            except ssl.SSLWantReadError:\n                select.select([s], [], [])\n            except ssl.SSLWantWriteError:\n                select.select([], [s], [])\n        if support.verbose:\n            sys.stdout.write(\"\\nNeeded %d calls to do_handshake() to establish session.\\n\" % count)\n\n    def test_get_server_certificate(self):\n        _test_get_server_certificate(self, *self.server_addr, cert=SIGNING_CA)\n\n    def test_get_server_certificate_fail(self):\n        # Connection failure crashes ThreadedEchoServer, so run this in an\n        # independent test method\n        _test_get_server_certificate_fail(self, *self.server_addr)\n\n    def test_ciphers(self):\n        with test_wrap_socket(socket.socket(socket.AF_INET),\n                             cert_reqs=ssl.CERT_NONE, ciphers=\"ALL\") as s:\n            s.connect(self.server_addr)\n        with test_wrap_socket(socket.socket(socket.AF_INET),\n                             cert_reqs=ssl.CERT_NONE, ciphers=\"DEFAULT\") as s:\n            s.connect(self.server_addr)\n        # Error checking can happen at instantiation or when connecting\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            with socket.socket(socket.AF_INET) as sock:\n                s = test_wrap_socket(sock,\n                                    cert_reqs=ssl.CERT_NONE, ciphers=\"^$:,;?*'dorothyx\")\n                s.connect(self.server_addr)\n\n    def test_get_ca_certs_capath(self):\n        # capath certs are loaded on request\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_verify_locations(capath=CAPATH)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        with ctx.wrap_socket(socket.socket(socket.AF_INET),\n                             server_hostname='localhost') as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n        self.assertEqual(len(ctx.get_ca_certs()), 1)\n\n    @needs_sni\n    def test_context_setget(self):\n        # Check that the context of a connected socket can be replaced.\n        ctx1 = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx1.load_verify_locations(capath=CAPATH)\n        ctx2 = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx2.load_verify_locations(capath=CAPATH)\n        s = socket.socket(socket.AF_INET)\n        with ctx1.wrap_socket(s, server_hostname='localhost') as ss:\n            ss.connect(self.server_addr)\n            self.assertIs(ss.context, ctx1)\n            self.assertIs(ss._sslobj.context, ctx1)\n            ss.context = ctx2\n            self.assertIs(ss.context, ctx2)\n            self.assertIs(ss._sslobj.context, ctx2)\n\n    def ssl_io_loop(self, sock, incoming, outgoing, func, *args, **kwargs):\n        # A simple IO loop. Call func(*args) depending on the error we get\n        # (WANT_READ or WANT_WRITE) move data between the socket and the BIOs.\n        timeout = kwargs.get('timeout', 10)\n        deadline = time.monotonic() + timeout\n        count = 0\n        while True:\n            if time.monotonic() > deadline:\n                self.fail(\"timeout\")\n            errno = None\n            count += 1\n            try:\n                ret = func(*args)\n            except ssl.SSLError as e:\n                if e.errno not in (ssl.SSL_ERROR_WANT_READ,\n                                   ssl.SSL_ERROR_WANT_WRITE):\n                    raise\n                errno = e.errno\n            # Get any data from the outgoing BIO irrespective of any error, and\n            # send it to the socket.\n            buf = outgoing.read()\n            sock.sendall(buf)\n            # If there's no error, we're done. For WANT_READ, we need to get\n            # data from the socket and put it in the incoming BIO.\n            if errno is None:\n                break\n            elif errno == ssl.SSL_ERROR_WANT_READ:\n                buf = sock.recv(32768)\n                if buf:\n                    incoming.write(buf)\n                else:\n                    incoming.write_eof()\n        if support.verbose:\n            sys.stdout.write(\"Needed %d calls to complete %s().\\n\"\n                             % (count, func.__name__))\n        return ret\n\n    def test_bio_handshake(self):\n        sock = socket.socket(socket.AF_INET)\n        self.addCleanup(sock.close)\n        sock.connect(self.server_addr)\n        incoming = ssl.MemoryBIO()\n        outgoing = ssl.MemoryBIO()\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.load_verify_locations(SIGNING_CA)\n        sslobj = ctx.wrap_bio(incoming, outgoing, False,\n                              SIGNED_CERTFILE_HOSTNAME)\n        self.assertIs(sslobj._sslobj.owner, sslobj)\n        self.assertIsNone(sslobj.cipher())\n        self.assertIsNone(sslobj.version())\n        self.assertIsNotNone(sslobj.shared_ciphers())\n        self.assertRaises(ValueError, sslobj.getpeercert)\n        if 'tls-unique' in ssl.CHANNEL_BINDING_TYPES:\n            self.assertIsNone(sslobj.get_channel_binding('tls-unique'))\n        self.ssl_io_loop(sock, incoming, outgoing, sslobj.do_handshake)\n        self.assertTrue(sslobj.cipher())\n        self.assertIsNotNone(sslobj.shared_ciphers())\n        self.assertIsNotNone(sslobj.version())\n        self.assertTrue(sslobj.getpeercert())\n        if 'tls-unique' in ssl.CHANNEL_BINDING_TYPES:\n            self.assertTrue(sslobj.get_channel_binding('tls-unique'))\n        try:\n            self.ssl_io_loop(sock, incoming, outgoing, sslobj.unwrap)\n        except ssl.SSLSyscallError:\n            # If the server shuts down the TCP connection without sending a\n            # secure shutdown message, this is reported as SSL_ERROR_SYSCALL\n            pass\n        self.assertRaises(ssl.SSLError, sslobj.write, b'foo')\n\n    def test_bio_read_write_data(self):\n        sock = socket.socket(socket.AF_INET)\n        self.addCleanup(sock.close)\n        sock.connect(self.server_addr)\n        incoming = ssl.MemoryBIO()\n        outgoing = ssl.MemoryBIO()\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_NONE\n        sslobj = ctx.wrap_bio(incoming, outgoing, False)\n        self.ssl_io_loop(sock, incoming, outgoing, sslobj.do_handshake)\n        req = b'FOO\\n'\n        self.ssl_io_loop(sock, incoming, outgoing, sslobj.write, req)\n        buf = self.ssl_io_loop(sock, incoming, outgoing, sslobj.read, 1024)\n        self.assertEqual(buf, b'foo\\n')\n        self.ssl_io_loop(sock, incoming, outgoing, sslobj.unwrap)\n\n\nclass NetworkedTests(unittest.TestCase):\n\n    def test_timeout_connect_ex(self):\n        # Issue #12065: on a timeout, connect_ex() should return the original\n        # errno (mimicking the behaviour of non-SSL sockets).\n        with support.transient_internet(REMOTE_HOST):\n            s = test_wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                do_handshake_on_connect=False)\n            self.addCleanup(s.close)\n            s.settimeout(0.0000001)\n            rc = s.connect_ex((REMOTE_HOST, 443))\n            if rc == 0:\n                self.skipTest(\"REMOTE_HOST responded too quickly\")\n            self.assertIn(rc, (errno.EAGAIN, errno.EWOULDBLOCK))\n\n    @unittest.skipUnless(support.IPV6_ENABLED, 'Needs IPv6')\n    def test_get_server_certificate_ipv6(self):\n        with support.transient_internet('ipv6.google.com'):\n            _test_get_server_certificate(self, 'ipv6.google.com', 443)\n            _test_get_server_certificate_fail(self, 'ipv6.google.com', 443)\n\n\ndef _test_get_server_certificate(test, host, port, cert=None):\n    pem = ssl.get_server_certificate((host, port))\n    if not pem:\n        test.fail(\"No server certificate on %s:%s!\" % (host, port))\n\n    pem = ssl.get_server_certificate((host, port), ca_certs=cert)\n    if not pem:\n        test.fail(\"No server certificate on %s:%s!\" % (host, port))\n    if support.verbose:\n        sys.stdout.write(\"\\nVerified certificate for %s:%s is\\n%s\\n\" % (host, port ,pem))\n\ndef _test_get_server_certificate_fail(test, host, port):\n    try:\n        pem = ssl.get_server_certificate((host, port), ca_certs=CERTFILE)\n    except ssl.SSLError as x:\n        #should fail\n        if support.verbose:\n            sys.stdout.write(\"%s\\n\" % x)\n    else:\n        test.fail(\"Got server certificate %s for %s:%s!\" % (pem, host, port))\n\n\nfrom test.ssl_servers import make_https_server\n\nclass ThreadedEchoServer(threading.Thread):\n\n    class ConnectionHandler(threading.Thread):\n\n        \"\"\"A mildly complicated class, because we want it to work both\n        with and without the SSL wrapper around the socket connection, so\n        that we can test the STARTTLS functionality.\"\"\"\n\n        def __init__(self, server, connsock, addr):\n            self.server = server\n            self.running = False\n            self.sock = connsock\n            self.addr = addr\n            self.sock.setblocking(1)\n            self.sslconn = None\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def wrap_conn(self):\n            try:\n                self.sslconn = self.server.context.wrap_socket(\n                    self.sock, server_side=True)\n                self.server.selected_npn_protocols.append(self.sslconn.selected_npn_protocol())\n                self.server.selected_alpn_protocols.append(self.sslconn.selected_alpn_protocol())\n            except (ssl.SSLError, ConnectionResetError, OSError) as e:\n                # We treat ConnectionResetError as though it were an\n                # SSLError - OpenSSL on Ubuntu abruptly closes the\n                # connection when asked to use an unsupported protocol.\n                #\n                # OSError may occur with wrong protocols, e.g. both\n                # sides use PROTOCOL_TLS_SERVER.\n                #\n                # XXX Various errors can have happened here, for example\n                # a mismatching protocol version, an invalid certificate,\n                # or a low-level bug. This should be made more discriminating.\n                #\n                # bpo-31323: Store the exception as string to prevent\n                # a reference leak: server -> conn_errors -> exception\n                # -> traceback -> self (ConnectionHandler) -> server\n                self.server.conn_errors.append(str(e))\n                if self.server.chatty:\n                    handle_error(\"\\n server:  bad connection attempt from \" + repr(self.addr) + \":\\n\")\n                self.running = False\n                self.server.stop()\n                self.close()\n                return False\n            else:\n                self.server.shared_ciphers.append(self.sslconn.shared_ciphers())\n                if self.server.context.verify_mode == ssl.CERT_REQUIRED:\n                    cert = self.sslconn.getpeercert()\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" client cert is \" + pprint.pformat(cert) + \"\\n\")\n                    cert_binary = self.sslconn.getpeercert(True)\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" cert binary is \" + str(len(cert_binary)) + \" bytes\\n\")\n                cipher = self.sslconn.cipher()\n                if support.verbose and self.server.chatty:\n                    sys.stdout.write(\" server: connection cipher is now \" + str(cipher) + \"\\n\")\n                    sys.stdout.write(\" server: selected protocol is now \"\n                            + str(self.sslconn.selected_npn_protocol()) + \"\\n\")\n                return True\n\n        def read(self):\n            if self.sslconn:\n                return self.sslconn.read()\n            else:\n                return self.sock.recv(1024)\n\n        def write(self, bytes):\n            if self.sslconn:\n                return self.sslconn.write(bytes)\n            else:\n                return self.sock.send(bytes)\n\n        def close(self):\n            if self.sslconn:\n                self.sslconn.close()\n            else:\n                self.sock.close()\n\n        def run(self):\n            self.running = True\n            if not self.server.starttls_server:\n                if not self.wrap_conn():\n                    return\n            while self.running:\n                try:\n                    msg = self.read()\n                    stripped = msg.strip()\n                    if not stripped:\n                        # eof, so quit this handler\n                        self.running = False\n                        try:\n                            self.sock = self.sslconn.unwrap()\n                        except OSError:\n                            # Many tests shut the TCP connection down\n                            # without an SSL shutdown. This causes\n                            # unwrap() to raise OSError with errno=0!\n                            pass\n                        else:\n                            self.sslconn = None\n                        self.close()\n                    elif stripped == b'over':\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: client closed connection\\n\")\n                        self.close()\n                        return\n                    elif (self.server.starttls_server and\n                          stripped == b'STARTTLS'):\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: read STARTTLS from client, sending OK...\\n\")\n                        self.write(b\"OK\\n\")\n                        if not self.wrap_conn():\n                            return\n                    elif (self.server.starttls_server and self.sslconn\n                          and stripped == b'ENDTLS'):\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: read ENDTLS from client, sending OK...\\n\")\n                        self.write(b\"OK\\n\")\n                        self.sock = self.sslconn.unwrap()\n                        self.sslconn = None\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: connection is now unencrypted...\\n\")\n                    elif stripped == b'CB tls-unique':\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: read CB tls-unique from client, sending our CB data...\\n\")\n                        data = self.sslconn.get_channel_binding(\"tls-unique\")\n                        self.write(repr(data).encode(\"us-ascii\") + b\"\\n\")\n                    else:\n                        if (support.verbose and\n                            self.server.connectionchatty):\n                            ctype = (self.sslconn and \"encrypted\") or \"unencrypted\"\n                            sys.stdout.write(\" server: read %r (%s), sending back %r (%s)...\\n\"\n                                             % (msg, ctype, msg.lower(), ctype))\n                        self.write(msg.lower())\n                except OSError:\n                    if self.server.chatty:\n                        handle_error(\"Test server failure:\\n\")\n                    self.close()\n                    self.running = False\n                    # normally, we'd just stop here, but for the test\n                    # harness, we want to stop the server\n                    self.server.stop()\n\n    def __init__(self, certificate=None, ssl_version=None,\n                 certreqs=None, cacerts=None,\n                 chatty=True, connectionchatty=False, starttls_server=False,\n                 npn_protocols=None, alpn_protocols=None,\n                 ciphers=None, context=None):\n        if context:\n            self.context = context\n        else:\n            self.context = ssl.SSLContext(ssl_version\n                                          if ssl_version is not None\n                                          else ssl.PROTOCOL_TLS_SERVER)\n            self.context.verify_mode = (certreqs if certreqs is not None\n                                        else ssl.CERT_NONE)\n            if cacerts:\n                self.context.load_verify_locations(cacerts)\n            if certificate:\n                self.context.load_cert_chain(certificate)\n            if npn_protocols:\n                self.context.set_npn_protocols(npn_protocols)\n            if alpn_protocols:\n                self.context.set_alpn_protocols(alpn_protocols)\n            if ciphers:\n                self.context.set_ciphers(ciphers)\n        self.chatty = chatty\n        self.connectionchatty = connectionchatty\n        self.starttls_server = starttls_server\n        self.sock = socket.socket()\n        self.port = support.bind_port(self.sock)\n        self.flag = None\n        self.active = False\n        self.selected_npn_protocols = []\n        self.selected_alpn_protocols = []\n        self.shared_ciphers = []\n        self.conn_errors = []\n        threading.Thread.__init__(self)\n        self.daemon = True\n\n    def __enter__(self):\n        self.start(threading.Event())\n        self.flag.wait()\n        return self\n\n    def __exit__(self, *args):\n        self.stop()\n        self.join()\n\n    def start(self, flag=None):\n        self.flag = flag\n        threading.Thread.start(self)\n\n    def run(self):\n        self.sock.settimeout(0.05)\n        self.sock.listen()\n        self.active = True\n        if self.flag:\n            # signal an event\n            self.flag.set()\n        while self.active:\n            try:\n                newconn, connaddr = self.sock.accept()\n                if support.verbose and self.chatty:\n                    sys.stdout.write(' server:  new connection from '\n                                     + repr(connaddr) + '\\n')\n                handler = self.ConnectionHandler(self, newconn, connaddr)\n                handler.start()\n                handler.join()\n            except socket.timeout:\n                pass\n            except KeyboardInterrupt:\n                self.stop()\n        self.sock.close()\n\n    def stop(self):\n        self.active = False\n\nclass AsyncoreEchoServer(threading.Thread):\n\n    # this one's based on asyncore.dispatcher\n\n    class EchoServer (asyncore.dispatcher):\n\n        class ConnectionHandler(asyncore.dispatcher_with_send):\n\n            def __init__(self, conn, certfile):\n                self.socket = test_wrap_socket(conn, server_side=True,\n                                              certfile=certfile,\n                                              do_handshake_on_connect=False)\n                asyncore.dispatcher_with_send.__init__(self, self.socket)\n                self._ssl_accepting = True\n                self._do_ssl_handshake()\n\n            def readable(self):\n                if isinstance(self.socket, ssl.SSLSocket):\n                    while self.socket.pending() > 0:\n                        self.handle_read_event()\n                return True\n\n            def _do_ssl_handshake(self):\n                try:\n                    self.socket.do_handshake()\n                except (ssl.SSLWantReadError, ssl.SSLWantWriteError):\n                    return\n                except ssl.SSLEOFError:\n                    return self.handle_close()\n                except ssl.SSLError:\n                    raise\n                except OSError as err:\n                    if err.args[0] == errno.ECONNABORTED:\n                        return self.handle_close()\n                else:\n                    self._ssl_accepting = False\n\n            def handle_read(self):\n                if self._ssl_accepting:\n                    self._do_ssl_handshake()\n                else:\n                    data = self.recv(1024)\n                    if support.verbose:\n                        sys.stdout.write(\" server:  read %s from client\\n\" % repr(data))\n                    if not data:\n                        self.close()\n                    else:\n                        self.send(data.lower())\n\n            def handle_close(self):\n                self.close()\n                if support.verbose:\n                    sys.stdout.write(\" server:  closed connection %s\\n\" % self.socket)\n\n            def handle_error(self):\n                raise\n\n        def __init__(self, certfile):\n            self.certfile = certfile\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.port = support.bind_port(sock, '')\n            asyncore.dispatcher.__init__(self, sock)\n            self.listen(5)\n\n        def handle_accepted(self, sock_obj, addr):\n            if support.verbose:\n                sys.stdout.write(\" server:  new connection from %s:%s\\n\" %addr)\n            self.ConnectionHandler(sock_obj, self.certfile)\n\n        def handle_error(self):\n            raise\n\n    def __init__(self, certfile):\n        self.flag = None\n        self.active = False\n        self.server = self.EchoServer(certfile)\n        self.port = self.server.port\n        threading.Thread.__init__(self)\n        self.daemon = True\n\n    def __str__(self):\n        return \"<%s %s>\" % (self.__class__.__name__, self.server)\n\n    def __enter__(self):\n        self.start(threading.Event())\n        self.flag.wait()\n        return self\n\n    def __exit__(self, *args):\n        if support.verbose:\n            sys.stdout.write(\" cleanup: stopping server.\\n\")\n        self.stop()\n        if support.verbose:\n            sys.stdout.write(\" cleanup: joining server thread.\\n\")\n        self.join()\n        if support.verbose:\n            sys.stdout.write(\" cleanup: successfully joined.\\n\")\n        # make sure that ConnectionHandler is removed from socket_map\n        asyncore.close_all(ignore_all=True)\n\n    def start (self, flag=None):\n        self.flag = flag\n        threading.Thread.start(self)\n\n    def run(self):\n        self.active = True\n        if self.flag:\n            self.flag.set()\n        while self.active:\n            try:\n                asyncore.loop(1)\n            except:\n                pass\n\n    def stop(self):\n        self.active = False\n        self.server.close()\n\ndef server_params_test(client_context, server_context, indata=b\"FOO\\n\",\n                       chatty=True, connectionchatty=False, sni_name=None,\n                       session=None):\n    \"\"\"\n    Launch a server, connect a client to it and try various reads\n    and writes.\n    \"\"\"\n    stats = {}\n    server = ThreadedEchoServer(context=server_context,\n                                chatty=chatty,\n                                connectionchatty=False)\n    with server:\n        with client_context.wrap_socket(socket.socket(),\n                server_hostname=sni_name, session=session) as s:\n            s.connect((HOST, server.port))\n            for arg in [indata, bytearray(indata), memoryview(indata)]:\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  sending %r...\\n\" % indata)\n                s.write(arg)\n                outdata = s.read()\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                if outdata != indata.lower():\n                    raise AssertionError(\n                        \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                        % (outdata[:20], len(outdata),\n                           indata[:20].lower(), len(indata)))\n            s.write(b\"over\\n\")\n            if connectionchatty:\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n            stats.update({\n                'compression': s.compression(),\n                'cipher': s.cipher(),\n                'peercert': s.getpeercert(),\n                'client_alpn_protocol': s.selected_alpn_protocol(),\n                'client_npn_protocol': s.selected_npn_protocol(),\n                'version': s.version(),\n                'session_reused': s.session_reused,\n                'session': s.session,\n            })\n            s.close()\n        stats['server_alpn_protocols'] = server.selected_alpn_protocols\n        stats['server_npn_protocols'] = server.selected_npn_protocols\n        stats['server_shared_ciphers'] = server.shared_ciphers\n    return stats\n\ndef try_protocol_combo(server_protocol, client_protocol, expect_success,\n                       certsreqs=None, server_options=0, client_options=0):\n    \"\"\"\n    Try to SSL-connect using *client_protocol* to *server_protocol*.\n    If *expect_success* is true, assert that the connection succeeds,\n    if it's false, assert that the connection fails.\n    Also, if *expect_success* is a string, assert that it is the protocol\n    version actually used by the connection.\n    \"\"\"\n    if certsreqs is None:\n        certsreqs = ssl.CERT_NONE\n    certtype = {\n        ssl.CERT_NONE: \"CERT_NONE\",\n        ssl.CERT_OPTIONAL: \"CERT_OPTIONAL\",\n        ssl.CERT_REQUIRED: \"CERT_REQUIRED\",\n    }[certsreqs]\n    if support.verbose:\n        formatstr = (expect_success and \" %s->%s %s\\n\") or \" {%s->%s} %s\\n\"\n        sys.stdout.write(formatstr %\n                         (ssl.get_protocol_name(client_protocol),\n                          ssl.get_protocol_name(server_protocol),\n                          certtype))\n    client_context = ssl.SSLContext(client_protocol)\n    client_context.options |= client_options\n    server_context = ssl.SSLContext(server_protocol)\n    server_context.options |= server_options\n\n    # NOTE: we must enable \"ALL\" ciphers on the client, otherwise an\n    # SSLv23 client will send an SSLv3 hello (rather than SSLv2)\n    # starting from OpenSSL 1.0.0 (see issue #8322).\n    if client_context.protocol == ssl.PROTOCOL_TLS:\n        client_context.set_ciphers(\"ALL\")\n\n    for ctx in (client_context, server_context):\n        ctx.verify_mode = certsreqs\n        ctx.load_cert_chain(SIGNED_CERTFILE)\n        ctx.load_verify_locations(SIGNING_CA)\n    try:\n        stats = server_params_test(client_context, server_context,\n                                   chatty=False, connectionchatty=False)\n    # Protocol mismatch can result in either an SSLError, or a\n    # \"Connection reset by peer\" error.\n    except ssl.SSLError:\n        if expect_success:\n            raise\n    except OSError as e:\n        if expect_success or e.errno != errno.ECONNRESET:\n            raise\n    else:\n        if not expect_success:\n            raise AssertionError(\n                \"Client protocol %s succeeded with server protocol %s!\"\n                % (ssl.get_protocol_name(client_protocol),\n                   ssl.get_protocol_name(server_protocol)))\n        elif (expect_success is not True\n              and expect_success != stats['version']):\n            raise AssertionError(\"version mismatch: expected %r, got %r\"\n                                 % (expect_success, stats['version']))\n\n\nclass ThreadedTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_echo(self):\n        \"\"\"Basic test of an SSL client connecting to a server\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        for protocol in PROTOCOLS:\n            if protocol in {ssl.PROTOCOL_TLS_CLIENT, ssl.PROTOCOL_TLS_SERVER}:\n                continue\n            with self.subTest(protocol=ssl._PROTOCOL_NAMES[protocol]):\n                context = ssl.SSLContext(protocol)\n                context.load_cert_chain(CERTFILE)\n                server_params_test(context, context,\n                                   chatty=True, connectionchatty=True)\n\n        client_context, server_context, hostname = testing_context()\n\n        with self.subTest(client=ssl.PROTOCOL_TLS_CLIENT, server=ssl.PROTOCOL_TLS_SERVER):\n            server_params_test(client_context=client_context,\n                               server_context=server_context,\n                               chatty=True, connectionchatty=True,\n                               sni_name=hostname)\n\n        client_context.check_hostname = False\n        with self.subTest(client=ssl.PROTOCOL_TLS_SERVER, server=ssl.PROTOCOL_TLS_CLIENT):\n            with self.assertRaises(ssl.SSLError) as e:\n                server_params_test(client_context=server_context,\n                                   server_context=client_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n            self.assertIn('called a function you should not call',\n                          str(e.exception))\n\n        with self.subTest(client=ssl.PROTOCOL_TLS_SERVER, server=ssl.PROTOCOL_TLS_SERVER):\n            with self.assertRaises(ssl.SSLError) as e:\n                server_params_test(client_context=server_context,\n                                   server_context=server_context,\n                                   chatty=True, connectionchatty=True)\n            self.assertIn('called a function you should not call',\n                          str(e.exception))\n\n        with self.subTest(client=ssl.PROTOCOL_TLS_CLIENT, server=ssl.PROTOCOL_TLS_CLIENT):\n            with self.assertRaises(ssl.SSLError) as e:\n                server_params_test(client_context=server_context,\n                                   server_context=client_context,\n                                   chatty=True, connectionchatty=True)\n            self.assertIn('called a function you should not call',\n                          str(e.exception))\n\n    def test_getpeercert(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        client_context, server_context, hostname = testing_context()\n        server = ThreadedEchoServer(context=server_context, chatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            do_handshake_on_connect=False,\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                # getpeercert() raise ValueError while the handshake isn't\n                # done.\n                with self.assertRaises(ValueError):\n                    s.getpeercert()\n                s.do_handshake()\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()\n                if support.verbose:\n                    sys.stdout.write(pprint.pformat(cert) + '\\n')\n                    sys.stdout.write(\"Connection cipher is \" + str(cipher) + '.\\n')\n                if 'subject' not in cert:\n                    self.fail(\"No subject field in certificate: %s.\" %\n                              pprint.pformat(cert))\n                if ((('organizationName', 'Python Software Foundation'),)\n                    not in cert['subject']):\n                    self.fail(\n                        \"Missing or invalid 'organizationName' field in certificate subject; \"\n                        \"should be 'Python Software Foundation'.\")\n                self.assertIn('notBefore', cert)\n                self.assertIn('notAfter', cert)\n                before = ssl.cert_time_to_seconds(cert['notBefore'])\n                after = ssl.cert_time_to_seconds(cert['notAfter'])\n                self.assertLess(before, after)\n\n    @unittest.skipUnless(have_verify_flags(),\n                        \"verify_flags need OpenSSL > 0.9.8\")\n    def test_crl_check(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        client_context, server_context, hostname = testing_context()\n\n        tf = getattr(ssl, \"VERIFY_X509_TRUSTED_FIRST\", 0)\n        self.assertEqual(client_context.verify_flags, ssl.VERIFY_DEFAULT | tf)\n\n        # VERIFY_DEFAULT should pass\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n\n        # VERIFY_CRL_CHECK_LEAF without a loaded CRL file fails\n        client_context.verify_flags |= ssl.VERIFY_CRL_CHECK_LEAF\n\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                with self.assertRaisesRegex(ssl.SSLError,\n                                            \"certificate verify failed\"):\n                    s.connect((HOST, server.port))\n\n        # now load a CRL file. The CRL file is signed by the CA.\n        client_context.load_verify_locations(CRLFILE)\n\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n\n    def test_check_hostname(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        client_context, server_context, hostname = testing_context()\n\n        # correct hostname should verify\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n\n        # incorrect hostname should raise an exception\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=\"invalid\") as s:\n                with self.assertRaisesRegex(\n                        ssl.CertificateError,\n                        \"Hostname mismatch, certificate is not valid for 'invalid'.\"):\n                    s.connect((HOST, server.port))\n\n        # missing server_hostname arg should cause an exception, too\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with socket.socket() as s:\n                with self.assertRaisesRegex(ValueError,\n                                            \"check_hostname requires server_hostname\"):\n                    client_context.wrap_socket(s)\n\n    def test_ecc_cert(self):\n        client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        client_context.load_verify_locations(SIGNING_CA)\n        client_context.set_ciphers(\n            'TLS13-AES-128-GCM-SHA256:TLS13-CHACHA20-POLY1305-SHA256:'\n            'ECDHE:ECDSA:!NULL:!aRSA'\n        )\n        hostname = SIGNED_CERTFILE_ECC_HOSTNAME\n\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        # load ECC cert\n        server_context.load_cert_chain(SIGNED_CERTFILE_ECC)\n\n        # correct hostname should verify\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()[0].split('-')\n                self.assertTrue(cipher[:2], ('ECDHE', 'ECDSA'))\n\n    def test_dual_rsa_ecc(self):\n        client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        client_context.load_verify_locations(SIGNING_CA)\n        # TODO: fix TLSv1.3 once SSLContext can restrict signature\n        #       algorithms.\n        client_context.options |= ssl.OP_NO_TLSv1_3\n        # only ECDSA certs\n        client_context.set_ciphers('ECDHE:ECDSA:!NULL:!aRSA')\n        hostname = SIGNED_CERTFILE_ECC_HOSTNAME\n\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        # load ECC and RSA key/cert pairs\n        server_context.load_cert_chain(SIGNED_CERTFILE_ECC)\n        server_context.load_cert_chain(SIGNED_CERTFILE)\n\n        # correct hostname should verify\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()[0].split('-')\n                self.assertTrue(cipher[:2], ('ECDHE', 'ECDSA'))\n\n    def test_check_hostname_idn(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        server_context.load_cert_chain(IDNSANSFILE)\n        # TODO: fix TLSv1.3 support\n        server_context.options |= ssl.OP_NO_TLSv1_3\n\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        context.verify_mode = ssl.CERT_REQUIRED\n        context.check_hostname = True\n        context.load_verify_locations(SIGNING_CA)\n\n        # correct hostname should verify, when specified in several\n        # different ways\n        idn_hostnames = [\n            ('k\u00f6nig.idn.pythontest.net',\n             'xn--knig-5qa.idn.pythontest.net'),\n            ('xn--knig-5qa.idn.pythontest.net',\n             'xn--knig-5qa.idn.pythontest.net'),\n            (b'xn--knig-5qa.idn.pythontest.net',\n             'xn--knig-5qa.idn.pythontest.net'),\n\n            ('k\u00f6nigsg\u00e4\u00dfchen.idna2003.pythontest.net',\n             'xn--knigsgsschen-lcb0w.idna2003.pythontest.net'),\n            ('xn--knigsgsschen-lcb0w.idna2003.pythontest.net',\n             'xn--knigsgsschen-lcb0w.idna2003.pythontest.net'),\n            (b'xn--knigsgsschen-lcb0w.idna2003.pythontest.net',\n             'xn--knigsgsschen-lcb0w.idna2003.pythontest.net'),\n\n            # ('k\u00f6nigsg\u00e4\u00dfchen.idna2008.pythontest.net',\n            #  'xn--knigsgchen-b4a3dun.idna2008.pythontest.net'),\n            ('xn--knigsgchen-b4a3dun.idna2008.pythontest.net',\n             'xn--knigsgchen-b4a3dun.idna2008.pythontest.net'),\n            (b'xn--knigsgchen-b4a3dun.idna2008.pythontest.net',\n             'xn--knigsgchen-b4a3dun.idna2008.pythontest.net'),\n\n        ]\n        for server_hostname, expected_hostname in idn_hostnames:\n            server = ThreadedEchoServer(context=server_context, chatty=True)\n            with server:\n                with context.wrap_socket(socket.socket(),\n                                         server_hostname=server_hostname) as s:\n                    self.assertEqual(s.server_hostname, expected_hostname)\n                    s.connect((HOST, server.port))\n                    cert = s.getpeercert()\n                    self.assertEqual(s.server_hostname, expected_hostname)\n                    self.assertTrue(cert, \"Can't get peer certificate.\")\n\n        # incorrect hostname should raise an exception\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with context.wrap_socket(socket.socket(),\n                                     server_hostname=\"python.example.org\") as s:\n                with self.assertRaises(ssl.CertificateError):\n                    s.connect((HOST, server.port))\n\n    def test_wrong_cert(self):\n        \"\"\"Connecting when the server rejects the client's certificate\n\n        Launch a server with CERT_REQUIRED, and check that trying to\n        connect to it with a wrong client certificate fails.\n        \"\"\"\n        client_context, server_context, hostname = testing_context()\n        # load client cert\n        client_context.load_cert_chain(WRONG_CERT)\n        # require TLS client authentication\n        server_context.verify_mode = ssl.CERT_REQUIRED\n        # TODO: fix TLSv1.3 support\n        # With TLS 1.3, test fails with exception in server thread\n        server_context.options |= ssl.OP_NO_TLSv1_3\n\n        server = ThreadedEchoServer(\n            context=server_context, chatty=True, connectionchatty=True,\n        )\n\n        with server, \\\n                client_context.wrap_socket(socket.socket(),\n                                           server_hostname=hostname) as s:\n            try:\n                # Expect either an SSL error about the server rejecting\n                # the connection, or a low-level connection reset (which\n                # sometimes happens on Windows)\n                s.connect((HOST, server.port))\n            except ssl.SSLError as e:\n                if support.verbose:\n                    sys.stdout.write(\"\\nSSLError is %r\\n\" % e)\n            except OSError as e:\n                if e.errno != errno.ECONNRESET:\n                    raise\n                if support.verbose:\n                    sys.stdout.write(\"\\nsocket.error is %r\\n\" % e)\n            else:\n                self.fail(\"Use of invalid cert should have failed!\")\n\n    def test_rude_shutdown(self):\n        \"\"\"A brutal shutdown of an SSL server should raise an OSError\n        in the client when attempting handshake.\n        \"\"\"\n        listener_ready = threading.Event()\n        listener_gone = threading.Event()\n\n        s = socket.socket()\n        port = support.bind_port(s, HOST)\n\n        # `listener` runs in a thread.  It sits in an accept() until\n        # the main thread connects.  Then it rudely closes the socket,\n        # and sets Event `listener_gone` to let the main thread know\n        # the socket is gone.\n        def listener():\n            s.listen()\n            listener_ready.set()\n            newsock, addr = s.accept()\n            newsock.close()\n            s.close()\n            listener_gone.set()\n\n        def connector():\n            listener_ready.wait()\n            with socket.socket() as c:\n                c.connect((HOST, port))\n                listener_gone.wait()\n                try:\n                    ssl_sock = test_wrap_socket(c)\n                except OSError:\n                    pass\n                else:\n                    self.fail('connecting to closed SSL socket should have failed')\n\n        t = threading.Thread(target=listener)\n        t.start()\n        try:\n            connector()\n        finally:\n            t.join()\n\n    def test_ssl_cert_verify_error(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        server_context.load_cert_chain(SIGNED_CERTFILE)\n\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with context.wrap_socket(socket.socket(),\n                                     server_hostname=SIGNED_CERTFILE_HOSTNAME) as s:\n                try:\n                    s.connect((HOST, server.port))\n                except ssl.SSLError as e:\n                    msg = 'unable to get local issuer certificate'\n                    self.assertIsInstance(e, ssl.SSLCertVerificationError)\n                    self.assertEqual(e.verify_code, 20)\n                    self.assertEqual(e.verify_message, msg)\n                    self.assertIn(msg, repr(e))\n                    self.assertIn('certificate verify failed', repr(e))\n\n    @skip_if_broken_ubuntu_ssl\n    @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv2'),\n                         \"OpenSSL is compiled without SSLv2 support\")\n    def test_protocol_sslv2(self):\n        \"\"\"Connecting to an SSLv2 server with various client options\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_REQUIRED)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLS, False)\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLSv1, False)\n        # SSLv23 client with specific SSL options\n        if no_sslv2_implies_sslv3_hello():\n            # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLS, False,\n                               client_options=ssl.OP_NO_SSLv2)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_SSLv3)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_TLSv1)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_PROTOCOL_TLS(self):\n        \"\"\"Connecting to an SSLv23 server with various client options\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try:\n                try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv2, True)\n            except OSError as x:\n                # this fails on some older versions of OpenSSL (0.9.7l, for instance)\n                if support.verbose:\n                    sys.stdout.write(\n                        \" SSL2 client to SSL23 server test unexpectedly failed:\\n %s\\n\"\n                        % str(x))\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS, True)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1, 'TLSv1')\n\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv3, False, ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS, True, ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1, 'TLSv1', ssl.CERT_OPTIONAL)\n\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv3, False, ssl.CERT_REQUIRED)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS, True, ssl.CERT_REQUIRED)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1, 'TLSv1', ssl.CERT_REQUIRED)\n\n        # Server with specific SSL options\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv3, False,\n                           server_options=ssl.OP_NO_SSLv3)\n        # Will choose TLSv1\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS, True,\n                           server_options=ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1, False,\n                           server_options=ssl.OP_NO_TLSv1)\n\n\n    @skip_if_broken_ubuntu_ssl\n    @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv3'),\n                         \"OpenSSL is compiled without SSLv3 support\")\n    def test_protocol_sslv3(self):\n        \"\"\"Connecting to an SSLv3 server with various client options\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, 'SSLv3')\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, 'SSLv3', ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, 'SSLv3', ssl.CERT_REQUIRED)\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv2, False)\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_SSLv3)\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLSv1, False)\n        if no_sslv2_implies_sslv3_hello():\n            # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLS,\n                               False, client_options=ssl.OP_NO_SSLv2)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol_tlsv1(self):\n        \"\"\"Connecting to a TLSv1 server with various client options\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, 'TLSv1')\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, 'TLSv1', ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, 'TLSv1', ssl.CERT_REQUIRED)\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv2, False)\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_TLSv1)\n\n    @skip_if_broken_ubuntu_ssl\n    @unittest.skipUnless(hasattr(ssl, \"PROTOCOL_TLSv1_1\"),\n                         \"TLS version 1.1 not supported.\")\n    def test_protocol_tlsv1_1(self):\n        \"\"\"Connecting to a TLSv1.1 server with various client options.\n           Testing against older TLS versions.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1_1, 'TLSv1.1')\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv2, False)\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_TLSv1_1)\n\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1_1, 'TLSv1.1')\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1_1, False)\n\n    @skip_if_broken_ubuntu_ssl\n    @unittest.skipUnless(hasattr(ssl, \"PROTOCOL_TLSv1_2\"),\n                         \"TLS version 1.2 not supported.\")\n    def test_protocol_tlsv1_2(self):\n        \"\"\"Connecting to a TLSv1.2 server with various client options.\n           Testing against older TLS versions.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1_2, 'TLSv1.2',\n                           server_options=ssl.OP_NO_SSLv3|ssl.OP_NO_SSLv2,\n                           client_options=ssl.OP_NO_SSLv3|ssl.OP_NO_SSLv2,)\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv2, False)\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_TLSv1_2)\n\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1_2, 'TLSv1.2')\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1_2, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1_1, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1_2, False)\n\n    def test_starttls(self):\n        \"\"\"Switching from clear text to encrypted and back again.\"\"\"\n        msgs = (b\"msg 1\", b\"MSG 2\", b\"STARTTLS\", b\"MSG 3\", b\"msg 4\", b\"ENDTLS\", b\"msg 5\", b\"msg 6\")\n\n        server = ThreadedEchoServer(CERTFILE,\n                                    starttls_server=True,\n                                    chatty=True,\n                                    connectionchatty=True)\n        wrapped = False\n        with server:\n            s = socket.socket()\n            s.setblocking(1)\n            s.connect((HOST, server.port))\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            for indata in msgs:\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client:  sending %r...\\n\" % indata)\n                if wrapped:\n                    conn.write(indata)\n                    outdata = conn.read()\n                else:\n                    s.send(indata)\n                    outdata = s.recv(1024)\n                msg = outdata.strip().lower()\n                if indata == b\"STARTTLS\" and msg.startswith(b\"ok\"):\n                    # STARTTLS ok, switch to secure mode\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  read %r from server, starting TLS...\\n\"\n                            % msg)\n                    conn = test_wrap_socket(s)\n                    wrapped = True\n                elif indata == b\"ENDTLS\" and msg.startswith(b\"ok\"):\n                    # ENDTLS ok, switch back to clear text\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  read %r from server, ending TLS...\\n\"\n                            % msg)\n                    s = conn.unwrap()\n                    wrapped = False\n                else:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  read %r from server\\n\" % msg)\n            if support.verbose:\n                sys.stdout.write(\" client:  closing connection.\\n\")\n            if wrapped:\n                conn.write(b\"over\\n\")\n            else:\n                s.send(b\"over\\n\")\n            if wrapped:\n                conn.close()\n            else:\n                s.close()\n\n    def test_socketserver(self):\n        \"\"\"Using socketserver to create and manage SSL connections.\"\"\"\n        server = make_https_server(self, certfile=SIGNED_CERTFILE)\n        # try to connect\n        if support.verbose:\n            sys.stdout.write('\\n')\n        with open(CERTFILE, 'rb') as f:\n            d1 = f.read()\n        d2 = ''\n        # now fetch the same data from the HTTPS server\n        url = 'https://localhost:%d/%s' % (\n            server.port, os.path.split(CERTFILE)[1])\n        context = ssl.create_default_context(cafile=SIGNING_CA)\n        f = urllib.request.urlopen(url, context=context)\n        try:\n            dlen = f.info().get(\"content-length\")\n            if dlen and (int(dlen) > 0):\n                d2 = f.read(int(dlen))\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client: read %d bytes from remote server '%s'\\n\"\n                        % (len(d2), server))\n        finally:\n            f.close()\n        self.assertEqual(d1, d2)\n\n    def test_asyncore_server(self):\n        \"\"\"Check the example asyncore integration.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        indata = b\"FOO\\n\"\n        server = AsyncoreEchoServer(CERTFILE)\n        with server:\n            s = test_wrap_socket(socket.socket())\n            s.connect(('127.0.0.1', server.port))\n            if support.verbose:\n                sys.stdout.write(\n                    \" client:  sending %r...\\n\" % indata)\n            s.write(indata)\n            outdata = s.read()\n            if support.verbose:\n                sys.stdout.write(\" client:  read %r\\n\" % outdata)\n            if outdata != indata.lower():\n                self.fail(\n                    \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                    % (outdata[:20], len(outdata),\n                       indata[:20].lower(), len(indata)))\n            s.write(b\"over\\n\")\n            if support.verbose:\n                sys.stdout.write(\" client:  closing connection.\\n\")\n            s.close()\n            if support.verbose:\n                sys.stdout.write(\" client:  connection closed.\\n\")\n\n    def test_recv_send(self):\n        \"\"\"Test recv(), send() and friends.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLS_SERVER,\n                                    cacerts=CERTFILE,\n                                    chatty=True,\n                                    connectionchatty=False)\n        with server:\n            s = test_wrap_socket(socket.socket(),\n                                server_side=False,\n                                certfile=CERTFILE,\n                                ca_certs=CERTFILE,\n                                cert_reqs=ssl.CERT_NONE,\n                                ssl_version=ssl.PROTOCOL_TLS_CLIENT)\n            s.connect((HOST, server.port))\n            # helper methods for standardising recv* method signatures\n            def _recv_into():\n                b = bytearray(b\"\\0\"*100)\n                count = s.recv_into(b)\n                return b[:count]\n\n            def _recvfrom_into():\n                b = bytearray(b\"\\0\"*100)\n                count, addr = s.recvfrom_into(b)\n                return b[:count]\n\n            # (name, method, expect success?, *args, return value func)\n            send_methods = [\n                ('send', s.send, True, [], len),\n                ('sendto', s.sendto, False, [\"some.address\"], len),\n                ('sendall', s.sendall, True, [], lambda x: None),\n            ]\n            # (name, method, whether to expect success, *args)\n            recv_methods = [\n                ('recv', s.recv, True, []),\n                ('recvfrom', s.recvfrom, False, [\"some.address\"]),\n                ('recv_into', _recv_into, True, []),\n                ('recvfrom_into', _recvfrom_into, False, []),\n            ]\n            data_prefix = \"PREFIX_\"\n\n            for (meth_name, send_meth, expect_success, args,\n                    ret_val_meth) in send_methods:\n                indata = (data_prefix + meth_name).encode('ascii')\n                try:\n                    ret = send_meth(indata, *args)\n                    msg = \"sending with {}\".format(meth_name)\n                    self.assertEqual(ret, ret_val_meth(indata), msg=msg)\n                    outdata = s.read()\n                    if outdata != indata.lower():\n                        self.fail(\n                            \"While sending with <<{name:s}>> bad data \"\n                            \"<<{outdata:r}>> ({nout:d}) received; \"\n                            \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                name=meth_name, outdata=outdata[:20],\n                                nout=len(outdata),\n                                indata=indata[:20], nin=len(indata)\n                            )\n                        )\n                except ValueError as e:\n                    if expect_success:\n                        self.fail(\n                            \"Failed to send with method <<{name:s}>>; \"\n                            \"expected to succeed.\\n\".format(name=meth_name)\n                        )\n                    if not str(e).startswith(meth_name):\n                        self.fail(\n                            \"Method <<{name:s}>> failed with unexpected \"\n                            \"exception message: {exp:s}\\n\".format(\n                                name=meth_name, exp=e\n                            )\n                        )\n\n            for meth_name, recv_meth, expect_success, args in recv_methods:\n                indata = (data_prefix + meth_name).encode('ascii')\n                try:\n                    s.send(indata)\n                    outdata = recv_meth(*args)\n                    if outdata != indata.lower():\n                        self.fail(\n                            \"While receiving with <<{name:s}>> bad data \"\n                            \"<<{outdata:r}>> ({nout:d}) received; \"\n                            \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                name=meth_name, outdata=outdata[:20],\n                                nout=len(outdata),\n                                indata=indata[:20], nin=len(indata)\n                            )\n                        )\n                except ValueError as e:\n                    if expect_success:\n                        self.fail(\n                            \"Failed to receive with method <<{name:s}>>; \"\n                            \"expected to succeed.\\n\".format(name=meth_name)\n                        )\n                    if not str(e).startswith(meth_name):\n                        self.fail(\n                            \"Method <<{name:s}>> failed with unexpected \"\n                            \"exception message: {exp:s}\\n\".format(\n                                name=meth_name, exp=e\n                            )\n                        )\n                    # consume data\n                    s.read()\n\n            # read(-1, buffer) is supported, even though read(-1) is not\n            data = b\"data\"\n            s.send(data)\n            buffer = bytearray(len(data))\n            self.assertEqual(s.read(-1, buffer), len(data))\n            self.assertEqual(buffer, data)\n\n            # sendall accepts bytes-like objects\n            if ctypes is not None:\n                ubyte = ctypes.c_ubyte * len(data)\n                byteslike = ubyte.from_buffer_copy(data)\n                s.sendall(byteslike)\n                self.assertEqual(s.read(), data)\n\n            # Make sure sendmsg et al are disallowed to avoid\n            # inadvertent disclosure of data and/or corruption\n            # of the encrypted data stream\n            self.assertRaises(NotImplementedError, s.sendmsg, [b\"data\"])\n            self.assertRaises(NotImplementedError, s.recvmsg, 100)\n            self.assertRaises(NotImplementedError,\n                              s.recvmsg_into, bytearray(100))\n            s.write(b\"over\\n\")\n\n            self.assertRaises(ValueError, s.recv, -1)\n            self.assertRaises(ValueError, s.read, -1)\n\n            s.close()\n\n    def test_recv_zero(self):\n        server = ThreadedEchoServer(CERTFILE)\n        server.__enter__()\n        self.addCleanup(server.__exit__, None, None)\n        s = socket.create_connection((HOST, server.port))\n        self.addCleanup(s.close)\n        s = test_wrap_socket(s, suppress_ragged_eofs=False)\n        self.addCleanup(s.close)\n\n        # recv/read(0) should return no data\n        s.send(b\"data\")\n        self.assertEqual(s.recv(0), b\"\")\n        self.assertEqual(s.read(0), b\"\")\n        self.assertEqual(s.read(), b\"data\")\n\n        # Should not block if the other end sends no data\n        s.setblocking(False)\n        self.assertEqual(s.recv(0), b\"\")\n        self.assertEqual(s.recv_into(bytearray()), 0)\n\n    def test_nonblocking_send(self):\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLS_SERVER,\n                                    cacerts=CERTFILE,\n                                    chatty=True,\n                                    connectionchatty=False)\n        with server:\n            s = test_wrap_socket(socket.socket(),\n                                server_side=False,\n                                certfile=CERTFILE,\n                                ca_certs=CERTFILE,\n                                cert_reqs=ssl.CERT_NONE,\n                                ssl_version=ssl.PROTOCOL_TLS_CLIENT)\n            s.connect((HOST, server.port))\n            s.setblocking(False)\n\n            # If we keep sending data, at some point the buffers\n            # will be full and the call will block\n            buf = bytearray(8192)\n            def fill_buffer():\n                while True:\n                    s.send(buf)\n            self.assertRaises((ssl.SSLWantWriteError,\n                               ssl.SSLWantReadError), fill_buffer)\n\n            # Now read all the output and discard it\n            s.setblocking(True)\n            s.close()\n\n    def test_handshake_timeout(self):\n        # Issue #5103: SSL handshake must respect the socket timeout\n        server = socket.socket(socket.AF_INET)\n        host = \"127.0.0.1\"\n        port = support.bind_port(server)\n        started = threading.Event()\n        finish = False\n\n        def serve():\n            server.listen()\n            started.set()\n            conns = []\n            while not finish:\n                r, w, e = select.select([server], [], [], 0.1)\n                if server in r:\n                    # Let the socket hang around rather than having\n                    # it closed by garbage collection.\n                    conns.append(server.accept()[0])\n            for sock in conns:\n                sock.close()\n\n        t = threading.Thread(target=serve)\n        t.start()\n        started.wait()\n\n        try:\n            try:\n                c = socket.socket(socket.AF_INET)\n                c.settimeout(0.2)\n                c.connect((host, port))\n                # Will attempt handshake and time out\n                self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                       test_wrap_socket, c)\n            finally:\n                c.close()\n            try:\n                c = socket.socket(socket.AF_INET)\n                c = test_wrap_socket(c)\n                c.settimeout(0.2)\n                # Will attempt handshake and time out\n                self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                       c.connect, (host, port))\n            finally:\n                c.close()\n        finally:\n            finish = True\n            t.join()\n            server.close()\n\n    def test_server_accept(self):\n        # Issue #16357: accept() on a SSLSocket created through\n        # SSLContext.wrap_socket().\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        context.verify_mode = ssl.CERT_REQUIRED\n        context.load_verify_locations(SIGNING_CA)\n        context.load_cert_chain(SIGNED_CERTFILE)\n        server = socket.socket(socket.AF_INET)\n        host = \"127.0.0.1\"\n        port = support.bind_port(server)\n        server = context.wrap_socket(server, server_side=True)\n        self.assertTrue(server.server_side)\n\n        evt = threading.Event()\n        remote = None\n        peer = None\n        def serve():\n            nonlocal remote, peer\n            server.listen()\n            # Block on the accept and wait on the connection to close.\n            evt.set()\n            remote, peer = server.accept()\n            remote.recv(1)\n\n        t = threading.Thread(target=serve)\n        t.start()\n        # Client wait until server setup and perform a connect.\n        evt.wait()\n        client = context.wrap_socket(socket.socket())\n        client.connect((host, port))\n        client_addr = client.getsockname()\n        client.close()\n        t.join()\n        remote.close()\n        server.close()\n        # Sanity checks.\n        self.assertIsInstance(remote, ssl.SSLSocket)\n        self.assertEqual(peer, client_addr)\n\n    def test_getpeercert_enotconn(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        with context.wrap_socket(socket.socket()) as sock:\n            with self.assertRaises(OSError) as cm:\n                sock.getpeercert()\n            self.assertEqual(cm.exception.errno, errno.ENOTCONN)\n\n    def test_do_handshake_enotconn(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        with context.wrap_socket(socket.socket()) as sock:\n            with self.assertRaises(OSError) as cm:\n                sock.do_handshake()\n            self.assertEqual(cm.exception.errno, errno.ENOTCONN)\n\n    def test_default_ciphers(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        try:\n            # Force a set of weak ciphers on our client context\n            context.set_ciphers(\"DES\")\n        except ssl.SSLError:\n            self.skipTest(\"no DES cipher available\")\n        with ThreadedEchoServer(CERTFILE,\n                                ssl_version=ssl.PROTOCOL_TLS,\n                                chatty=False) as server:\n            with context.wrap_socket(socket.socket()) as s:\n                with self.assertRaises(OSError):\n                    s.connect((HOST, server.port))\n        self.assertIn(\"no shared cipher\", server.conn_errors[0])\n\n    def test_version_basic(self):\n        \"\"\"\n        Basic tests for SSLSocket.version().\n        More tests are done in the test_protocol_*() methods.\n        \"\"\"\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        context.check_hostname = False\n        context.verify_mode = ssl.CERT_NONE\n        with ThreadedEchoServer(CERTFILE,\n                                ssl_version=ssl.PROTOCOL_TLS_SERVER,\n                                chatty=False) as server:\n            with context.wrap_socket(socket.socket()) as s:\n                self.assertIs(s.version(), None)\n                self.assertIs(s._sslobj, None)\n                s.connect((HOST, server.port))\n                if ssl.OPENSSL_VERSION_INFO >= (1, 1, 1):\n                    self.assertEqual(s.version(), 'TLSv1.3')\n                elif ssl.OPENSSL_VERSION_INFO >= (1, 0, 2):\n                    self.assertEqual(s.version(), 'TLSv1.2')\n                else:  # 0.9.8 to 1.0.1\n                    self.assertIn(s.version(), ('TLSv1', 'TLSv1.2'))\n            self.assertIs(s._sslobj, None)\n            self.assertIs(s.version(), None)\n\n    @unittest.skipUnless(ssl.HAS_TLSv1_3,\n                         \"test requires TLSv1.3 enabled OpenSSL\")\n    def test_tls1_3(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        context.load_cert_chain(CERTFILE)\n        context.options |= (\n            ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1 | ssl.OP_NO_TLSv1_2\n        )\n        with ThreadedEchoServer(context=context) as server:\n            with context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                self.assertIn(s.cipher()[0], {\n                    'TLS13-AES-256-GCM-SHA384',\n                    'TLS13-CHACHA20-POLY1305-SHA256',\n                    'TLS13-AES-128-GCM-SHA256',\n                })\n                self.assertEqual(s.version(), 'TLSv1.3')\n\n    @unittest.skipUnless(hasattr(ssl.SSLContext, 'minimum_version'),\n                         \"required OpenSSL 1.1.0g\")\n    def test_min_max_version(self):\n        client_context, server_context, hostname = testing_context()\n        # client TLSv1.0 to 1.2\n        client_context.minimum_version = ssl.TLSVersion.TLSv1\n        client_context.maximum_version = ssl.TLSVersion.TLSv1_2\n        # server only TLSv1.2\n        server_context.minimum_version = ssl.TLSVersion.TLSv1_2\n        server_context.maximum_version = ssl.TLSVersion.TLSv1_2\n\n        with ThreadedEchoServer(context=server_context) as server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                self.assertEqual(s.version(), 'TLSv1.2')\n\n        # client 1.0 to 1.2, server 1.0 to 1.1\n        server_context.minimum_version = ssl.TLSVersion.TLSv1\n        server_context.maximum_version = ssl.TLSVersion.TLSv1_1\n\n        with ThreadedEchoServer(context=server_context) as server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                self.assertEqual(s.version(), 'TLSv1.1')\n\n        # client 1.0, server 1.2 (mismatch)\n        server_context.minimum_version = ssl.TLSVersion.TLSv1_2\n        server_context.maximum_version = ssl.TLSVersion.TLSv1_2\n        client_context.minimum_version = ssl.TLSVersion.TLSv1\n        client_context.maximum_version = ssl.TLSVersion.TLSv1\n        with ThreadedEchoServer(context=server_context) as server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                with self.assertRaises(ssl.SSLError) as e:\n                    s.connect((HOST, server.port))\n                self.assertIn(\"alert\", str(e.exception))\n\n\n    @unittest.skipUnless(hasattr(ssl.SSLContext, 'minimum_version'),\n                         \"required OpenSSL 1.1.0g\")\n    @unittest.skipUnless(ssl.HAS_SSLv3, \"requires SSLv3 support\")\n    def test_min_max_version_sslv3(self):\n        client_context, server_context, hostname = testing_context()\n        server_context.minimum_version = ssl.TLSVersion.SSLv3\n        client_context.minimum_version = ssl.TLSVersion.SSLv3\n        client_context.maximum_version = ssl.TLSVersion.SSLv3\n        with ThreadedEchoServer(context=server_context) as server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                self.assertEqual(s.version(), 'SSLv3')\n\n    @unittest.skipUnless(ssl.HAS_ECDH, \"test requires ECDH-enabled OpenSSL\")\n    def test_default_ecdh_curve(self):\n        # Issue #21015: elliptic curve-based Diffie Hellman key exchange\n        # should be enabled by default on SSL contexts.\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        context.load_cert_chain(CERTFILE)\n        # TLSv1.3 defaults to PFS key agreement and no longer has KEA in\n        # cipher name.\n        context.options |= ssl.OP_NO_TLSv1_3\n        # Prior to OpenSSL 1.0.0, ECDH ciphers have to be enabled\n        # explicitly using the 'ECCdraft' cipher alias.  Otherwise,\n        # our default cipher list should prefer ECDH-based ciphers\n        # automatically.\n        if ssl.OPENSSL_VERSION_INFO < (1, 0, 0):\n            context.set_ciphers(\"ECCdraft:ECDH\")\n        with ThreadedEchoServer(context=context) as server:\n            with context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                self.assertIn(\"ECDH\", s.cipher()[0])\n\n    @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                         \"'tls-unique' channel binding not available\")\n    def test_tls_unique_channel_binding(self):\n        \"\"\"Test tls-unique channel binding.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        client_context, server_context, hostname = testing_context()\n        # TODO: fix TLSv1.3 support\n        client_context.options |= ssl.OP_NO_TLSv1_3\n\n        server = ThreadedEchoServer(context=server_context,\n                                    chatty=True,\n                                    connectionchatty=False)\n\n        with server:\n            with client_context.wrap_socket(\n                    socket.socket(),\n                    server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                # get the data\n                cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\n                        \" got channel binding data: {0!r}\\n\".format(cb_data))\n\n                # check if it is sane\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n\n                # and compare with the peers version\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(cb_data).encode(\"us-ascii\"))\n\n            # now, again\n            with client_context.wrap_socket(\n                    socket.socket(),\n                    server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                new_cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\n                        \"got another channel binding data: {0!r}\\n\".format(\n                            new_cb_data)\n                    )\n                # is it really unique\n                self.assertNotEqual(cb_data, new_cb_data)\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(new_cb_data).encode(\"us-ascii\"))\n\n    def test_compression(self):\n        client_context, server_context, hostname = testing_context()\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        if support.verbose:\n            sys.stdout.write(\" got compression: {!r}\\n\".format(stats['compression']))\n        self.assertIn(stats['compression'], { None, 'ZLIB', 'RLE' })\n\n    @unittest.skipUnless(hasattr(ssl, 'OP_NO_COMPRESSION'),\n                         \"ssl.OP_NO_COMPRESSION needed for this test\")\n    def test_compression_disabled(self):\n        client_context, server_context, hostname = testing_context()\n        client_context.options |= ssl.OP_NO_COMPRESSION\n        server_context.options |= ssl.OP_NO_COMPRESSION\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        self.assertIs(stats['compression'], None)\n\n    def test_dh_params(self):\n        # Check we can get a connection with ephemeral Diffie-Hellman\n        client_context, server_context, hostname = testing_context()\n        # test scenario needs TLS <= 1.2\n        client_context.options |= ssl.OP_NO_TLSv1_3\n        server_context.load_dh_params(DHFILE)\n        server_context.set_ciphers(\"kEDH\")\n        server_context.options |= ssl.OP_NO_TLSv1_3\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        cipher = stats[\"cipher\"][0]\n        parts = cipher.split(\"-\")\n        if \"ADH\" not in parts and \"EDH\" not in parts and \"DHE\" not in parts:\n            self.fail(\"Non-DH cipher: \" + cipher[0])\n\n    @unittest.skipUnless(HAVE_SECP_CURVES, \"needs secp384r1 curve support\")\n    @unittest.skipIf(IS_OPENSSL_1_1_1, \"TODO: Test doesn't work on 1.1.1\")\n    def test_ecdh_curve(self):\n        # server secp384r1, client auto\n        client_context, server_context, hostname = testing_context()\n\n        server_context.set_ecdh_curve(\"secp384r1\")\n        server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")\n        server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n\n        # server auto, client secp384r1\n        client_context, server_context, hostname = testing_context()\n        client_context.set_ecdh_curve(\"secp384r1\")\n        server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")\n        server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n\n        # server / client curve mismatch\n        client_context, server_context, hostname = testing_context()\n        client_context.set_ecdh_curve(\"prime256v1\")\n        server_context.set_ecdh_curve(\"secp384r1\")\n        server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")\n        server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n        try:\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True, connectionchatty=True,\n                                       sni_name=hostname)\n        except ssl.SSLError:\n            pass\n        else:\n            # OpenSSL 1.0.2 does not fail although it should.\n            if IS_OPENSSL_1_1_0:\n                self.fail(\"mismatch curve did not fail\")\n\n    def test_selected_alpn_protocol(self):\n        # selected_alpn_protocol() is None unless ALPN is used.\n        client_context, server_context, hostname = testing_context()\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        self.assertIs(stats['client_alpn_protocol'], None)\n\n    @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support required\")\n    def test_selected_alpn_protocol_if_server_uses_alpn(self):\n        # selected_alpn_protocol() is None unless ALPN is used by the client.\n        client_context, server_context, hostname = testing_context()\n        server_context.set_alpn_protocols(['foo', 'bar'])\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        self.assertIs(stats['client_alpn_protocol'], None)\n\n    @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support needed for this test\")\n    def test_alpn_protocols(self):\n        server_protocols = ['foo', 'bar', 'milkshake']\n        protocol_tests = [\n            (['foo', 'bar'], 'foo'),\n            (['bar', 'foo'], 'foo'),\n            (['milkshake'], 'milkshake'),\n            (['http/3.0', 'http/4.0'], None)\n        ]\n        for client_protocols, expected in protocol_tests:\n            client_context, server_context, hostname = testing_context()\n            server_context.set_alpn_protocols(server_protocols)\n            client_context.set_alpn_protocols(client_protocols)\n\n            try:\n                stats = server_params_test(client_context,\n                                           server_context,\n                                           chatty=True,\n                                           connectionchatty=True,\n                                           sni_name=hostname)\n            except ssl.SSLError as e:\n                stats = e\n\n            if (expected is None and IS_OPENSSL_1_1_0\n                    and ssl.OPENSSL_VERSION_INFO < (1, 1, 0, 6)):\n                # OpenSSL 1.1.0 to 1.1.0e raises handshake error\n                self.assertIsInstance(stats, ssl.SSLError)\n            else:\n                msg = \"failed trying %s (s) and %s (c).\\n\" \\\n                    \"was expecting %s, but got %%s from the %%s\" \\\n                        % (str(server_protocols), str(client_protocols),\n                            str(expected))\n                client_result = stats['client_alpn_protocol']\n                self.assertEqual(client_result, expected,\n                                 msg % (client_result, \"client\"))\n                server_result = stats['server_alpn_protocols'][-1] \\\n                    if len(stats['server_alpn_protocols']) else 'nothing'\n                self.assertEqual(server_result, expected,\n                                 msg % (server_result, \"server\"))\n\n    def test_selected_npn_protocol(self):\n        # selected_npn_protocol() is None unless NPN is used\n        client_context, server_context, hostname = testing_context()\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        self.assertIs(stats['client_npn_protocol'], None)\n\n    @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")\n    def test_npn_protocols(self):\n        server_protocols = ['http/1.1', 'spdy/2']\n        protocol_tests = [\n            (['http/1.1', 'spdy/2'], 'http/1.1'),\n            (['spdy/2', 'http/1.1'], 'http/1.1'),\n            (['spdy/2', 'test'], 'spdy/2'),\n            (['abc', 'def'], 'abc')\n        ]\n        for client_protocols, expected in protocol_tests:\n            client_context, server_context, hostname = testing_context()\n            server_context.set_npn_protocols(server_protocols)\n            client_context.set_npn_protocols(client_protocols)\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True, connectionchatty=True,\n                                       sni_name=hostname)\n            msg = \"failed trying %s (s) and %s (c).\\n\" \\\n                  \"was expecting %s, but got %%s from the %%s\" \\\n                      % (str(server_protocols), str(client_protocols),\n                         str(expected))\n            client_result = stats['client_npn_protocol']\n            self.assertEqual(client_result, expected, msg % (client_result, \"client\"))\n            server_result = stats['server_npn_protocols'][-1] \\\n                if len(stats['server_npn_protocols']) else 'nothing'\n            self.assertEqual(server_result, expected, msg % (server_result, \"server\"))\n\n    def sni_contexts(self):\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        server_context.load_cert_chain(SIGNED_CERTFILE)\n        other_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        other_context.load_cert_chain(SIGNED_CERTFILE2)\n        client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        client_context.load_verify_locations(SIGNING_CA)\n        return server_context, other_context, client_context\n\n    def check_common_name(self, stats, name):\n        cert = stats['peercert']\n        self.assertIn((('commonName', name),), cert['subject'])\n\n    @needs_sni\n    def test_sni_callback(self):\n        calls = []\n        server_context, other_context, client_context = self.sni_contexts()\n\n        client_context.check_hostname = False\n\n        def servername_cb(ssl_sock, server_name, initial_context):\n            calls.append((server_name, initial_context))\n            if server_name is not None:\n                ssl_sock.context = other_context\n        server_context.set_servername_callback(servername_cb)\n\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True,\n                                   sni_name='supermessage')\n        # The hostname was fetched properly, and the certificate was\n        # changed for the connection.\n        self.assertEqual(calls, [(\"supermessage\", server_context)])\n        # CERTFILE4 was selected\n        self.check_common_name(stats, 'fakehostname')\n\n        calls = []\n        # The callback is called with server_name=None\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True,\n                                   sni_name=None)\n        self.assertEqual(calls, [(None, server_context)])\n        self.check_common_name(stats, SIGNED_CERTFILE_HOSTNAME)\n\n        # Check disabling the callback\n        calls = []\n        server_context.set_servername_callback(None)\n\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True,\n                                   sni_name='notfunny')\n        # Certificate didn't change\n        self.check_common_name(stats, SIGNED_CERTFILE_HOSTNAME)\n        self.assertEqual(calls, [])\n\n    @needs_sni\n    def test_sni_callback_alert(self):\n        # Returning a TLS alert is reflected to the connecting client\n        server_context, other_context, client_context = self.sni_contexts()\n\n        def cb_returning_alert(ssl_sock, server_name, initial_context):\n            return ssl.ALERT_DESCRIPTION_ACCESS_DENIED\n        server_context.set_servername_callback(cb_returning_alert)\n        with self.assertRaises(ssl.SSLError) as cm:\n            stats = server_params_test(client_context, server_context,\n                                       chatty=False,\n                                       sni_name='supermessage')\n        self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_ACCESS_DENIED')\n\n    @needs_sni\n    def test_sni_callback_raising(self):\n        # Raising fails the connection with a TLS handshake failure alert.\n        server_context, other_context, client_context = self.sni_contexts()\n\n        def cb_raising(ssl_sock, server_name, initial_context):\n            1/0\n        server_context.set_servername_callback(cb_raising)\n\n        with self.assertRaises(ssl.SSLError) as cm, \\\n             support.captured_stderr() as stderr:\n            stats = server_params_test(client_context, server_context,\n                                       chatty=False,\n                                       sni_name='supermessage')\n        self.assertEqual(cm.exception.reason, 'SSLV3_ALERT_HANDSHAKE_FAILURE')\n        self.assertIn(\"ZeroDivisionError\", stderr.getvalue())\n\n    @needs_sni\n    def test_sni_callback_wrong_return_type(self):\n        # Returning the wrong return type terminates the TLS connection\n        # with an internal error alert.\n        server_context, other_context, client_context = self.sni_contexts()\n\n        def cb_wrong_return_type(ssl_sock, server_name, initial_context):\n            return \"foo\"\n        server_context.set_servername_callback(cb_wrong_return_type)\n\n        with self.assertRaises(ssl.SSLError) as cm, \\\n             support.captured_stderr() as stderr:\n            stats = server_params_test(client_context, server_context,\n                                       chatty=False,\n                                       sni_name='supermessage')\n        self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_INTERNAL_ERROR')\n        self.assertIn(\"TypeError\", stderr.getvalue())\n\n    def test_shared_ciphers(self):\n        client_context, server_context, hostname = testing_context()\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0, 2):\n            client_context.set_ciphers(\"AES128:AES256\")\n            server_context.set_ciphers(\"AES256\")\n            alg1 = \"AES256\"\n            alg2 = \"AES-256\"\n        else:\n            client_context.set_ciphers(\"AES:3DES\")\n            server_context.set_ciphers(\"3DES\")\n            alg1 = \"3DES\"\n            alg2 = \"DES-CBC3\"\n\n        stats = server_params_test(client_context, server_context,\n                                   sni_name=hostname)\n        ciphers = stats['server_shared_ciphers'][0]\n        self.assertGreater(len(ciphers), 0)\n        for name, tls_version, bits in ciphers:\n            if not alg1 in name.split(\"-\") and alg2 not in name:\n                self.fail(name)\n\n    def test_read_write_after_close_raises_valuerror(self):\n        client_context, server_context, hostname = testing_context()\n        server = ThreadedEchoServer(context=server_context, chatty=False)\n\n        with server:\n            s = client_context.wrap_socket(socket.socket(),\n                                           server_hostname=hostname)\n            s.connect((HOST, server.port))\n            s.close()\n\n            self.assertRaises(ValueError, s.read, 1024)\n            self.assertRaises(ValueError, s.write, b'hello')\n\n    def test_sendfile(self):\n        TEST_DATA = b\"x\" * 512\n        with open(support.TESTFN, 'wb') as f:\n            f.write(TEST_DATA)\n        self.addCleanup(support.unlink, support.TESTFN)\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        context.verify_mode = ssl.CERT_REQUIRED\n        context.load_verify_locations(SIGNING_CA)\n        context.load_cert_chain(SIGNED_CERTFILE)\n        server = ThreadedEchoServer(context=context, chatty=False)\n        with server:\n            with context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                with open(support.TESTFN, 'rb') as file:\n                    s.sendfile(file)\n                    self.assertEqual(s.recv(1024), TEST_DATA)\n\n    def test_session(self):\n        client_context, server_context, hostname = testing_context()\n        # TODO: sessions aren't compatible with TLSv1.3 yet\n        client_context.options |= ssl.OP_NO_TLSv1_3\n\n        # first connection without session\n        stats = server_params_test(client_context, server_context,\n                                   sni_name=hostname)\n        session = stats['session']\n        self.assertTrue(session.id)\n        self.assertGreater(session.time, 0)\n        self.assertGreater(session.timeout, 0)\n        self.assertTrue(session.has_ticket)\n        if ssl.OPENSSL_VERSION_INFO > (1, 0, 1):\n            self.assertGreater(session.ticket_lifetime_hint, 0)\n        self.assertFalse(stats['session_reused'])\n        sess_stat = server_context.session_stats()\n        self.assertEqual(sess_stat['accept'], 1)\n        self.assertEqual(sess_stat['hits'], 0)\n\n        # reuse session\n        stats = server_params_test(client_context, server_context,\n                                   session=session, sni_name=hostname)\n        sess_stat = server_context.session_stats()\n        self.assertEqual(sess_stat['accept'], 2)\n        self.assertEqual(sess_stat['hits'], 1)\n        self.assertTrue(stats['session_reused'])\n        session2 = stats['session']\n        self.assertEqual(session2.id, session.id)\n        self.assertEqual(session2, session)\n        self.assertIsNot(session2, session)\n        self.assertGreaterEqual(session2.time, session.time)\n        self.assertGreaterEqual(session2.timeout, session.timeout)\n\n        # another one without session\n        stats = server_params_test(client_context, server_context,\n                                   sni_name=hostname)\n        self.assertFalse(stats['session_reused'])\n        session3 = stats['session']\n        self.assertNotEqual(session3.id, session.id)\n        self.assertNotEqual(session3, session)\n        sess_stat = server_context.session_stats()\n        self.assertEqual(sess_stat['accept'], 3)\n        self.assertEqual(sess_stat['hits'], 1)\n\n        # reuse session again\n        stats = server_params_test(client_context, server_context,\n                                   session=session, sni_name=hostname)\n        self.assertTrue(stats['session_reused'])\n        session4 = stats['session']\n        self.assertEqual(session4.id, session.id)\n        self.assertEqual(session4, session)\n        self.assertGreaterEqual(session4.time, session.time)\n        self.assertGreaterEqual(session4.timeout, session.timeout)\n        sess_stat = server_context.session_stats()\n        self.assertEqual(sess_stat['accept'], 4)\n        self.assertEqual(sess_stat['hits'], 2)\n\n    def test_session_handling(self):\n        client_context, server_context, hostname = testing_context()\n        client_context2, _, _ = testing_context()\n\n        # TODO: session reuse does not work with TLSv1.3\n        client_context.options |= ssl.OP_NO_TLSv1_3\n        client_context2.options |= ssl.OP_NO_TLSv1_3\n\n        server = ThreadedEchoServer(context=server_context, chatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                # session is None before handshake\n                self.assertEqual(s.session, None)\n                self.assertEqual(s.session_reused, None)\n                s.connect((HOST, server.port))\n                session = s.session\n                self.assertTrue(session)\n                with self.assertRaises(TypeError) as e:\n                    s.session = object\n                self.assertEqual(str(e.exception), 'Value is not a SSLSession.')\n\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                # cannot set session after handshake\n                with self.assertRaises(ValueError) as e:\n                    s.session = session\n                self.assertEqual(str(e.exception),\n                                 'Cannot set session after handshake.')\n\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                # can set session before handshake and before the\n                # connection was established\n                s.session = session\n                s.connect((HOST, server.port))\n                self.assertEqual(s.session.id, session.id)\n                self.assertEqual(s.session, session)\n                self.assertEqual(s.session_reused, True)\n\n            with client_context2.wrap_socket(socket.socket(),\n                                             server_hostname=hostname) as s:\n                # cannot re-use session with a different SSLContext\n                with self.assertRaises(ValueError) as e:\n                    s.session = session\n                    s.connect((HOST, server.port))\n                self.assertEqual(str(e.exception),\n                                 'Session refers to a different SSLContext.')\n\n\ndef test_main(verbose=False):\n    if support.verbose:\n        import warnings\n        plats = {\n            'Linux': platform.linux_distribution,\n            'Mac': platform.mac_ver,\n            'Windows': platform.win32_ver,\n        }\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                'ignore',\n                r'dist\\(\\) and linux_distribution\\(\\) '\n                'functions are deprecated .*',\n                PendingDeprecationWarning,\n            )\n            for name, func in plats.items():\n                plat = func()\n                if plat and plat[0]:\n                    plat = '%s %r' % (name, plat)\n                    break\n            else:\n                plat = repr(platform.platform())\n        print(\"test_ssl: testing with %r %r\" %\n            (ssl.OPENSSL_VERSION, ssl.OPENSSL_VERSION_INFO))\n        print(\"          under %s\" % plat)\n        print(\"          HAS_SNI = %r\" % ssl.HAS_SNI)\n        print(\"          OP_ALL = 0x%8x\" % ssl.OP_ALL)\n        try:\n            print(\"          OP_NO_TLSv1_1 = 0x%8x\" % ssl.OP_NO_TLSv1_1)\n        except AttributeError:\n            pass\n\n    for filename in [\n        CERTFILE, BYTES_CERTFILE,\n        ONLYCERT, ONLYKEY, BYTES_ONLYCERT, BYTES_ONLYKEY,\n        SIGNED_CERTFILE, SIGNED_CERTFILE2, SIGNING_CA,\n        BADCERT, BADKEY, EMPTYCERT]:\n        if not os.path.exists(filename):\n            raise support.TestFailed(\"Can't read certificate file %r\" % filename)\n\n    tests = [\n        ContextTests, BasicSocketTests, SSLErrorTests, MemoryBIOTests,\n        SSLObjectTests, SimpleBackgroundTests, ThreadedTests,\n    ]\n\n    if support.is_resource_enabled('network'):\n        tests.append(NetworkedTests)\n\n    thread_info = support.threading_setup()\n    try:\n        support.run_unittest(*tests)\n    finally:\n        support.threading_cleanup(*thread_info)\n\nif __name__ == \"__main__\":\n    test_main()\n",
    "code_after": "# Test the support for SSL and sockets\n\nimport sys\nimport unittest\nfrom test import support\nimport socket\nimport select\nimport time\nimport datetime\nimport gc\nimport os\nimport errno\nimport pprint\nimport urllib.request\nimport threading\nimport traceback\nimport asyncore\nimport weakref\nimport platform\nimport functools\nimport sysconfig\ntry:\n    import ctypes\nexcept ImportError:\n    ctypes = None\n\nssl = support.import_module(\"ssl\")\n\n\nPROTOCOLS = sorted(ssl._PROTOCOL_NAMES)\nHOST = support.HOST\nIS_LIBRESSL = ssl.OPENSSL_VERSION.startswith('LibreSSL')\nIS_OPENSSL_1_1_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0)\nIS_OPENSSL_1_1_1 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 1)\nPY_SSL_DEFAULT_CIPHERS = sysconfig.get_config_var('PY_SSL_DEFAULT_CIPHERS')\n\ndef data_file(*name):\n    return os.path.join(os.path.dirname(__file__), *name)\n\n# The custom key and certificate files used in test_ssl are generated\n# using Lib/test/make_ssl_certs.py.\n# Other certificates are simply fetched from the Internet servers they\n# are meant to authenticate.\n\nCERTFILE = data_file(\"keycert.pem\")\nBYTES_CERTFILE = os.fsencode(CERTFILE)\nONLYCERT = data_file(\"ssl_cert.pem\")\nONLYKEY = data_file(\"ssl_key.pem\")\nBYTES_ONLYCERT = os.fsencode(ONLYCERT)\nBYTES_ONLYKEY = os.fsencode(ONLYKEY)\nCERTFILE_PROTECTED = data_file(\"keycert.passwd.pem\")\nONLYKEY_PROTECTED = data_file(\"ssl_key.passwd.pem\")\nKEY_PASSWORD = \"somepass\"\nCAPATH = data_file(\"capath\")\nBYTES_CAPATH = os.fsencode(CAPATH)\nCAFILE_NEURONIO = data_file(\"capath\", \"4e1295a3.0\")\nCAFILE_CACERT = data_file(\"capath\", \"5ed36f99.0\")\nWRONG_CERT = data_file(\"wrongcert.pem\")\n\nCERTFILE_INFO = {\n    'issuer': ((('countryName', 'XY'),),\n               (('localityName', 'Castle Anthrax'),),\n               (('organizationName', 'Python Software Foundation'),),\n               (('commonName', 'localhost'),)),\n    'notAfter': 'Jan 17 19:09:06 2028 GMT',\n    'notBefore': 'Jan 19 19:09:06 2018 GMT',\n    'serialNumber': 'F9BA076D5B6ABD9B',\n    'subject': ((('countryName', 'XY'),),\n             (('localityName', 'Castle Anthrax'),),\n             (('organizationName', 'Python Software Foundation'),),\n             (('commonName', 'localhost'),)),\n    'subjectAltName': (('DNS', 'localhost'),),\n    'version': 3\n}\n\n# empty CRL\nCRLFILE = data_file(\"revocation.crl\")\n\n# Two keys and certs signed by the same CA (for SNI tests)\nSIGNED_CERTFILE = data_file(\"keycert3.pem\")\nSIGNED_CERTFILE_HOSTNAME = 'localhost'\n\nSIGNED_CERTFILE_INFO = {\n    'OCSP': ('http://testca.pythontest.net/testca/ocsp/',),\n    'caIssuers': ('http://testca.pythontest.net/testca/pycacert.cer',),\n    'crlDistributionPoints': ('http://testca.pythontest.net/testca/revocation.crl',),\n    'issuer': ((('countryName', 'XY'),),\n            (('organizationName', 'Python Software Foundation CA'),),\n            (('commonName', 'our-ca-server'),)),\n    'notAfter': 'Nov 28 19:09:06 2027 GMT',\n    'notBefore': 'Jan 19 19:09:06 2018 GMT',\n    'serialNumber': '82EDBF41C880919C',\n    'subject': ((('countryName', 'XY'),),\n             (('localityName', 'Castle Anthrax'),),\n             (('organizationName', 'Python Software Foundation'),),\n             (('commonName', 'localhost'),)),\n    'subjectAltName': (('DNS', 'localhost'),),\n    'version': 3\n}\n\nSIGNED_CERTFILE2 = data_file(\"keycert4.pem\")\nSIGNED_CERTFILE2_HOSTNAME = 'fakehostname'\nSIGNED_CERTFILE_ECC = data_file(\"keycertecc.pem\")\nSIGNED_CERTFILE_ECC_HOSTNAME = 'localhost-ecc'\n\n# Same certificate as pycacert.pem, but without extra text in file\nSIGNING_CA = data_file(\"capath\", \"ceff1710.0\")\n# cert with all kinds of subject alt names\nALLSANFILE = data_file(\"allsans.pem\")\nIDNSANSFILE = data_file(\"idnsans.pem\")\n\nREMOTE_HOST = \"self-signed.pythontest.net\"\n\nEMPTYCERT = data_file(\"nullcert.pem\")\nBADCERT = data_file(\"badcert.pem\")\nNONEXISTINGCERT = data_file(\"XXXnonexisting.pem\")\nBADKEY = data_file(\"badkey.pem\")\nNOKIACERT = data_file(\"nokia.pem\")\nNULLBYTECERT = data_file(\"nullbytecert.pem\")\n\nDHFILE = data_file(\"dh1024.pem\")\nBYTES_DHFILE = os.fsencode(DHFILE)\n\n# Not defined in all versions of OpenSSL\nOP_NO_COMPRESSION = getattr(ssl, \"OP_NO_COMPRESSION\", 0)\nOP_SINGLE_DH_USE = getattr(ssl, \"OP_SINGLE_DH_USE\", 0)\nOP_SINGLE_ECDH_USE = getattr(ssl, \"OP_SINGLE_ECDH_USE\", 0)\nOP_CIPHER_SERVER_PREFERENCE = getattr(ssl, \"OP_CIPHER_SERVER_PREFERENCE\", 0)\nOP_ENABLE_MIDDLEBOX_COMPAT = getattr(ssl, \"OP_ENABLE_MIDDLEBOX_COMPAT\", 0)\n\n\ndef handle_error(prefix):\n    exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))\n    if support.verbose:\n        sys.stdout.write(prefix + exc_format)\n\ndef can_clear_options():\n    # 0.9.8m or higher\n    return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)\n\ndef no_sslv2_implies_sslv3_hello():\n    # 0.9.7h or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)\n\ndef have_verify_flags():\n    # 0.9.8 or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 8, 0, 15)\n\ndef _have_secp_curves():\n    if not ssl.HAS_ECDH:\n        return False\n    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    try:\n        ctx.set_ecdh_curve(\"secp384r1\")\n    except ValueError:\n        return False\n    else:\n        return True\n\n\nHAVE_SECP_CURVES = _have_secp_curves()\n\n\ndef utc_offset(): #NOTE: ignore issues like #1647654\n    # local time = utc time + utc offset\n    if time.daylight and time.localtime().tm_isdst > 0:\n        return -time.altzone  # seconds\n    return -time.timezone\n\ndef asn1time(cert_time):\n    # Some versions of OpenSSL ignore seconds, see #18207\n    # 0.9.8.i\n    if ssl._OPENSSL_API_VERSION == (0, 9, 8, 9, 15):\n        fmt = \"%b %d %H:%M:%S %Y GMT\"\n        dt = datetime.datetime.strptime(cert_time, fmt)\n        dt = dt.replace(second=0)\n        cert_time = dt.strftime(fmt)\n        # %d adds leading zero but ASN1_TIME_print() uses leading space\n        if cert_time[4] == \"0\":\n            cert_time = cert_time[:4] + \" \" + cert_time[5:]\n\n    return cert_time\n\n# Issue #9415: Ubuntu hijacks their OpenSSL and forcefully disables SSLv2\ndef skip_if_broken_ubuntu_ssl(func):\n    if hasattr(ssl, 'PROTOCOL_SSLv2'):\n        @functools.wraps(func)\n        def f(*args, **kwargs):\n            try:\n                ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n            except ssl.SSLError:\n                if (ssl.OPENSSL_VERSION_INFO == (0, 9, 8, 15, 15) and\n                    platform.linux_distribution() == ('debian', 'squeeze/sid', '')):\n                    raise unittest.SkipTest(\"Patched Ubuntu OpenSSL breaks behaviour\")\n            return func(*args, **kwargs)\n        return f\n    else:\n        return func\n\nneeds_sni = unittest.skipUnless(ssl.HAS_SNI, \"SNI support needed for this test\")\n\n\ndef test_wrap_socket(sock, ssl_version=ssl.PROTOCOL_TLS, *,\n                     cert_reqs=ssl.CERT_NONE, ca_certs=None,\n                     ciphers=None, certfile=None, keyfile=None,\n                     **kwargs):\n    context = ssl.SSLContext(ssl_version)\n    if cert_reqs is not None:\n        if cert_reqs == ssl.CERT_NONE:\n            context.check_hostname = False\n        context.verify_mode = cert_reqs\n    if ca_certs is not None:\n        context.load_verify_locations(ca_certs)\n    if certfile is not None or keyfile is not None:\n        context.load_cert_chain(certfile, keyfile)\n    if ciphers is not None:\n        context.set_ciphers(ciphers)\n    return context.wrap_socket(sock, **kwargs)\n\n\ndef testing_context(server_cert=SIGNED_CERTFILE):\n    \"\"\"Create context\n\n    client_context, server_context, hostname = testing_context()\n    \"\"\"\n    if server_cert == SIGNED_CERTFILE:\n        hostname = SIGNED_CERTFILE_HOSTNAME\n    elif server_cert == SIGNED_CERTFILE2:\n        hostname = SIGNED_CERTFILE2_HOSTNAME\n    else:\n        raise ValueError(server_cert)\n\n    client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n    client_context.load_verify_locations(SIGNING_CA)\n\n    server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n    server_context.load_cert_chain(server_cert)\n    client_context.load_verify_locations(SIGNING_CA)\n\n    return client_context, server_context, hostname\n\n\nclass BasicSocketTests(unittest.TestCase):\n\n    def test_constants(self):\n        ssl.CERT_NONE\n        ssl.CERT_OPTIONAL\n        ssl.CERT_REQUIRED\n        ssl.OP_CIPHER_SERVER_PREFERENCE\n        ssl.OP_SINGLE_DH_USE\n        if ssl.HAS_ECDH:\n            ssl.OP_SINGLE_ECDH_USE\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0):\n            ssl.OP_NO_COMPRESSION\n        self.assertIn(ssl.HAS_SNI, {True, False})\n        self.assertIn(ssl.HAS_ECDH, {True, False})\n        ssl.OP_NO_SSLv2\n        ssl.OP_NO_SSLv3\n        ssl.OP_NO_TLSv1\n        ssl.OP_NO_TLSv1_3\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0, 1):\n            ssl.OP_NO_TLSv1_1\n            ssl.OP_NO_TLSv1_2\n        self.assertEqual(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv23)\n\n    def test_private_init(self):\n        with self.assertRaisesRegex(TypeError, \"public constructor\"):\n            with socket.socket() as s:\n                ssl.SSLSocket(s)\n\n    def test_str_for_enums(self):\n        # Make sure that the PROTOCOL_* constants have enum-like string\n        # reprs.\n        proto = ssl.PROTOCOL_TLS\n        self.assertEqual(str(proto), '_SSLMethod.PROTOCOL_TLS')\n        ctx = ssl.SSLContext(proto)\n        self.assertIs(ctx.protocol, proto)\n\n    def test_random(self):\n        v = ssl.RAND_status()\n        if support.verbose:\n            sys.stdout.write(\"\\n RAND_status is %d (%s)\\n\"\n                             % (v, (v and \"sufficient randomness\") or\n                                \"insufficient randomness\"))\n\n        data, is_cryptographic = ssl.RAND_pseudo_bytes(16)\n        self.assertEqual(len(data), 16)\n        self.assertEqual(is_cryptographic, v == 1)\n        if v:\n            data = ssl.RAND_bytes(16)\n            self.assertEqual(len(data), 16)\n        else:\n            self.assertRaises(ssl.SSLError, ssl.RAND_bytes, 16)\n\n        # negative num is invalid\n        self.assertRaises(ValueError, ssl.RAND_bytes, -5)\n        self.assertRaises(ValueError, ssl.RAND_pseudo_bytes, -5)\n\n        if hasattr(ssl, 'RAND_egd'):\n            self.assertRaises(TypeError, ssl.RAND_egd, 1)\n            self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)\n        ssl.RAND_add(\"this is a random string\", 75.0)\n        ssl.RAND_add(b\"this is a random bytes object\", 75.0)\n        ssl.RAND_add(bytearray(b\"this is a random bytearray object\"), 75.0)\n\n    @unittest.skipUnless(os.name == 'posix', 'requires posix')\n    def test_random_fork(self):\n        status = ssl.RAND_status()\n        if not status:\n            self.fail(\"OpenSSL's PRNG has insufficient randomness\")\n\n        rfd, wfd = os.pipe()\n        pid = os.fork()\n        if pid == 0:\n            try:\n                os.close(rfd)\n                child_random = ssl.RAND_pseudo_bytes(16)[0]\n                self.assertEqual(len(child_random), 16)\n                os.write(wfd, child_random)\n                os.close(wfd)\n            except BaseException:\n                os._exit(1)\n            else:\n                os._exit(0)\n        else:\n            os.close(wfd)\n            self.addCleanup(os.close, rfd)\n            _, status = os.waitpid(pid, 0)\n            self.assertEqual(status, 0)\n\n            child_random = os.read(rfd, 16)\n            self.assertEqual(len(child_random), 16)\n            parent_random = ssl.RAND_pseudo_bytes(16)[0]\n            self.assertEqual(len(parent_random), 16)\n\n            self.assertNotEqual(child_random, parent_random)\n\n    def test_parse_cert(self):\n        # note that this uses an 'unofficial' function in _ssl.c,\n        # provided solely for this test, to exercise the certificate\n        # parsing code\n        self.assertEqual(\n            ssl._ssl._test_decode_cert(CERTFILE),\n            CERTFILE_INFO\n        )\n        self.assertEqual(\n            ssl._ssl._test_decode_cert(SIGNED_CERTFILE),\n            SIGNED_CERTFILE_INFO\n        )\n\n        # Issue #13034: the subjectAltName in some certificates\n        # (notably projects.developer.nokia.com:443) wasn't parsed\n        p = ssl._ssl._test_decode_cert(NOKIACERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'projects.developer.nokia.com'),\n                          ('DNS', 'projects.forum.nokia.com'))\n                        )\n        # extra OCSP and AIA fields\n        self.assertEqual(p['OCSP'], ('http://ocsp.verisign.com',))\n        self.assertEqual(p['caIssuers'],\n                         ('http://SVRIntl-G3-aia.verisign.com/SVRIntlG3.cer',))\n        self.assertEqual(p['crlDistributionPoints'],\n                         ('http://SVRIntl-G3-crl.verisign.com/SVRIntlG3.crl',))\n\n    def test_parse_cert_CVE_2013_4238(self):\n        p = ssl._ssl._test_decode_cert(NULLBYTECERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        subject = ((('countryName', 'US'),),\n                   (('stateOrProvinceName', 'Oregon'),),\n                   (('localityName', 'Beaverton'),),\n                   (('organizationName', 'Python Software Foundation'),),\n                   (('organizationalUnitName', 'Python Core Development'),),\n                   (('commonName', 'null.python.org\\x00example.org'),),\n                   (('emailAddress', 'python-dev@python.org'),))\n        self.assertEqual(p['subject'], subject)\n        self.assertEqual(p['issuer'], subject)\n        if ssl._OPENSSL_API_VERSION >= (0, 9, 8):\n            san = (('DNS', 'altnull.python.org\\x00example.com'),\n                   ('email', 'null@python.org\\x00user@example.org'),\n                   ('URI', 'http://null.python.org\\x00http://example.org'),\n                   ('IP Address', '192.0.2.1'),\n                   ('IP Address', '2001:DB8:0:0:0:0:0:1\\n'))\n        else:\n            # OpenSSL 0.9.7 doesn't support IPv6 addresses in subjectAltName\n            san = (('DNS', 'altnull.python.org\\x00example.com'),\n                   ('email', 'null@python.org\\x00user@example.org'),\n                   ('URI', 'http://null.python.org\\x00http://example.org'),\n                   ('IP Address', '192.0.2.1'),\n                   ('IP Address', '<invalid>'))\n\n        self.assertEqual(p['subjectAltName'], san)\n\n    def test_parse_all_sans(self):\n        p = ssl._ssl._test_decode_cert(ALLSANFILE)\n        self.assertEqual(p['subjectAltName'],\n            (\n                ('DNS', 'allsans'),\n                ('othername', '<unsupported>'),\n                ('othername', '<unsupported>'),\n                ('email', 'user@example.org'),\n                ('DNS', 'www.example.org'),\n                ('DirName',\n                    ((('countryName', 'XY'),),\n                    (('localityName', 'Castle Anthrax'),),\n                    (('organizationName', 'Python Software Foundation'),),\n                    (('commonName', 'dirname example'),))),\n                ('URI', 'https://www.python.org/'),\n                ('IP Address', '127.0.0.1'),\n                ('IP Address', '0:0:0:0:0:0:0:1\\n'),\n                ('Registered ID', '1.2.3.4.5')\n            )\n        )\n\n    def test_DER_to_PEM(self):\n        with open(CAFILE_CACERT, 'r') as f:\n            pem = f.read()\n        d1 = ssl.PEM_cert_to_DER_cert(pem)\n        p2 = ssl.DER_cert_to_PEM_cert(d1)\n        d2 = ssl.PEM_cert_to_DER_cert(p2)\n        self.assertEqual(d1, d2)\n        if not p2.startswith(ssl.PEM_HEADER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct header:\\n%r\\n\" % p2)\n        if not p2.endswith('\\n' + ssl.PEM_FOOTER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct footer:\\n%r\\n\" % p2)\n\n    def test_openssl_version(self):\n        n = ssl.OPENSSL_VERSION_NUMBER\n        t = ssl.OPENSSL_VERSION_INFO\n        s = ssl.OPENSSL_VERSION\n        self.assertIsInstance(n, int)\n        self.assertIsInstance(t, tuple)\n        self.assertIsInstance(s, str)\n        # Some sanity checks follow\n        # >= 0.9\n        self.assertGreaterEqual(n, 0x900000)\n        # < 3.0\n        self.assertLess(n, 0x30000000)\n        major, minor, fix, patch, status = t\n        self.assertGreaterEqual(major, 0)\n        self.assertLess(major, 3)\n        self.assertGreaterEqual(minor, 0)\n        self.assertLess(minor, 256)\n        self.assertGreaterEqual(fix, 0)\n        self.assertLess(fix, 256)\n        self.assertGreaterEqual(patch, 0)\n        self.assertLessEqual(patch, 63)\n        self.assertGreaterEqual(status, 0)\n        self.assertLessEqual(status, 15)\n        # Version string as returned by {Open,Libre}SSL, the format might change\n        if IS_LIBRESSL:\n            self.assertTrue(s.startswith(\"LibreSSL {:d}\".format(major)),\n                            (s, t, hex(n)))\n        else:\n            self.assertTrue(s.startswith(\"OpenSSL {:d}.{:d}.{:d}\".format(major, minor, fix)),\n                            (s, t, hex(n)))\n\n    @support.cpython_only\n    def test_refcycle(self):\n        # Issue #7943: an SSL object doesn't create reference cycles with\n        # itself.\n        s = socket.socket(socket.AF_INET)\n        ss = test_wrap_socket(s)\n        wr = weakref.ref(ss)\n        with support.check_warnings((\"\", ResourceWarning)):\n            del ss\n        self.assertEqual(wr(), None)\n\n    def test_wrapped_unconnected(self):\n        # Methods on an unconnected SSLSocket propagate the original\n        # OSError raise by the underlying socket object.\n        s = socket.socket(socket.AF_INET)\n        with test_wrap_socket(s) as ss:\n            self.assertRaises(OSError, ss.recv, 1)\n            self.assertRaises(OSError, ss.recv_into, bytearray(b'x'))\n            self.assertRaises(OSError, ss.recvfrom, 1)\n            self.assertRaises(OSError, ss.recvfrom_into, bytearray(b'x'), 1)\n            self.assertRaises(OSError, ss.send, b'x')\n            self.assertRaises(OSError, ss.sendto, b'x', ('0.0.0.0', 0))\n            self.assertRaises(NotImplementedError, ss.sendmsg,\n                              [b'x'], (), 0, ('0.0.0.0', 0))\n\n    def test_timeout(self):\n        # Issue #8524: when creating an SSL socket, the timeout of the\n        # original socket should be retained.\n        for timeout in (None, 0.0, 5.0):\n            s = socket.socket(socket.AF_INET)\n            s.settimeout(timeout)\n            with test_wrap_socket(s) as ss:\n                self.assertEqual(timeout, ss.gettimeout())\n\n    def test_errors_sslwrap(self):\n        sock = socket.socket()\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified\",\n                        ssl.wrap_socket, sock, keyfile=CERTFILE)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                         ssl.wrap_socket, sock, server_side=True, certfile=\"\")\n        with ssl.wrap_socket(sock, server_side=True, certfile=CERTFILE) as s:\n            self.assertRaisesRegex(ValueError, \"can't connect in server-side mode\",\n                                     s.connect, (HOST, 8080))\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock,\n                    certfile=CERTFILE, keyfile=NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock,\n                    certfile=NONEXISTINGCERT, keyfile=NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n\n    def bad_cert_test(self, certfile):\n        \"\"\"Check that trying to use the given client certificate fails\"\"\"\n        certfile = os.path.join(os.path.dirname(__file__) or os.curdir,\n                                   certfile)\n        sock = socket.socket()\n        self.addCleanup(sock.close)\n        with self.assertRaises(ssl.SSLError):\n            test_wrap_socket(sock,\n                             certfile=certfile)\n\n    def test_empty_cert(self):\n        \"\"\"Wrapping with an empty cert file\"\"\"\n        self.bad_cert_test(\"nullcert.pem\")\n\n    def test_malformed_cert(self):\n        \"\"\"Wrapping with a badly formatted certificate (syntax error)\"\"\"\n        self.bad_cert_test(\"badcert.pem\")\n\n    def test_malformed_key(self):\n        \"\"\"Wrapping with a badly formatted key (syntax error)\"\"\"\n        self.bad_cert_test(\"badkey.pem\")\n\n    def test_match_hostname(self):\n        def ok(cert, hostname):\n            ssl.match_hostname(cert, hostname)\n        def fail(cert, hostname):\n            self.assertRaises(ssl.CertificateError,\n                              ssl.match_hostname, cert, hostname)\n\n        # -- Hostname matching --\n\n        cert = {'subject': ((('commonName', 'example.com'),),)}\n        ok(cert, 'example.com')\n        ok(cert, 'ExAmple.cOm')\n        fail(cert, 'www.example.com')\n        fail(cert, '.example.com')\n        fail(cert, 'example.org')\n        fail(cert, 'exampleXcom')\n\n        cert = {'subject': ((('commonName', '*.a.com'),),)}\n        ok(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        # only match wildcards when they are the only thing\n        # in left-most segment\n        cert = {'subject': ((('commonName', 'f*.com'),),)}\n        fail(cert, 'foo.com')\n        fail(cert, 'f.com')\n        fail(cert, 'bar.com')\n        fail(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.com')\n\n        # NULL bytes are bad, CVE-2013-4073\n        cert = {'subject': ((('commonName',\n                              'null.python.org\\x00example.org'),),)}\n        ok(cert, 'null.python.org\\x00example.org') # or raise an error?\n        fail(cert, 'example.org')\n        fail(cert, 'null.python.org')\n\n        # error cases with wildcards\n        cert = {'subject': ((('commonName', '*.*.a.com'),),)}\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        cert = {'subject': ((('commonName', 'a.*.com'),),)}\n        fail(cert, 'a.foo.com')\n        fail(cert, 'a..com')\n        fail(cert, 'a.com')\n\n        # wildcard doesn't match IDNA prefix 'xn--'\n        idna = 'p\u00fcthon.python.org'.encode(\"idna\").decode(\"ascii\")\n        cert = {'subject': ((('commonName', idna),),)}\n        ok(cert, idna)\n        cert = {'subject': ((('commonName', 'x*.python.org'),),)}\n        fail(cert, idna)\n        cert = {'subject': ((('commonName', 'xn--p*.python.org'),),)}\n        fail(cert, idna)\n\n        # wildcard in first fragment and  IDNA A-labels in sequent fragments\n        # are supported.\n        idna = 'www*.pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\")\n        cert = {'subject': ((('commonName', idna),),)}\n        fail(cert, 'www.pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\"))\n        fail(cert, 'www1.pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\"))\n        fail(cert, 'ftp.pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\"))\n        fail(cert, 'pyth\u00f6n.org'.encode(\"idna\").decode(\"ascii\"))\n\n        # Slightly fake real-world example\n        cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                'subject': ((('commonName', 'linuxfrz.org'),),),\n                'subjectAltName': (('DNS', 'linuxfr.org'),\n                                   ('DNS', 'linuxfr.com'),\n                                   ('othername', '<unsupported>'))}\n        ok(cert, 'linuxfr.org')\n        ok(cert, 'linuxfr.com')\n        # Not a \"DNS\" entry\n        fail(cert, '<unsupported>')\n        # When there is a subjectAltName, commonName isn't used\n        fail(cert, 'linuxfrz.org')\n\n        # A pristine real-world example\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),),\n                            (('commonName', 'mail.google.com'),))}\n        ok(cert, 'mail.google.com')\n        fail(cert, 'gmail.com')\n        # Only commonName is considered\n        fail(cert, 'California')\n\n        # -- IPv4 matching --\n        cert = {'subject': ((('commonName', 'example.com'),),),\n                'subjectAltName': (('DNS', 'example.com'),\n                                   ('IP Address', '10.11.12.13'),\n                                   ('IP Address', '14.15.16.17'))}\n        ok(cert, '10.11.12.13')\n        ok(cert, '14.15.16.17')\n        fail(cert, '14.15.16.18')\n        fail(cert, 'example.net')\n\n        # -- IPv6 matching --\n        if hasattr(socket, 'AF_INET6'):\n            cert = {'subject': ((('commonName', 'example.com'),),),\n                    'subjectAltName': (\n                        ('DNS', 'example.com'),\n                        ('IP Address', '2001:0:0:0:0:0:0:CAFE\\n'),\n                        ('IP Address', '2003:0:0:0:0:0:0:BABA\\n'))}\n            ok(cert, '2001::cafe')\n            ok(cert, '2003::baba')\n            fail(cert, '2003::bebe')\n            fail(cert, 'example.net')\n\n        # -- Miscellaneous --\n\n        # Neither commonName nor subjectAltName\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),))}\n        fail(cert, 'mail.google.com')\n\n        # No DNS entry in subjectAltName but a commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('commonName', 'mail.google.com'),)),\n                'subjectAltName': (('othername', 'blabla'), )}\n        ok(cert, 'mail.google.com')\n\n        # No DNS entry subjectAltName and no commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),)),\n                'subjectAltName': (('othername', 'blabla'),)}\n        fail(cert, 'google.com')\n\n        # Empty cert / no cert\n        self.assertRaises(ValueError, ssl.match_hostname, None, 'example.com')\n        self.assertRaises(ValueError, ssl.match_hostname, {}, 'example.com')\n\n        # Issue #17980: avoid denials of service by refusing more than one\n        # wildcard per fragment.\n        cert = {'subject': ((('commonName', 'a*b.example.com'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                \"partial wildcards in leftmost label are not supported\"):\n            ssl.match_hostname(cert, 'axxb.example.com')\n\n        cert = {'subject': ((('commonName', 'www.*.example.com'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                \"wildcard can only be present in the leftmost label\"):\n            ssl.match_hostname(cert, 'www.sub.example.com')\n\n        cert = {'subject': ((('commonName', 'a*b*.example.com'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                \"too many wildcards\"):\n            ssl.match_hostname(cert, 'axxbxxc.example.com')\n\n        cert = {'subject': ((('commonName', '*'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                \"sole wildcard without additional labels are not support\"):\n            ssl.match_hostname(cert, 'host')\n\n        cert = {'subject': ((('commonName', '*.com'),),)}\n        with self.assertRaisesRegex(\n                ssl.CertificateError,\n                r\"hostname 'com' doesn't match '\\*.com'\"):\n            ssl.match_hostname(cert, 'com')\n\n        # extra checks for _inet_paton()\n        for invalid in ['1', '', '1.2.3', '256.0.0.1', '127.0.0.1/24']:\n            with self.assertRaises(ValueError):\n                ssl._inet_paton(invalid)\n        for ipaddr in ['127.0.0.1', '192.168.0.1']:\n            self.assertTrue(ssl._inet_paton(ipaddr))\n        if hasattr(socket, 'AF_INET6'):\n            for ipaddr in ['::1', '2001:db8:85a3::8a2e:370:7334']:\n                self.assertTrue(ssl._inet_paton(ipaddr))\n\n    def test_server_side(self):\n        # server_hostname doesn't work for server sockets\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        with socket.socket() as sock:\n            self.assertRaises(ValueError, ctx.wrap_socket, sock, True,\n                              server_hostname=\"some.hostname\")\n\n    def test_unknown_channel_binding(self):\n        # should raise ValueError for unknown type\n        s = socket.socket(socket.AF_INET)\n        s.bind(('127.0.0.1', 0))\n        s.listen()\n        c = socket.socket(socket.AF_INET)\n        c.connect(s.getsockname())\n        with test_wrap_socket(c, do_handshake_on_connect=False) as ss:\n            with self.assertRaises(ValueError):\n                ss.get_channel_binding(\"unknown-type\")\n        s.close()\n\n    @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                         \"'tls-unique' channel binding not available\")\n    def test_tls_unique_channel_binding(self):\n        # unconnected should return None for known type\n        s = socket.socket(socket.AF_INET)\n        with test_wrap_socket(s) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n        # the same for server-side\n        s = socket.socket(socket.AF_INET)\n        with test_wrap_socket(s, server_side=True, certfile=CERTFILE) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n\n    def test_dealloc_warn(self):\n        ss = test_wrap_socket(socket.socket(socket.AF_INET))\n        r = repr(ss)\n        with self.assertWarns(ResourceWarning) as cm:\n            ss = None\n            support.gc_collect()\n        self.assertIn(r, str(cm.warning.args[0]))\n\n    def test_get_default_verify_paths(self):\n        paths = ssl.get_default_verify_paths()\n        self.assertEqual(len(paths), 6)\n        self.assertIsInstance(paths, ssl.DefaultVerifyPaths)\n\n        with support.EnvironmentVarGuard() as env:\n            env[\"SSL_CERT_DIR\"] = CAPATH\n            env[\"SSL_CERT_FILE\"] = CERTFILE\n            paths = ssl.get_default_verify_paths()\n            self.assertEqual(paths.cafile, CERTFILE)\n            self.assertEqual(paths.capath, CAPATH)\n\n    @unittest.skipUnless(sys.platform == \"win32\", \"Windows specific\")\n    def test_enum_certificates(self):\n        self.assertTrue(ssl.enum_certificates(\"CA\"))\n        self.assertTrue(ssl.enum_certificates(\"ROOT\"))\n\n        self.assertRaises(TypeError, ssl.enum_certificates)\n        self.assertRaises(WindowsError, ssl.enum_certificates, \"\")\n\n        trust_oids = set()\n        for storename in (\"CA\", \"ROOT\"):\n            store = ssl.enum_certificates(storename)\n            self.assertIsInstance(store, list)\n            for element in store:\n                self.assertIsInstance(element, tuple)\n                self.assertEqual(len(element), 3)\n                cert, enc, trust = element\n                self.assertIsInstance(cert, bytes)\n                self.assertIn(enc, {\"x509_asn\", \"pkcs_7_asn\"})\n                self.assertIsInstance(trust, (set, bool))\n                if isinstance(trust, set):\n                    trust_oids.update(trust)\n\n        serverAuth = \"1.3.6.1.5.5.7.3.1\"\n        self.assertIn(serverAuth, trust_oids)\n\n    @unittest.skipUnless(sys.platform == \"win32\", \"Windows specific\")\n    def test_enum_crls(self):\n        self.assertTrue(ssl.enum_crls(\"CA\"))\n        self.assertRaises(TypeError, ssl.enum_crls)\n        self.assertRaises(WindowsError, ssl.enum_crls, \"\")\n\n        crls = ssl.enum_crls(\"CA\")\n        self.assertIsInstance(crls, list)\n        for element in crls:\n            self.assertIsInstance(element, tuple)\n            self.assertEqual(len(element), 2)\n            self.assertIsInstance(element[0], bytes)\n            self.assertIn(element[1], {\"x509_asn\", \"pkcs_7_asn\"})\n\n\n    def test_asn1object(self):\n        expected = (129, 'serverAuth', 'TLS Web Server Authentication',\n                    '1.3.6.1.5.5.7.3.1')\n\n        val = ssl._ASN1Object('1.3.6.1.5.5.7.3.1')\n        self.assertEqual(val, expected)\n        self.assertEqual(val.nid, 129)\n        self.assertEqual(val.shortname, 'serverAuth')\n        self.assertEqual(val.longname, 'TLS Web Server Authentication')\n        self.assertEqual(val.oid, '1.3.6.1.5.5.7.3.1')\n        self.assertIsInstance(val, ssl._ASN1Object)\n        self.assertRaises(ValueError, ssl._ASN1Object, 'serverAuth')\n\n        val = ssl._ASN1Object.fromnid(129)\n        self.assertEqual(val, expected)\n        self.assertIsInstance(val, ssl._ASN1Object)\n        self.assertRaises(ValueError, ssl._ASN1Object.fromnid, -1)\n        with self.assertRaisesRegex(ValueError, \"unknown NID 100000\"):\n            ssl._ASN1Object.fromnid(100000)\n        for i in range(1000):\n            try:\n                obj = ssl._ASN1Object.fromnid(i)\n            except ValueError:\n                pass\n            else:\n                self.assertIsInstance(obj.nid, int)\n                self.assertIsInstance(obj.shortname, str)\n                self.assertIsInstance(obj.longname, str)\n                self.assertIsInstance(obj.oid, (str, type(None)))\n\n        val = ssl._ASN1Object.fromname('TLS Web Server Authentication')\n        self.assertEqual(val, expected)\n        self.assertIsInstance(val, ssl._ASN1Object)\n        self.assertEqual(ssl._ASN1Object.fromname('serverAuth'), expected)\n        self.assertEqual(ssl._ASN1Object.fromname('1.3.6.1.5.5.7.3.1'),\n                         expected)\n        with self.assertRaisesRegex(ValueError, \"unknown object 'serverauth'\"):\n            ssl._ASN1Object.fromname('serverauth')\n\n    def test_purpose_enum(self):\n        val = ssl._ASN1Object('1.3.6.1.5.5.7.3.1')\n        self.assertIsInstance(ssl.Purpose.SERVER_AUTH, ssl._ASN1Object)\n        self.assertEqual(ssl.Purpose.SERVER_AUTH, val)\n        self.assertEqual(ssl.Purpose.SERVER_AUTH.nid, 129)\n        self.assertEqual(ssl.Purpose.SERVER_AUTH.shortname, 'serverAuth')\n        self.assertEqual(ssl.Purpose.SERVER_AUTH.oid,\n                              '1.3.6.1.5.5.7.3.1')\n\n        val = ssl._ASN1Object('1.3.6.1.5.5.7.3.2')\n        self.assertIsInstance(ssl.Purpose.CLIENT_AUTH, ssl._ASN1Object)\n        self.assertEqual(ssl.Purpose.CLIENT_AUTH, val)\n        self.assertEqual(ssl.Purpose.CLIENT_AUTH.nid, 130)\n        self.assertEqual(ssl.Purpose.CLIENT_AUTH.shortname, 'clientAuth')\n        self.assertEqual(ssl.Purpose.CLIENT_AUTH.oid,\n                              '1.3.6.1.5.5.7.3.2')\n\n    def test_unsupported_dtls(self):\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.addCleanup(s.close)\n        with self.assertRaises(NotImplementedError) as cx:\n            test_wrap_socket(s, cert_reqs=ssl.CERT_NONE)\n        self.assertEqual(str(cx.exception), \"only stream sockets are supported\")\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        with self.assertRaises(NotImplementedError) as cx:\n            ctx.wrap_socket(s)\n        self.assertEqual(str(cx.exception), \"only stream sockets are supported\")\n\n    def cert_time_ok(self, timestring, timestamp):\n        self.assertEqual(ssl.cert_time_to_seconds(timestring), timestamp)\n\n    def cert_time_fail(self, timestring):\n        with self.assertRaises(ValueError):\n            ssl.cert_time_to_seconds(timestring)\n\n    @unittest.skipUnless(utc_offset(),\n                         'local time needs to be different from UTC')\n    def test_cert_time_to_seconds_timezone(self):\n        # Issue #19940: ssl.cert_time_to_seconds() returns wrong\n        #               results if local timezone is not UTC\n        self.cert_time_ok(\"May  9 00:00:00 2007 GMT\", 1178668800.0)\n        self.cert_time_ok(\"Jan  5 09:34:43 2018 GMT\", 1515144883.0)\n\n    def test_cert_time_to_seconds(self):\n        timestring = \"Jan  5 09:34:43 2018 GMT\"\n        ts = 1515144883.0\n        self.cert_time_ok(timestring, ts)\n        # accept keyword parameter, assert its name\n        self.assertEqual(ssl.cert_time_to_seconds(cert_time=timestring), ts)\n        # accept both %e and %d (space or zero generated by strftime)\n        self.cert_time_ok(\"Jan 05 09:34:43 2018 GMT\", ts)\n        # case-insensitive\n        self.cert_time_ok(\"JaN  5 09:34:43 2018 GmT\", ts)\n        self.cert_time_fail(\"Jan  5 09:34 2018 GMT\")     # no seconds\n        self.cert_time_fail(\"Jan  5 09:34:43 2018\")      # no GMT\n        self.cert_time_fail(\"Jan  5 09:34:43 2018 UTC\")  # not GMT timezone\n        self.cert_time_fail(\"Jan 35 09:34:43 2018 GMT\")  # invalid day\n        self.cert_time_fail(\"Jon  5 09:34:43 2018 GMT\")  # invalid month\n        self.cert_time_fail(\"Jan  5 24:00:00 2018 GMT\")  # invalid hour\n        self.cert_time_fail(\"Jan  5 09:60:43 2018 GMT\")  # invalid minute\n\n        newyear_ts = 1230768000.0\n        # leap seconds\n        self.cert_time_ok(\"Dec 31 23:59:60 2008 GMT\", newyear_ts)\n        # same timestamp\n        self.cert_time_ok(\"Jan  1 00:00:00 2009 GMT\", newyear_ts)\n\n        self.cert_time_ok(\"Jan  5 09:34:59 2018 GMT\", 1515144899)\n        #  allow 60th second (even if it is not a leap second)\n        self.cert_time_ok(\"Jan  5 09:34:60 2018 GMT\", 1515144900)\n        #  allow 2nd leap second for compatibility with time.strptime()\n        self.cert_time_ok(\"Jan  5 09:34:61 2018 GMT\", 1515144901)\n        self.cert_time_fail(\"Jan  5 09:34:62 2018 GMT\")  # invalid seconds\n\n        # no special treatment for the special value:\n        #   99991231235959Z (rfc 5280)\n        self.cert_time_ok(\"Dec 31 23:59:59 9999 GMT\", 253402300799.0)\n\n    @support.run_with_locale('LC_ALL', '')\n    def test_cert_time_to_seconds_locale(self):\n        # `cert_time_to_seconds()` should be locale independent\n\n        def local_february_name():\n            return time.strftime('%b', (1, 2, 3, 4, 5, 6, 0, 0, 0))\n\n        if local_february_name().lower() == 'feb':\n            self.skipTest(\"locale-specific month name needs to be \"\n                          \"different from C locale\")\n\n        # locale-independent\n        self.cert_time_ok(\"Feb  9 00:00:00 2007 GMT\", 1170979200.0)\n        self.cert_time_fail(local_february_name() + \"  9 00:00:00 2007 GMT\")\n\n    def test_connect_ex_error(self):\n        server = socket.socket(socket.AF_INET)\n        self.addCleanup(server.close)\n        port = support.bind_port(server)  # Reserve port but don't listen\n        s = test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED)\n        self.addCleanup(s.close)\n        rc = s.connect_ex((HOST, port))\n        # Issue #19919: Windows machines or VMs hosted on Windows\n        # machines sometimes return EWOULDBLOCK.\n        errors = (\n            errno.ECONNREFUSED, errno.EHOSTUNREACH, errno.ETIMEDOUT,\n            errno.EWOULDBLOCK,\n        )\n        self.assertIn(rc, errors)\n\n\nclass ContextTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_constructor(self):\n        for protocol in PROTOCOLS:\n            ssl.SSLContext(protocol)\n        ctx = ssl.SSLContext()\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertRaises(ValueError, ssl.SSLContext, -1)\n        self.assertRaises(ValueError, ssl.SSLContext, 42)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.protocol, proto)\n\n    def test_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.set_ciphers(\"ALL\")\n        ctx.set_ciphers(\"DEFAULT\")\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            ctx.set_ciphers(\"^$:,;?*'dorothyx\")\n\n    @unittest.skipUnless(PY_SSL_DEFAULT_CIPHERS == 1,\n                         \"Test applies only to Python default ciphers\")\n    def test_python_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ciphers = ctx.get_ciphers()\n        for suite in ciphers:\n            name = suite['name']\n            self.assertNotIn(\"PSK\", name)\n            self.assertNotIn(\"SRP\", name)\n            self.assertNotIn(\"MD5\", name)\n            self.assertNotIn(\"RC4\", name)\n            self.assertNotIn(\"3DES\", name)\n\n    @unittest.skipIf(ssl.OPENSSL_VERSION_INFO < (1, 0, 2, 0, 0), 'OpenSSL too old')\n    def test_get_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.set_ciphers('AESGCM')\n        names = set(d['name'] for d in ctx.get_ciphers())\n        self.assertIn('AES256-GCM-SHA384', names)\n        self.assertIn('AES128-GCM-SHA256', names)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_options(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        # OP_ALL | OP_NO_SSLv2 | OP_NO_SSLv3 is the default value\n        default = (ssl.OP_ALL | ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n        # SSLContext also enables these by default\n        default |= (OP_NO_COMPRESSION | OP_CIPHER_SERVER_PREFERENCE |\n                    OP_SINGLE_DH_USE | OP_SINGLE_ECDH_USE |\n                    OP_ENABLE_MIDDLEBOX_COMPAT)\n        self.assertEqual(default, ctx.options)\n        ctx.options |= ssl.OP_NO_TLSv1\n        self.assertEqual(default | ssl.OP_NO_TLSv1, ctx.options)\n        if can_clear_options():\n            ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)\n            self.assertEqual(default, ctx.options)\n            ctx.options = 0\n            # Ubuntu has OP_NO_SSLv3 forced on by default\n            self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)\n        else:\n            with self.assertRaises(ValueError):\n                ctx.options = 0\n\n    def test_verify_mode_protocol(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        # Default value\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        with self.assertRaises(TypeError):\n            ctx.verify_mode = None\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = 42\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self.assertFalse(ctx.check_hostname)\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        self.assertTrue(ctx.check_hostname)\n\n    def test_hostname_checks_common_name(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertTrue(ctx.hostname_checks_common_name)\n        if ssl.HAS_NEVER_CHECK_COMMON_NAME:\n            ctx.hostname_checks_common_name = True\n            self.assertTrue(ctx.hostname_checks_common_name)\n            ctx.hostname_checks_common_name = False\n            self.assertFalse(ctx.hostname_checks_common_name)\n            ctx.hostname_checks_common_name = True\n            self.assertTrue(ctx.hostname_checks_common_name)\n        else:\n            with self.assertRaises(AttributeError):\n                ctx.hostname_checks_common_name = True\n\n    @unittest.skipUnless(hasattr(ssl.SSLContext, 'minimum_version'),\n                         \"required OpenSSL 1.1.0g\")\n    def test_min_max_version(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        self.assertEqual(\n            ctx.minimum_version, ssl.TLSVersion.MINIMUM_SUPPORTED\n        )\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.MAXIMUM_SUPPORTED\n        )\n\n        ctx.minimum_version = ssl.TLSVersion.TLSv1_1\n        ctx.maximum_version = ssl.TLSVersion.TLSv1_2\n        self.assertEqual(\n            ctx.minimum_version, ssl.TLSVersion.TLSv1_1\n        )\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.TLSv1_2\n        )\n\n        ctx.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED\n        ctx.maximum_version = ssl.TLSVersion.TLSv1\n        self.assertEqual(\n            ctx.minimum_version, ssl.TLSVersion.MINIMUM_SUPPORTED\n        )\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.TLSv1\n        )\n\n        ctx.maximum_version = ssl.TLSVersion.MAXIMUM_SUPPORTED\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.MAXIMUM_SUPPORTED\n        )\n\n        ctx.maximum_version = ssl.TLSVersion.MINIMUM_SUPPORTED\n        self.assertIn(\n            ctx.maximum_version,\n            {ssl.TLSVersion.TLSv1, ssl.TLSVersion.SSLv3}\n        )\n\n        ctx.minimum_version = ssl.TLSVersion.MAXIMUM_SUPPORTED\n        self.assertIn(\n            ctx.minimum_version,\n            {ssl.TLSVersion.TLSv1_2, ssl.TLSVersion.TLSv1_3}\n        )\n\n        with self.assertRaises(ValueError):\n            ctx.minimum_version = 42\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1_1)\n\n        self.assertEqual(\n            ctx.minimum_version, ssl.TLSVersion.MINIMUM_SUPPORTED\n        )\n        self.assertEqual(\n            ctx.maximum_version, ssl.TLSVersion.MAXIMUM_SUPPORTED\n        )\n        with self.assertRaises(ValueError):\n            ctx.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED\n        with self.assertRaises(ValueError):\n            ctx.maximum_version = ssl.TLSVersion.TLSv1\n\n\n    @unittest.skipUnless(have_verify_flags(),\n                         \"verify_flags need OpenSSL > 0.9.8\")\n    def test_verify_flags(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        # default value\n        tf = getattr(ssl, \"VERIFY_X509_TRUSTED_FIRST\", 0)\n        self.assertEqual(ctx.verify_flags, ssl.VERIFY_DEFAULT | tf)\n        ctx.verify_flags = ssl.VERIFY_CRL_CHECK_LEAF\n        self.assertEqual(ctx.verify_flags, ssl.VERIFY_CRL_CHECK_LEAF)\n        ctx.verify_flags = ssl.VERIFY_CRL_CHECK_CHAIN\n        self.assertEqual(ctx.verify_flags, ssl.VERIFY_CRL_CHECK_CHAIN)\n        ctx.verify_flags = ssl.VERIFY_DEFAULT\n        self.assertEqual(ctx.verify_flags, ssl.VERIFY_DEFAULT)\n        # supports any value\n        ctx.verify_flags = ssl.VERIFY_CRL_CHECK_LEAF | ssl.VERIFY_X509_STRICT\n        self.assertEqual(ctx.verify_flags,\n                         ssl.VERIFY_CRL_CHECK_LEAF | ssl.VERIFY_X509_STRICT)\n        with self.assertRaises(TypeError):\n            ctx.verify_flags = None\n\n    def test_load_cert_chain(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        # Combined key and cert in a single file\n        ctx.load_cert_chain(CERTFILE, keyfile=None)\n        ctx.load_cert_chain(CERTFILE, keyfile=CERTFILE)\n        self.assertRaises(TypeError, ctx.load_cert_chain, keyfile=CERTFILE)\n        with self.assertRaises(OSError) as cm:\n            ctx.load_cert_chain(NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(BADCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(EMPTYCERT)\n        # Separate key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY)\n        ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)\n        ctx.load_cert_chain(certfile=BYTES_ONLYCERT, keyfile=BYTES_ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)\n        # Mismatching key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        with self.assertRaisesRegex(ssl.SSLError, \"key values mismatch\"):\n            ctx.load_cert_chain(CAFILE_CACERT, ONLYKEY)\n        # Password protected key and cert\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD.encode())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=bytearray(KEY_PASSWORD.encode()))\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD.encode())\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED,\n                            bytearray(KEY_PASSWORD.encode()))\n        with self.assertRaisesRegex(TypeError, \"should be a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=True)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=\"badpass\")\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            # openssl has a fixed limit on the password buffer.\n            # PEM_BUFSIZE is generally set to 1kb.\n            # Return a string larger than this.\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=b'a' * 102400)\n        # Password callback\n        def getpass_unicode():\n            return KEY_PASSWORD\n        def getpass_bytes():\n            return KEY_PASSWORD.encode()\n        def getpass_bytearray():\n            return bytearray(KEY_PASSWORD.encode())\n        def getpass_badpass():\n            return \"badpass\"\n        def getpass_huge():\n            return b'a' * (1024 * 1024)\n        def getpass_bad_type():\n            return 9\n        def getpass_exception():\n            raise Exception('getpass error')\n        class GetPassCallable:\n            def __call__(self):\n                return KEY_PASSWORD\n            def getpass(self):\n                return KEY_PASSWORD\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_unicode)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytes)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytearray)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=GetPassCallable())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=GetPassCallable().getpass)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_badpass)\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_huge)\n        with self.assertRaisesRegex(TypeError, \"must return a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bad_type)\n        with self.assertRaisesRegex(Exception, \"getpass error\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_exception)\n        # Make sure the password function isn't called if it isn't needed\n        ctx.load_cert_chain(CERTFILE, password=getpass_exception)\n\n    def test_load_verify_locations(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.load_verify_locations(CERTFILE)\n        ctx.load_verify_locations(cafile=CERTFILE, capath=None)\n        ctx.load_verify_locations(BYTES_CERTFILE)\n        ctx.load_verify_locations(cafile=BYTES_CERTFILE, capath=None)\n        self.assertRaises(TypeError, ctx.load_verify_locations)\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, None, None)\n        with self.assertRaises(OSError) as cm:\n            ctx.load_verify_locations(NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_verify_locations(BADCERT)\n        ctx.load_verify_locations(CERTFILE, CAPATH)\n        ctx.load_verify_locations(CERTFILE, capath=BYTES_CAPATH)\n\n        # Issue #10989: crash if the second argument type is invalid\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, True)\n\n    def test_load_verify_cadata(self):\n        # test cadata\n        with open(CAFILE_CACERT) as f:\n            cacert_pem = f.read()\n        cacert_der = ssl.PEM_cert_to_DER_cert(cacert_pem)\n        with open(CAFILE_NEURONIO) as f:\n            neuronio_pem = f.read()\n        neuronio_der = ssl.PEM_cert_to_DER_cert(neuronio_pem)\n\n        # test PEM\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 0)\n        ctx.load_verify_locations(cadata=cacert_pem)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 1)\n        ctx.load_verify_locations(cadata=neuronio_pem)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n        # cert already in hash table\n        ctx.load_verify_locations(cadata=neuronio_pem)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # combined\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        combined = \"\\n\".join((cacert_pem, neuronio_pem))\n        ctx.load_verify_locations(cadata=combined)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # with junk around the certs\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        combined = [\"head\", cacert_pem, \"other\", neuronio_pem, \"again\",\n                    neuronio_pem, \"tail\"]\n        ctx.load_verify_locations(cadata=\"\\n\".join(combined))\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # test DER\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_verify_locations(cadata=cacert_der)\n        ctx.load_verify_locations(cadata=neuronio_der)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n        # cert already in hash table\n        ctx.load_verify_locations(cadata=cacert_der)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # combined\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        combined = b\"\".join((cacert_der, neuronio_der))\n        ctx.load_verify_locations(cadata=combined)\n        self.assertEqual(ctx.cert_store_stats()[\"x509_ca\"], 2)\n\n        # error cases\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertRaises(TypeError, ctx.load_verify_locations, cadata=object)\n\n        with self.assertRaisesRegex(ssl.SSLError, \"no start line\"):\n            ctx.load_verify_locations(cadata=\"broken\")\n        with self.assertRaisesRegex(ssl.SSLError, \"not enough data\"):\n            ctx.load_verify_locations(cadata=b\"broken\")\n\n\n    def test_load_dh_params(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.load_dh_params(DHFILE)\n        if os.name != 'nt':\n            ctx.load_dh_params(BYTES_DHFILE)\n        self.assertRaises(TypeError, ctx.load_dh_params)\n        self.assertRaises(TypeError, ctx.load_dh_params, None)\n        with self.assertRaises(FileNotFoundError) as cm:\n            ctx.load_dh_params(NONEXISTINGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_session_stats(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.session_stats(), {\n                'number': 0,\n                'connect': 0,\n                'connect_good': 0,\n                'connect_renegotiate': 0,\n                'accept': 0,\n                'accept_good': 0,\n                'accept_renegotiate': 0,\n                'hits': 0,\n                'misses': 0,\n                'timeouts': 0,\n                'cache_full': 0,\n            })\n\n    def test_set_default_verify_paths(self):\n        # There's not much we can do to test that it acts as expected,\n        # so just check it doesn't crash or raise an exception.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.set_default_verify_paths()\n\n    @unittest.skipUnless(ssl.HAS_ECDH, \"ECDH disabled on this OpenSSL build\")\n    def test_set_ecdh_curve(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.set_ecdh_curve(\"prime256v1\")\n        ctx.set_ecdh_curve(b\"prime256v1\")\n        self.assertRaises(TypeError, ctx.set_ecdh_curve)\n        self.assertRaises(TypeError, ctx.set_ecdh_curve, None)\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, \"foo\")\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, b\"foo\")\n\n    @needs_sni\n    def test_sni_callback(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n\n        # set_servername_callback expects a callable, or None\n        self.assertRaises(TypeError, ctx.set_servername_callback)\n        self.assertRaises(TypeError, ctx.set_servername_callback, 4)\n        self.assertRaises(TypeError, ctx.set_servername_callback, \"\")\n        self.assertRaises(TypeError, ctx.set_servername_callback, ctx)\n\n        def dummycallback(sock, servername, ctx):\n            pass\n        ctx.set_servername_callback(None)\n        ctx.set_servername_callback(dummycallback)\n\n    @needs_sni\n    def test_sni_callback_refcycle(self):\n        # Reference cycles through the servername callback are detected\n        # and cleared.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        def dummycallback(sock, servername, ctx, cycle=ctx):\n            pass\n        ctx.set_servername_callback(dummycallback)\n        wr = weakref.ref(ctx)\n        del ctx, dummycallback\n        gc.collect()\n        self.assertIs(wr(), None)\n\n    def test_cert_store_stats(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 0})\n        ctx.load_cert_chain(CERTFILE)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 0})\n        ctx.load_verify_locations(CERTFILE)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 1})\n        ctx.load_verify_locations(CAFILE_CACERT)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 1, 'crl': 0, 'x509': 2})\n\n    def test_get_ca_certs(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        # CERTFILE is not flagged as X509v3 Basic Constraints: CA:TRUE\n        ctx.load_verify_locations(CERTFILE)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        # but CAFILE_CACERT is a CA cert\n        ctx.load_verify_locations(CAFILE_CACERT)\n        self.assertEqual(ctx.get_ca_certs(),\n            [{'issuer': ((('organizationName', 'Root CA'),),\n                         (('organizationalUnitName', 'http://www.cacert.org'),),\n                         (('commonName', 'CA Cert Signing Authority'),),\n                         (('emailAddress', 'support@cacert.org'),)),\n              'notAfter': asn1time('Mar 29 12:29:49 2033 GMT'),\n              'notBefore': asn1time('Mar 30 12:29:49 2003 GMT'),\n              'serialNumber': '00',\n              'crlDistributionPoints': ('https://www.cacert.org/revoke.crl',),\n              'subject': ((('organizationName', 'Root CA'),),\n                          (('organizationalUnitName', 'http://www.cacert.org'),),\n                          (('commonName', 'CA Cert Signing Authority'),),\n                          (('emailAddress', 'support@cacert.org'),)),\n              'version': 3}])\n\n        with open(CAFILE_CACERT) as f:\n            pem = f.read()\n        der = ssl.PEM_cert_to_DER_cert(pem)\n        self.assertEqual(ctx.get_ca_certs(True), [der])\n\n    def test_load_default_certs(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_default_certs()\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_default_certs(ssl.Purpose.SERVER_AUTH)\n        ctx.load_default_certs()\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_default_certs(ssl.Purpose.CLIENT_AUTH)\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertRaises(TypeError, ctx.load_default_certs, None)\n        self.assertRaises(TypeError, ctx.load_default_certs, 'SERVER_AUTH')\n\n    @unittest.skipIf(sys.platform == \"win32\", \"not-Windows specific\")\n    @unittest.skipIf(IS_LIBRESSL, \"LibreSSL doesn't support env vars\")\n    def test_load_default_certs_env(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        with support.EnvironmentVarGuard() as env:\n            env[\"SSL_CERT_DIR\"] = CAPATH\n            env[\"SSL_CERT_FILE\"] = CERTFILE\n            ctx.load_default_certs()\n            self.assertEqual(ctx.cert_store_stats(), {\"crl\": 0, \"x509\": 1, \"x509_ca\": 0})\n\n    @unittest.skipUnless(sys.platform == \"win32\", \"Windows specific\")\n    @unittest.skipIf(hasattr(sys, \"gettotalrefcount\"), \"Debug build does not share environment between CRTs\")\n    def test_load_default_certs_env_windows(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_default_certs()\n        stats = ctx.cert_store_stats()\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        with support.EnvironmentVarGuard() as env:\n            env[\"SSL_CERT_DIR\"] = CAPATH\n            env[\"SSL_CERT_FILE\"] = CERTFILE\n            ctx.load_default_certs()\n            stats[\"x509\"] += 1\n            self.assertEqual(ctx.cert_store_stats(), stats)\n\n    def _assert_context_options(self, ctx):\n        self.assertEqual(ctx.options & ssl.OP_NO_SSLv2, ssl.OP_NO_SSLv2)\n        if OP_NO_COMPRESSION != 0:\n            self.assertEqual(ctx.options & OP_NO_COMPRESSION,\n                             OP_NO_COMPRESSION)\n        if OP_SINGLE_DH_USE != 0:\n            self.assertEqual(ctx.options & OP_SINGLE_DH_USE,\n                             OP_SINGLE_DH_USE)\n        if OP_SINGLE_ECDH_USE != 0:\n            self.assertEqual(ctx.options & OP_SINGLE_ECDH_USE,\n                             OP_SINGLE_ECDH_USE)\n        if OP_CIPHER_SERVER_PREFERENCE != 0:\n            self.assertEqual(ctx.options & OP_CIPHER_SERVER_PREFERENCE,\n                             OP_CIPHER_SERVER_PREFERENCE)\n\n    def test_create_default_context(self):\n        ctx = ssl.create_default_context()\n\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        self.assertTrue(ctx.check_hostname)\n        self._assert_context_options(ctx)\n\n        with open(SIGNING_CA) as f:\n            cadata = f.read()\n        ctx = ssl.create_default_context(cafile=SIGNING_CA, capath=CAPATH,\n                                         cadata=cadata)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        self._assert_context_options(ctx)\n\n        ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self._assert_context_options(ctx)\n\n    def test__create_stdlib_context(self):\n        ctx = ssl._create_stdlib_context()\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self.assertFalse(ctx.check_hostname)\n        self._assert_context_options(ctx)\n\n        ctx = ssl._create_stdlib_context(ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self._assert_context_options(ctx)\n\n        ctx = ssl._create_stdlib_context(ssl.PROTOCOL_TLSv1,\n                                         cert_reqs=ssl.CERT_REQUIRED,\n                                         check_hostname=True)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        self.assertTrue(ctx.check_hostname)\n        self._assert_context_options(ctx)\n\n        ctx = ssl._create_stdlib_context(purpose=ssl.Purpose.CLIENT_AUTH)\n        self.assertEqual(ctx.protocol, ssl.PROTOCOL_TLS)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        self._assert_context_options(ctx)\n\n    def test_check_hostname(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n\n        # Auto set CERT_REQUIRED\n        ctx.check_hostname = True\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.check_hostname = False\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n\n        # Changing verify_mode does not affect check_hostname\n        ctx.check_hostname = False\n        ctx.verify_mode = ssl.CERT_NONE\n        ctx.check_hostname = False\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        # Auto set\n        ctx.check_hostname = True\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n\n        ctx.check_hostname = False\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        ctx.check_hostname = False\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        # keep CERT_OPTIONAL\n        ctx.check_hostname = True\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n\n        # Cannot set CERT_NONE with check_hostname enabled\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = ssl.CERT_NONE\n        ctx.check_hostname = False\n        self.assertFalse(ctx.check_hostname)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n\n    def test_context_client_server(self):\n        # PROTOCOL_TLS_CLIENT has sane defaults\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n\n        # PROTOCOL_TLS_SERVER has different but also sane defaults\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        self.assertFalse(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n\n    def test_context_custom_class(self):\n        class MySSLSocket(ssl.SSLSocket):\n            pass\n\n        class MySSLObject(ssl.SSLObject):\n            pass\n\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        ctx.sslsocket_class = MySSLSocket\n        ctx.sslobject_class = MySSLObject\n\n        with ctx.wrap_socket(socket.socket(), server_side=True) as sock:\n            self.assertIsInstance(sock, MySSLSocket)\n        obj = ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO())\n        self.assertIsInstance(obj, MySSLObject)\n\n\nclass SSLErrorTests(unittest.TestCase):\n\n    def test_str(self):\n        # The str() of a SSLError doesn't include the errno\n        e = ssl.SSLError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n        # Same for a subclass\n        e = ssl.SSLZeroReturnError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n\n    def test_lib_reason(self):\n        # Test the library and reason attributes\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n        self.assertEqual(cm.exception.library, 'PEM')\n        self.assertEqual(cm.exception.reason, 'NO_START_LINE')\n        s = str(cm.exception)\n        self.assertTrue(s.startswith(\"[PEM: NO_START_LINE] no start line\"), s)\n\n    def test_subclass(self):\n        # Check that the appropriate SSLError subclass is raised\n        # (this only tests one of them)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.check_hostname = False\n        ctx.verify_mode = ssl.CERT_NONE\n        with socket.socket() as s:\n            s.bind((\"127.0.0.1\", 0))\n            s.listen()\n            c = socket.socket()\n            c.connect(s.getsockname())\n            c.setblocking(False)\n            with ctx.wrap_socket(c, False, do_handshake_on_connect=False) as c:\n                with self.assertRaises(ssl.SSLWantReadError) as cm:\n                    c.do_handshake()\n                s = str(cm.exception)\n                self.assertTrue(s.startswith(\"The operation did not complete (read)\"), s)\n                # For compatibility\n                self.assertEqual(cm.exception.errno, ssl.SSL_ERROR_WANT_READ)\n\n\n    def test_bad_server_hostname(self):\n        ctx = ssl.create_default_context()\n        with self.assertRaises(ValueError):\n            ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO(),\n                         server_hostname=\"\")\n        with self.assertRaises(ValueError):\n            ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO(),\n                         server_hostname=\".example.org\")\n        with self.assertRaises(TypeError):\n            ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO(),\n                         server_hostname=\"example.org\\x00evil.com\")\n\n\nclass MemoryBIOTests(unittest.TestCase):\n\n    def test_read_write(self):\n        bio = ssl.MemoryBIO()\n        bio.write(b'foo')\n        self.assertEqual(bio.read(), b'foo')\n        self.assertEqual(bio.read(), b'')\n        bio.write(b'foo')\n        bio.write(b'bar')\n        self.assertEqual(bio.read(), b'foobar')\n        self.assertEqual(bio.read(), b'')\n        bio.write(b'baz')\n        self.assertEqual(bio.read(2), b'ba')\n        self.assertEqual(bio.read(1), b'z')\n        self.assertEqual(bio.read(1), b'')\n\n    def test_eof(self):\n        bio = ssl.MemoryBIO()\n        self.assertFalse(bio.eof)\n        self.assertEqual(bio.read(), b'')\n        self.assertFalse(bio.eof)\n        bio.write(b'foo')\n        self.assertFalse(bio.eof)\n        bio.write_eof()\n        self.assertFalse(bio.eof)\n        self.assertEqual(bio.read(2), b'fo')\n        self.assertFalse(bio.eof)\n        self.assertEqual(bio.read(1), b'o')\n        self.assertTrue(bio.eof)\n        self.assertEqual(bio.read(), b'')\n        self.assertTrue(bio.eof)\n\n    def test_pending(self):\n        bio = ssl.MemoryBIO()\n        self.assertEqual(bio.pending, 0)\n        bio.write(b'foo')\n        self.assertEqual(bio.pending, 3)\n        for i in range(3):\n            bio.read(1)\n            self.assertEqual(bio.pending, 3-i-1)\n        for i in range(3):\n            bio.write(b'x')\n            self.assertEqual(bio.pending, i+1)\n        bio.read()\n        self.assertEqual(bio.pending, 0)\n\n    def test_buffer_types(self):\n        bio = ssl.MemoryBIO()\n        bio.write(b'foo')\n        self.assertEqual(bio.read(), b'foo')\n        bio.write(bytearray(b'bar'))\n        self.assertEqual(bio.read(), b'bar')\n        bio.write(memoryview(b'baz'))\n        self.assertEqual(bio.read(), b'baz')\n\n    def test_error_types(self):\n        bio = ssl.MemoryBIO()\n        self.assertRaises(TypeError, bio.write, 'foo')\n        self.assertRaises(TypeError, bio.write, None)\n        self.assertRaises(TypeError, bio.write, True)\n        self.assertRaises(TypeError, bio.write, 1)\n\n\nclass SSLObjectTests(unittest.TestCase):\n    def test_private_init(self):\n        bio = ssl.MemoryBIO()\n        with self.assertRaisesRegex(TypeError, \"public constructor\"):\n            ssl.SSLObject(bio, bio)\n\n\nclass SimpleBackgroundTests(unittest.TestCase):\n    \"\"\"Tests that connect to a simple server running in the background\"\"\"\n\n    def setUp(self):\n        server = ThreadedEchoServer(SIGNED_CERTFILE)\n        self.server_addr = (HOST, server.port)\n        server.__enter__()\n        self.addCleanup(server.__exit__, None, None, None)\n\n    def test_connect(self):\n        with test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_NONE) as s:\n            s.connect(self.server_addr)\n            self.assertEqual({}, s.getpeercert())\n            self.assertFalse(s.server_side)\n\n        # this should succeed because we specify the root cert\n        with test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED,\n                            ca_certs=SIGNING_CA) as s:\n            s.connect(self.server_addr)\n            self.assertTrue(s.getpeercert())\n            self.assertFalse(s.server_side)\n\n    def test_connect_fail(self):\n        # This should fail because we have no verification certs. Connection\n        # failure crashes ThreadedEchoServer, so run this in an independent\n        # test method.\n        s = test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED)\n        self.addCleanup(s.close)\n        self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                               s.connect, self.server_addr)\n\n    def test_connect_ex(self):\n        # Issue #11326: check connect_ex() implementation\n        s = test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED,\n                            ca_certs=SIGNING_CA)\n        self.addCleanup(s.close)\n        self.assertEqual(0, s.connect_ex(self.server_addr))\n        self.assertTrue(s.getpeercert())\n\n    def test_non_blocking_connect_ex(self):\n        # Issue #11326: non-blocking connect_ex() should allow handshake\n        # to proceed after the socket gets ready.\n        s = test_wrap_socket(socket.socket(socket.AF_INET),\n                            cert_reqs=ssl.CERT_REQUIRED,\n                            ca_certs=SIGNING_CA,\n                            do_handshake_on_connect=False)\n        self.addCleanup(s.close)\n        s.setblocking(False)\n        rc = s.connect_ex(self.server_addr)\n        # EWOULDBLOCK under Windows, EINPROGRESS elsewhere\n        self.assertIn(rc, (0, errno.EINPROGRESS, errno.EWOULDBLOCK))\n        # Wait for connect to finish\n        select.select([], [s], [], 5.0)\n        # Non-blocking handshake\n        while True:\n            try:\n                s.do_handshake()\n                break\n            except ssl.SSLWantReadError:\n                select.select([s], [], [], 5.0)\n            except ssl.SSLWantWriteError:\n                select.select([], [s], [], 5.0)\n        # SSL established\n        self.assertTrue(s.getpeercert())\n\n    def test_connect_with_context(self):\n        # Same as test_connect, but with a separately created context\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            self.assertEqual({}, s.getpeercert())\n        # Same with a server hostname\n        with ctx.wrap_socket(socket.socket(socket.AF_INET),\n                            server_hostname=\"dummy\") as s:\n            s.connect(self.server_addr)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        # This should succeed because we specify the root cert\n        ctx.load_verify_locations(SIGNING_CA)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n\n    def test_connect_with_context_fail(self):\n        # This should fail because we have no verification certs. Connection\n        # failure crashes ThreadedEchoServer, so run this in an independent\n        # test method.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n        self.addCleanup(s.close)\n        self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                s.connect, self.server_addr)\n\n    def test_connect_capath(self):\n        # Verify server certificates using the `capath` argument\n        # NOTE: the subject hashing algorithm has been changed between\n        # OpenSSL 0.9.8n and 1.0.0, as a result the capath directory must\n        # contain both versions of each certificate (same content, different\n        # filename) for this test to be portable across OpenSSL releases.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        ctx.load_verify_locations(capath=CAPATH)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n        # Same with a bytes `capath` argument\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        ctx.load_verify_locations(capath=BYTES_CAPATH)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n\n    def test_connect_cadata(self):\n        with open(SIGNING_CA) as f:\n            pem = f.read()\n        der = ssl.PEM_cert_to_DER_cert(pem)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        # TODO: fix TLSv1.3 support\n        ctx.options |= ssl.OP_NO_TLSv1_3\n        ctx.load_verify_locations(cadata=pem)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n\n        # same with DER\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        # TODO: fix TLSv1.3 support\n        ctx.options |= ssl.OP_NO_TLSv1_3\n        ctx.load_verify_locations(cadata=der)\n        with ctx.wrap_socket(socket.socket(socket.AF_INET)) as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n\n    @unittest.skipIf(os.name == \"nt\", \"Can't use a socket as a file under Windows\")\n    def test_makefile_close(self):\n        # Issue #5238: creating a file-like object with makefile() shouldn't\n        # delay closing the underlying \"real socket\" (here tested with its\n        # file descriptor, hence skipping the test under Windows).\n        ss = test_wrap_socket(socket.socket(socket.AF_INET))\n        ss.connect(self.server_addr)\n        fd = ss.fileno()\n        f = ss.makefile()\n        f.close()\n        # The fd is still open\n        os.read(fd, 0)\n        # Closing the SSL socket should close the fd too\n        ss.close()\n        gc.collect()\n        with self.assertRaises(OSError) as e:\n            os.read(fd, 0)\n        self.assertEqual(e.exception.errno, errno.EBADF)\n\n    def test_non_blocking_handshake(self):\n        s = socket.socket(socket.AF_INET)\n        s.connect(self.server_addr)\n        s.setblocking(False)\n        s = test_wrap_socket(s,\n                            cert_reqs=ssl.CERT_NONE,\n                            do_handshake_on_connect=False)\n        self.addCleanup(s.close)\n        count = 0\n        while True:\n            try:\n                count += 1\n                s.do_handshake()\n                break\n            except ssl.SSLWantReadError:\n                select.select([s], [], [])\n            except ssl.SSLWantWriteError:\n                select.select([], [s], [])\n        if support.verbose:\n            sys.stdout.write(\"\\nNeeded %d calls to do_handshake() to establish session.\\n\" % count)\n\n    def test_get_server_certificate(self):\n        _test_get_server_certificate(self, *self.server_addr, cert=SIGNING_CA)\n\n    def test_get_server_certificate_fail(self):\n        # Connection failure crashes ThreadedEchoServer, so run this in an\n        # independent test method\n        _test_get_server_certificate_fail(self, *self.server_addr)\n\n    def test_ciphers(self):\n        with test_wrap_socket(socket.socket(socket.AF_INET),\n                             cert_reqs=ssl.CERT_NONE, ciphers=\"ALL\") as s:\n            s.connect(self.server_addr)\n        with test_wrap_socket(socket.socket(socket.AF_INET),\n                             cert_reqs=ssl.CERT_NONE, ciphers=\"DEFAULT\") as s:\n            s.connect(self.server_addr)\n        # Error checking can happen at instantiation or when connecting\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            with socket.socket(socket.AF_INET) as sock:\n                s = test_wrap_socket(sock,\n                                    cert_reqs=ssl.CERT_NONE, ciphers=\"^$:,;?*'dorothyx\")\n                s.connect(self.server_addr)\n\n    def test_get_ca_certs_capath(self):\n        # capath certs are loaded on request\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx.load_verify_locations(capath=CAPATH)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        with ctx.wrap_socket(socket.socket(socket.AF_INET),\n                             server_hostname='localhost') as s:\n            s.connect(self.server_addr)\n            cert = s.getpeercert()\n            self.assertTrue(cert)\n        self.assertEqual(len(ctx.get_ca_certs()), 1)\n\n    @needs_sni\n    def test_context_setget(self):\n        # Check that the context of a connected socket can be replaced.\n        ctx1 = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx1.load_verify_locations(capath=CAPATH)\n        ctx2 = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        ctx2.load_verify_locations(capath=CAPATH)\n        s = socket.socket(socket.AF_INET)\n        with ctx1.wrap_socket(s, server_hostname='localhost') as ss:\n            ss.connect(self.server_addr)\n            self.assertIs(ss.context, ctx1)\n            self.assertIs(ss._sslobj.context, ctx1)\n            ss.context = ctx2\n            self.assertIs(ss.context, ctx2)\n            self.assertIs(ss._sslobj.context, ctx2)\n\n    def ssl_io_loop(self, sock, incoming, outgoing, func, *args, **kwargs):\n        # A simple IO loop. Call func(*args) depending on the error we get\n        # (WANT_READ or WANT_WRITE) move data between the socket and the BIOs.\n        timeout = kwargs.get('timeout', 10)\n        deadline = time.monotonic() + timeout\n        count = 0\n        while True:\n            if time.monotonic() > deadline:\n                self.fail(\"timeout\")\n            errno = None\n            count += 1\n            try:\n                ret = func(*args)\n            except ssl.SSLError as e:\n                if e.errno not in (ssl.SSL_ERROR_WANT_READ,\n                                   ssl.SSL_ERROR_WANT_WRITE):\n                    raise\n                errno = e.errno\n            # Get any data from the outgoing BIO irrespective of any error, and\n            # send it to the socket.\n            buf = outgoing.read()\n            sock.sendall(buf)\n            # If there's no error, we're done. For WANT_READ, we need to get\n            # data from the socket and put it in the incoming BIO.\n            if errno is None:\n                break\n            elif errno == ssl.SSL_ERROR_WANT_READ:\n                buf = sock.recv(32768)\n                if buf:\n                    incoming.write(buf)\n                else:\n                    incoming.write_eof()\n        if support.verbose:\n            sys.stdout.write(\"Needed %d calls to complete %s().\\n\"\n                             % (count, func.__name__))\n        return ret\n\n    def test_bio_handshake(self):\n        sock = socket.socket(socket.AF_INET)\n        self.addCleanup(sock.close)\n        sock.connect(self.server_addr)\n        incoming = ssl.MemoryBIO()\n        outgoing = ssl.MemoryBIO()\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        self.assertTrue(ctx.check_hostname)\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.load_verify_locations(SIGNING_CA)\n        sslobj = ctx.wrap_bio(incoming, outgoing, False,\n                              SIGNED_CERTFILE_HOSTNAME)\n        self.assertIs(sslobj._sslobj.owner, sslobj)\n        self.assertIsNone(sslobj.cipher())\n        self.assertIsNone(sslobj.version())\n        self.assertIsNotNone(sslobj.shared_ciphers())\n        self.assertRaises(ValueError, sslobj.getpeercert)\n        if 'tls-unique' in ssl.CHANNEL_BINDING_TYPES:\n            self.assertIsNone(sslobj.get_channel_binding('tls-unique'))\n        self.ssl_io_loop(sock, incoming, outgoing, sslobj.do_handshake)\n        self.assertTrue(sslobj.cipher())\n        self.assertIsNotNone(sslobj.shared_ciphers())\n        self.assertIsNotNone(sslobj.version())\n        self.assertTrue(sslobj.getpeercert())\n        if 'tls-unique' in ssl.CHANNEL_BINDING_TYPES:\n            self.assertTrue(sslobj.get_channel_binding('tls-unique'))\n        try:\n            self.ssl_io_loop(sock, incoming, outgoing, sslobj.unwrap)\n        except ssl.SSLSyscallError:\n            # If the server shuts down the TCP connection without sending a\n            # secure shutdown message, this is reported as SSL_ERROR_SYSCALL\n            pass\n        self.assertRaises(ssl.SSLError, sslobj.write, b'foo')\n\n    def test_bio_read_write_data(self):\n        sock = socket.socket(socket.AF_INET)\n        self.addCleanup(sock.close)\n        sock.connect(self.server_addr)\n        incoming = ssl.MemoryBIO()\n        outgoing = ssl.MemoryBIO()\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        ctx.verify_mode = ssl.CERT_NONE\n        sslobj = ctx.wrap_bio(incoming, outgoing, False)\n        self.ssl_io_loop(sock, incoming, outgoing, sslobj.do_handshake)\n        req = b'FOO\\n'\n        self.ssl_io_loop(sock, incoming, outgoing, sslobj.write, req)\n        buf = self.ssl_io_loop(sock, incoming, outgoing, sslobj.read, 1024)\n        self.assertEqual(buf, b'foo\\n')\n        self.ssl_io_loop(sock, incoming, outgoing, sslobj.unwrap)\n\n\nclass NetworkedTests(unittest.TestCase):\n\n    def test_timeout_connect_ex(self):\n        # Issue #12065: on a timeout, connect_ex() should return the original\n        # errno (mimicking the behaviour of non-SSL sockets).\n        with support.transient_internet(REMOTE_HOST):\n            s = test_wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                do_handshake_on_connect=False)\n            self.addCleanup(s.close)\n            s.settimeout(0.0000001)\n            rc = s.connect_ex((REMOTE_HOST, 443))\n            if rc == 0:\n                self.skipTest(\"REMOTE_HOST responded too quickly\")\n            self.assertIn(rc, (errno.EAGAIN, errno.EWOULDBLOCK))\n\n    @unittest.skipUnless(support.IPV6_ENABLED, 'Needs IPv6')\n    def test_get_server_certificate_ipv6(self):\n        with support.transient_internet('ipv6.google.com'):\n            _test_get_server_certificate(self, 'ipv6.google.com', 443)\n            _test_get_server_certificate_fail(self, 'ipv6.google.com', 443)\n\n\ndef _test_get_server_certificate(test, host, port, cert=None):\n    pem = ssl.get_server_certificate((host, port))\n    if not pem:\n        test.fail(\"No server certificate on %s:%s!\" % (host, port))\n\n    pem = ssl.get_server_certificate((host, port), ca_certs=cert)\n    if not pem:\n        test.fail(\"No server certificate on %s:%s!\" % (host, port))\n    if support.verbose:\n        sys.stdout.write(\"\\nVerified certificate for %s:%s is\\n%s\\n\" % (host, port ,pem))\n\ndef _test_get_server_certificate_fail(test, host, port):\n    try:\n        pem = ssl.get_server_certificate((host, port), ca_certs=CERTFILE)\n    except ssl.SSLError as x:\n        #should fail\n        if support.verbose:\n            sys.stdout.write(\"%s\\n\" % x)\n    else:\n        test.fail(\"Got server certificate %s for %s:%s!\" % (pem, host, port))\n\n\nfrom test.ssl_servers import make_https_server\n\nclass ThreadedEchoServer(threading.Thread):\n\n    class ConnectionHandler(threading.Thread):\n\n        \"\"\"A mildly complicated class, because we want it to work both\n        with and without the SSL wrapper around the socket connection, so\n        that we can test the STARTTLS functionality.\"\"\"\n\n        def __init__(self, server, connsock, addr):\n            self.server = server\n            self.running = False\n            self.sock = connsock\n            self.addr = addr\n            self.sock.setblocking(1)\n            self.sslconn = None\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def wrap_conn(self):\n            try:\n                self.sslconn = self.server.context.wrap_socket(\n                    self.sock, server_side=True)\n                self.server.selected_npn_protocols.append(self.sslconn.selected_npn_protocol())\n                self.server.selected_alpn_protocols.append(self.sslconn.selected_alpn_protocol())\n            except (ssl.SSLError, ConnectionResetError, OSError) as e:\n                # We treat ConnectionResetError as though it were an\n                # SSLError - OpenSSL on Ubuntu abruptly closes the\n                # connection when asked to use an unsupported protocol.\n                #\n                # OSError may occur with wrong protocols, e.g. both\n                # sides use PROTOCOL_TLS_SERVER.\n                #\n                # XXX Various errors can have happened here, for example\n                # a mismatching protocol version, an invalid certificate,\n                # or a low-level bug. This should be made more discriminating.\n                #\n                # bpo-31323: Store the exception as string to prevent\n                # a reference leak: server -> conn_errors -> exception\n                # -> traceback -> self (ConnectionHandler) -> server\n                self.server.conn_errors.append(str(e))\n                if self.server.chatty:\n                    handle_error(\"\\n server:  bad connection attempt from \" + repr(self.addr) + \":\\n\")\n                self.running = False\n                self.server.stop()\n                self.close()\n                return False\n            else:\n                self.server.shared_ciphers.append(self.sslconn.shared_ciphers())\n                if self.server.context.verify_mode == ssl.CERT_REQUIRED:\n                    cert = self.sslconn.getpeercert()\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" client cert is \" + pprint.pformat(cert) + \"\\n\")\n                    cert_binary = self.sslconn.getpeercert(True)\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" cert binary is \" + str(len(cert_binary)) + \" bytes\\n\")\n                cipher = self.sslconn.cipher()\n                if support.verbose and self.server.chatty:\n                    sys.stdout.write(\" server: connection cipher is now \" + str(cipher) + \"\\n\")\n                    sys.stdout.write(\" server: selected protocol is now \"\n                            + str(self.sslconn.selected_npn_protocol()) + \"\\n\")\n                return True\n\n        def read(self):\n            if self.sslconn:\n                return self.sslconn.read()\n            else:\n                return self.sock.recv(1024)\n\n        def write(self, bytes):\n            if self.sslconn:\n                return self.sslconn.write(bytes)\n            else:\n                return self.sock.send(bytes)\n\n        def close(self):\n            if self.sslconn:\n                self.sslconn.close()\n            else:\n                self.sock.close()\n\n        def run(self):\n            self.running = True\n            if not self.server.starttls_server:\n                if not self.wrap_conn():\n                    return\n            while self.running:\n                try:\n                    msg = self.read()\n                    stripped = msg.strip()\n                    if not stripped:\n                        # eof, so quit this handler\n                        self.running = False\n                        try:\n                            self.sock = self.sslconn.unwrap()\n                        except OSError:\n                            # Many tests shut the TCP connection down\n                            # without an SSL shutdown. This causes\n                            # unwrap() to raise OSError with errno=0!\n                            pass\n                        else:\n                            self.sslconn = None\n                        self.close()\n                    elif stripped == b'over':\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: client closed connection\\n\")\n                        self.close()\n                        return\n                    elif (self.server.starttls_server and\n                          stripped == b'STARTTLS'):\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: read STARTTLS from client, sending OK...\\n\")\n                        self.write(b\"OK\\n\")\n                        if not self.wrap_conn():\n                            return\n                    elif (self.server.starttls_server and self.sslconn\n                          and stripped == b'ENDTLS'):\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: read ENDTLS from client, sending OK...\\n\")\n                        self.write(b\"OK\\n\")\n                        self.sock = self.sslconn.unwrap()\n                        self.sslconn = None\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: connection is now unencrypted...\\n\")\n                    elif stripped == b'CB tls-unique':\n                        if support.verbose and self.server.connectionchatty:\n                            sys.stdout.write(\" server: read CB tls-unique from client, sending our CB data...\\n\")\n                        data = self.sslconn.get_channel_binding(\"tls-unique\")\n                        self.write(repr(data).encode(\"us-ascii\") + b\"\\n\")\n                    else:\n                        if (support.verbose and\n                            self.server.connectionchatty):\n                            ctype = (self.sslconn and \"encrypted\") or \"unencrypted\"\n                            sys.stdout.write(\" server: read %r (%s), sending back %r (%s)...\\n\"\n                                             % (msg, ctype, msg.lower(), ctype))\n                        self.write(msg.lower())\n                except OSError:\n                    if self.server.chatty:\n                        handle_error(\"Test server failure:\\n\")\n                    self.close()\n                    self.running = False\n                    # normally, we'd just stop here, but for the test\n                    # harness, we want to stop the server\n                    self.server.stop()\n\n    def __init__(self, certificate=None, ssl_version=None,\n                 certreqs=None, cacerts=None,\n                 chatty=True, connectionchatty=False, starttls_server=False,\n                 npn_protocols=None, alpn_protocols=None,\n                 ciphers=None, context=None):\n        if context:\n            self.context = context\n        else:\n            self.context = ssl.SSLContext(ssl_version\n                                          if ssl_version is not None\n                                          else ssl.PROTOCOL_TLS_SERVER)\n            self.context.verify_mode = (certreqs if certreqs is not None\n                                        else ssl.CERT_NONE)\n            if cacerts:\n                self.context.load_verify_locations(cacerts)\n            if certificate:\n                self.context.load_cert_chain(certificate)\n            if npn_protocols:\n                self.context.set_npn_protocols(npn_protocols)\n            if alpn_protocols:\n                self.context.set_alpn_protocols(alpn_protocols)\n            if ciphers:\n                self.context.set_ciphers(ciphers)\n        self.chatty = chatty\n        self.connectionchatty = connectionchatty\n        self.starttls_server = starttls_server\n        self.sock = socket.socket()\n        self.port = support.bind_port(self.sock)\n        self.flag = None\n        self.active = False\n        self.selected_npn_protocols = []\n        self.selected_alpn_protocols = []\n        self.shared_ciphers = []\n        self.conn_errors = []\n        threading.Thread.__init__(self)\n        self.daemon = True\n\n    def __enter__(self):\n        self.start(threading.Event())\n        self.flag.wait()\n        return self\n\n    def __exit__(self, *args):\n        self.stop()\n        self.join()\n\n    def start(self, flag=None):\n        self.flag = flag\n        threading.Thread.start(self)\n\n    def run(self):\n        self.sock.settimeout(0.05)\n        self.sock.listen()\n        self.active = True\n        if self.flag:\n            # signal an event\n            self.flag.set()\n        while self.active:\n            try:\n                newconn, connaddr = self.sock.accept()\n                if support.verbose and self.chatty:\n                    sys.stdout.write(' server:  new connection from '\n                                     + repr(connaddr) + '\\n')\n                handler = self.ConnectionHandler(self, newconn, connaddr)\n                handler.start()\n                handler.join()\n            except socket.timeout:\n                pass\n            except KeyboardInterrupt:\n                self.stop()\n        self.sock.close()\n\n    def stop(self):\n        self.active = False\n\nclass AsyncoreEchoServer(threading.Thread):\n\n    # this one's based on asyncore.dispatcher\n\n    class EchoServer (asyncore.dispatcher):\n\n        class ConnectionHandler(asyncore.dispatcher_with_send):\n\n            def __init__(self, conn, certfile):\n                self.socket = test_wrap_socket(conn, server_side=True,\n                                              certfile=certfile,\n                                              do_handshake_on_connect=False)\n                asyncore.dispatcher_with_send.__init__(self, self.socket)\n                self._ssl_accepting = True\n                self._do_ssl_handshake()\n\n            def readable(self):\n                if isinstance(self.socket, ssl.SSLSocket):\n                    while self.socket.pending() > 0:\n                        self.handle_read_event()\n                return True\n\n            def _do_ssl_handshake(self):\n                try:\n                    self.socket.do_handshake()\n                except (ssl.SSLWantReadError, ssl.SSLWantWriteError):\n                    return\n                except ssl.SSLEOFError:\n                    return self.handle_close()\n                except ssl.SSLError:\n                    raise\n                except OSError as err:\n                    if err.args[0] == errno.ECONNABORTED:\n                        return self.handle_close()\n                else:\n                    self._ssl_accepting = False\n\n            def handle_read(self):\n                if self._ssl_accepting:\n                    self._do_ssl_handshake()\n                else:\n                    data = self.recv(1024)\n                    if support.verbose:\n                        sys.stdout.write(\" server:  read %s from client\\n\" % repr(data))\n                    if not data:\n                        self.close()\n                    else:\n                        self.send(data.lower())\n\n            def handle_close(self):\n                self.close()\n                if support.verbose:\n                    sys.stdout.write(\" server:  closed connection %s\\n\" % self.socket)\n\n            def handle_error(self):\n                raise\n\n        def __init__(self, certfile):\n            self.certfile = certfile\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.port = support.bind_port(sock, '')\n            asyncore.dispatcher.__init__(self, sock)\n            self.listen(5)\n\n        def handle_accepted(self, sock_obj, addr):\n            if support.verbose:\n                sys.stdout.write(\" server:  new connection from %s:%s\\n\" %addr)\n            self.ConnectionHandler(sock_obj, self.certfile)\n\n        def handle_error(self):\n            raise\n\n    def __init__(self, certfile):\n        self.flag = None\n        self.active = False\n        self.server = self.EchoServer(certfile)\n        self.port = self.server.port\n        threading.Thread.__init__(self)\n        self.daemon = True\n\n    def __str__(self):\n        return \"<%s %s>\" % (self.__class__.__name__, self.server)\n\n    def __enter__(self):\n        self.start(threading.Event())\n        self.flag.wait()\n        return self\n\n    def __exit__(self, *args):\n        if support.verbose:\n            sys.stdout.write(\" cleanup: stopping server.\\n\")\n        self.stop()\n        if support.verbose:\n            sys.stdout.write(\" cleanup: joining server thread.\\n\")\n        self.join()\n        if support.verbose:\n            sys.stdout.write(\" cleanup: successfully joined.\\n\")\n        # make sure that ConnectionHandler is removed from socket_map\n        asyncore.close_all(ignore_all=True)\n\n    def start (self, flag=None):\n        self.flag = flag\n        threading.Thread.start(self)\n\n    def run(self):\n        self.active = True\n        if self.flag:\n            self.flag.set()\n        while self.active:\n            try:\n                asyncore.loop(1)\n            except:\n                pass\n\n    def stop(self):\n        self.active = False\n        self.server.close()\n\ndef server_params_test(client_context, server_context, indata=b\"FOO\\n\",\n                       chatty=True, connectionchatty=False, sni_name=None,\n                       session=None):\n    \"\"\"\n    Launch a server, connect a client to it and try various reads\n    and writes.\n    \"\"\"\n    stats = {}\n    server = ThreadedEchoServer(context=server_context,\n                                chatty=chatty,\n                                connectionchatty=False)\n    with server:\n        with client_context.wrap_socket(socket.socket(),\n                server_hostname=sni_name, session=session) as s:\n            s.connect((HOST, server.port))\n            for arg in [indata, bytearray(indata), memoryview(indata)]:\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  sending %r...\\n\" % indata)\n                s.write(arg)\n                outdata = s.read()\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                if outdata != indata.lower():\n                    raise AssertionError(\n                        \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                        % (outdata[:20], len(outdata),\n                           indata[:20].lower(), len(indata)))\n            s.write(b\"over\\n\")\n            if connectionchatty:\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n            stats.update({\n                'compression': s.compression(),\n                'cipher': s.cipher(),\n                'peercert': s.getpeercert(),\n                'client_alpn_protocol': s.selected_alpn_protocol(),\n                'client_npn_protocol': s.selected_npn_protocol(),\n                'version': s.version(),\n                'session_reused': s.session_reused,\n                'session': s.session,\n            })\n            s.close()\n        stats['server_alpn_protocols'] = server.selected_alpn_protocols\n        stats['server_npn_protocols'] = server.selected_npn_protocols\n        stats['server_shared_ciphers'] = server.shared_ciphers\n    return stats\n\ndef try_protocol_combo(server_protocol, client_protocol, expect_success,\n                       certsreqs=None, server_options=0, client_options=0):\n    \"\"\"\n    Try to SSL-connect using *client_protocol* to *server_protocol*.\n    If *expect_success* is true, assert that the connection succeeds,\n    if it's false, assert that the connection fails.\n    Also, if *expect_success* is a string, assert that it is the protocol\n    version actually used by the connection.\n    \"\"\"\n    if certsreqs is None:\n        certsreqs = ssl.CERT_NONE\n    certtype = {\n        ssl.CERT_NONE: \"CERT_NONE\",\n        ssl.CERT_OPTIONAL: \"CERT_OPTIONAL\",\n        ssl.CERT_REQUIRED: \"CERT_REQUIRED\",\n    }[certsreqs]\n    if support.verbose:\n        formatstr = (expect_success and \" %s->%s %s\\n\") or \" {%s->%s} %s\\n\"\n        sys.stdout.write(formatstr %\n                         (ssl.get_protocol_name(client_protocol),\n                          ssl.get_protocol_name(server_protocol),\n                          certtype))\n    client_context = ssl.SSLContext(client_protocol)\n    client_context.options |= client_options\n    server_context = ssl.SSLContext(server_protocol)\n    server_context.options |= server_options\n\n    # NOTE: we must enable \"ALL\" ciphers on the client, otherwise an\n    # SSLv23 client will send an SSLv3 hello (rather than SSLv2)\n    # starting from OpenSSL 1.0.0 (see issue #8322).\n    if client_context.protocol == ssl.PROTOCOL_TLS:\n        client_context.set_ciphers(\"ALL\")\n\n    for ctx in (client_context, server_context):\n        ctx.verify_mode = certsreqs\n        ctx.load_cert_chain(SIGNED_CERTFILE)\n        ctx.load_verify_locations(SIGNING_CA)\n    try:\n        stats = server_params_test(client_context, server_context,\n                                   chatty=False, connectionchatty=False)\n    # Protocol mismatch can result in either an SSLError, or a\n    # \"Connection reset by peer\" error.\n    except ssl.SSLError:\n        if expect_success:\n            raise\n    except OSError as e:\n        if expect_success or e.errno != errno.ECONNRESET:\n            raise\n    else:\n        if not expect_success:\n            raise AssertionError(\n                \"Client protocol %s succeeded with server protocol %s!\"\n                % (ssl.get_protocol_name(client_protocol),\n                   ssl.get_protocol_name(server_protocol)))\n        elif (expect_success is not True\n              and expect_success != stats['version']):\n            raise AssertionError(\"version mismatch: expected %r, got %r\"\n                                 % (expect_success, stats['version']))\n\n\nclass ThreadedTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_echo(self):\n        \"\"\"Basic test of an SSL client connecting to a server\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        for protocol in PROTOCOLS:\n            if protocol in {ssl.PROTOCOL_TLS_CLIENT, ssl.PROTOCOL_TLS_SERVER}:\n                continue\n            with self.subTest(protocol=ssl._PROTOCOL_NAMES[protocol]):\n                context = ssl.SSLContext(protocol)\n                context.load_cert_chain(CERTFILE)\n                server_params_test(context, context,\n                                   chatty=True, connectionchatty=True)\n\n        client_context, server_context, hostname = testing_context()\n\n        with self.subTest(client=ssl.PROTOCOL_TLS_CLIENT, server=ssl.PROTOCOL_TLS_SERVER):\n            server_params_test(client_context=client_context,\n                               server_context=server_context,\n                               chatty=True, connectionchatty=True,\n                               sni_name=hostname)\n\n        client_context.check_hostname = False\n        with self.subTest(client=ssl.PROTOCOL_TLS_SERVER, server=ssl.PROTOCOL_TLS_CLIENT):\n            with self.assertRaises(ssl.SSLError) as e:\n                server_params_test(client_context=server_context,\n                                   server_context=client_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n            self.assertIn('called a function you should not call',\n                          str(e.exception))\n\n        with self.subTest(client=ssl.PROTOCOL_TLS_SERVER, server=ssl.PROTOCOL_TLS_SERVER):\n            with self.assertRaises(ssl.SSLError) as e:\n                server_params_test(client_context=server_context,\n                                   server_context=server_context,\n                                   chatty=True, connectionchatty=True)\n            self.assertIn('called a function you should not call',\n                          str(e.exception))\n\n        with self.subTest(client=ssl.PROTOCOL_TLS_CLIENT, server=ssl.PROTOCOL_TLS_CLIENT):\n            with self.assertRaises(ssl.SSLError) as e:\n                server_params_test(client_context=server_context,\n                                   server_context=client_context,\n                                   chatty=True, connectionchatty=True)\n            self.assertIn('called a function you should not call',\n                          str(e.exception))\n\n    def test_getpeercert(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        client_context, server_context, hostname = testing_context()\n        server = ThreadedEchoServer(context=server_context, chatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            do_handshake_on_connect=False,\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                # getpeercert() raise ValueError while the handshake isn't\n                # done.\n                with self.assertRaises(ValueError):\n                    s.getpeercert()\n                s.do_handshake()\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()\n                if support.verbose:\n                    sys.stdout.write(pprint.pformat(cert) + '\\n')\n                    sys.stdout.write(\"Connection cipher is \" + str(cipher) + '.\\n')\n                if 'subject' not in cert:\n                    self.fail(\"No subject field in certificate: %s.\" %\n                              pprint.pformat(cert))\n                if ((('organizationName', 'Python Software Foundation'),)\n                    not in cert['subject']):\n                    self.fail(\n                        \"Missing or invalid 'organizationName' field in certificate subject; \"\n                        \"should be 'Python Software Foundation'.\")\n                self.assertIn('notBefore', cert)\n                self.assertIn('notAfter', cert)\n                before = ssl.cert_time_to_seconds(cert['notBefore'])\n                after = ssl.cert_time_to_seconds(cert['notAfter'])\n                self.assertLess(before, after)\n\n    @unittest.skipUnless(have_verify_flags(),\n                        \"verify_flags need OpenSSL > 0.9.8\")\n    def test_crl_check(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        client_context, server_context, hostname = testing_context()\n\n        tf = getattr(ssl, \"VERIFY_X509_TRUSTED_FIRST\", 0)\n        self.assertEqual(client_context.verify_flags, ssl.VERIFY_DEFAULT | tf)\n\n        # VERIFY_DEFAULT should pass\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n\n        # VERIFY_CRL_CHECK_LEAF without a loaded CRL file fails\n        client_context.verify_flags |= ssl.VERIFY_CRL_CHECK_LEAF\n\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                with self.assertRaisesRegex(ssl.SSLError,\n                                            \"certificate verify failed\"):\n                    s.connect((HOST, server.port))\n\n        # now load a CRL file. The CRL file is signed by the CA.\n        client_context.load_verify_locations(CRLFILE)\n\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n\n    def test_check_hostname(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        client_context, server_context, hostname = testing_context()\n\n        # correct hostname should verify\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n\n        # incorrect hostname should raise an exception\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=\"invalid\") as s:\n                with self.assertRaisesRegex(\n                        ssl.CertificateError,\n                        \"Hostname mismatch, certificate is not valid for 'invalid'.\"):\n                    s.connect((HOST, server.port))\n\n        # missing server_hostname arg should cause an exception, too\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with socket.socket() as s:\n                with self.assertRaisesRegex(ValueError,\n                                            \"check_hostname requires server_hostname\"):\n                    client_context.wrap_socket(s)\n\n    def test_ecc_cert(self):\n        client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        client_context.load_verify_locations(SIGNING_CA)\n        client_context.set_ciphers(\n            'TLS13-AES-128-GCM-SHA256:TLS13-CHACHA20-POLY1305-SHA256:'\n            'ECDHE:ECDSA:!NULL:!aRSA'\n        )\n        hostname = SIGNED_CERTFILE_ECC_HOSTNAME\n\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        # load ECC cert\n        server_context.load_cert_chain(SIGNED_CERTFILE_ECC)\n\n        # correct hostname should verify\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()[0].split('-')\n                self.assertTrue(cipher[:2], ('ECDHE', 'ECDSA'))\n\n    def test_dual_rsa_ecc(self):\n        client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        client_context.load_verify_locations(SIGNING_CA)\n        # TODO: fix TLSv1.3 once SSLContext can restrict signature\n        #       algorithms.\n        client_context.options |= ssl.OP_NO_TLSv1_3\n        # only ECDSA certs\n        client_context.set_ciphers('ECDHE:ECDSA:!NULL:!aRSA')\n        hostname = SIGNED_CERTFILE_ECC_HOSTNAME\n\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        # load ECC and RSA key/cert pairs\n        server_context.load_cert_chain(SIGNED_CERTFILE_ECC)\n        server_context.load_cert_chain(SIGNED_CERTFILE)\n\n        # correct hostname should verify\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()[0].split('-')\n                self.assertTrue(cipher[:2], ('ECDHE', 'ECDSA'))\n\n    def test_check_hostname_idn(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        server_context.load_cert_chain(IDNSANSFILE)\n        # TODO: fix TLSv1.3 support\n        server_context.options |= ssl.OP_NO_TLSv1_3\n\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        context.verify_mode = ssl.CERT_REQUIRED\n        context.check_hostname = True\n        context.load_verify_locations(SIGNING_CA)\n\n        # correct hostname should verify, when specified in several\n        # different ways\n        idn_hostnames = [\n            ('k\u00f6nig.idn.pythontest.net',\n             'xn--knig-5qa.idn.pythontest.net'),\n            ('xn--knig-5qa.idn.pythontest.net',\n             'xn--knig-5qa.idn.pythontest.net'),\n            (b'xn--knig-5qa.idn.pythontest.net',\n             'xn--knig-5qa.idn.pythontest.net'),\n\n            ('k\u00f6nigsg\u00e4\u00dfchen.idna2003.pythontest.net',\n             'xn--knigsgsschen-lcb0w.idna2003.pythontest.net'),\n            ('xn--knigsgsschen-lcb0w.idna2003.pythontest.net',\n             'xn--knigsgsschen-lcb0w.idna2003.pythontest.net'),\n            (b'xn--knigsgsschen-lcb0w.idna2003.pythontest.net',\n             'xn--knigsgsschen-lcb0w.idna2003.pythontest.net'),\n\n            # ('k\u00f6nigsg\u00e4\u00dfchen.idna2008.pythontest.net',\n            #  'xn--knigsgchen-b4a3dun.idna2008.pythontest.net'),\n            ('xn--knigsgchen-b4a3dun.idna2008.pythontest.net',\n             'xn--knigsgchen-b4a3dun.idna2008.pythontest.net'),\n            (b'xn--knigsgchen-b4a3dun.idna2008.pythontest.net',\n             'xn--knigsgchen-b4a3dun.idna2008.pythontest.net'),\n\n        ]\n        for server_hostname, expected_hostname in idn_hostnames:\n            server = ThreadedEchoServer(context=server_context, chatty=True)\n            with server:\n                with context.wrap_socket(socket.socket(),\n                                         server_hostname=server_hostname) as s:\n                    self.assertEqual(s.server_hostname, expected_hostname)\n                    s.connect((HOST, server.port))\n                    cert = s.getpeercert()\n                    self.assertEqual(s.server_hostname, expected_hostname)\n                    self.assertTrue(cert, \"Can't get peer certificate.\")\n\n        # incorrect hostname should raise an exception\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with context.wrap_socket(socket.socket(),\n                                     server_hostname=\"python.example.org\") as s:\n                with self.assertRaises(ssl.CertificateError):\n                    s.connect((HOST, server.port))\n\n    def test_wrong_cert(self):\n        \"\"\"Connecting when the server rejects the client's certificate\n\n        Launch a server with CERT_REQUIRED, and check that trying to\n        connect to it with a wrong client certificate fails.\n        \"\"\"\n        client_context, server_context, hostname = testing_context()\n        # load client cert\n        client_context.load_cert_chain(WRONG_CERT)\n        # require TLS client authentication\n        server_context.verify_mode = ssl.CERT_REQUIRED\n        # TODO: fix TLSv1.3 support\n        # With TLS 1.3, test fails with exception in server thread\n        server_context.options |= ssl.OP_NO_TLSv1_3\n\n        server = ThreadedEchoServer(\n            context=server_context, chatty=True, connectionchatty=True,\n        )\n\n        with server, \\\n                client_context.wrap_socket(socket.socket(),\n                                           server_hostname=hostname) as s:\n            try:\n                # Expect either an SSL error about the server rejecting\n                # the connection, or a low-level connection reset (which\n                # sometimes happens on Windows)\n                s.connect((HOST, server.port))\n            except ssl.SSLError as e:\n                if support.verbose:\n                    sys.stdout.write(\"\\nSSLError is %r\\n\" % e)\n            except OSError as e:\n                if e.errno != errno.ECONNRESET:\n                    raise\n                if support.verbose:\n                    sys.stdout.write(\"\\nsocket.error is %r\\n\" % e)\n            else:\n                self.fail(\"Use of invalid cert should have failed!\")\n\n    def test_rude_shutdown(self):\n        \"\"\"A brutal shutdown of an SSL server should raise an OSError\n        in the client when attempting handshake.\n        \"\"\"\n        listener_ready = threading.Event()\n        listener_gone = threading.Event()\n\n        s = socket.socket()\n        port = support.bind_port(s, HOST)\n\n        # `listener` runs in a thread.  It sits in an accept() until\n        # the main thread connects.  Then it rudely closes the socket,\n        # and sets Event `listener_gone` to let the main thread know\n        # the socket is gone.\n        def listener():\n            s.listen()\n            listener_ready.set()\n            newsock, addr = s.accept()\n            newsock.close()\n            s.close()\n            listener_gone.set()\n\n        def connector():\n            listener_ready.wait()\n            with socket.socket() as c:\n                c.connect((HOST, port))\n                listener_gone.wait()\n                try:\n                    ssl_sock = test_wrap_socket(c)\n                except OSError:\n                    pass\n                else:\n                    self.fail('connecting to closed SSL socket should have failed')\n\n        t = threading.Thread(target=listener)\n        t.start()\n        try:\n            connector()\n        finally:\n            t.join()\n\n    def test_ssl_cert_verify_error(self):\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        server_context.load_cert_chain(SIGNED_CERTFILE)\n\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n\n        server = ThreadedEchoServer(context=server_context, chatty=True)\n        with server:\n            with context.wrap_socket(socket.socket(),\n                                     server_hostname=SIGNED_CERTFILE_HOSTNAME) as s:\n                try:\n                    s.connect((HOST, server.port))\n                except ssl.SSLError as e:\n                    msg = 'unable to get local issuer certificate'\n                    self.assertIsInstance(e, ssl.SSLCertVerificationError)\n                    self.assertEqual(e.verify_code, 20)\n                    self.assertEqual(e.verify_message, msg)\n                    self.assertIn(msg, repr(e))\n                    self.assertIn('certificate verify failed', repr(e))\n\n    @skip_if_broken_ubuntu_ssl\n    @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv2'),\n                         \"OpenSSL is compiled without SSLv2 support\")\n    def test_protocol_sslv2(self):\n        \"\"\"Connecting to an SSLv2 server with various client options\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_REQUIRED)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLS, False)\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLSv1, False)\n        # SSLv23 client with specific SSL options\n        if no_sslv2_implies_sslv3_hello():\n            # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLS, False,\n                               client_options=ssl.OP_NO_SSLv2)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_SSLv3)\n        try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_TLSv1)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_PROTOCOL_TLS(self):\n        \"\"\"Connecting to an SSLv23 server with various client options\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try:\n                try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv2, True)\n            except OSError as x:\n                # this fails on some older versions of OpenSSL (0.9.7l, for instance)\n                if support.verbose:\n                    sys.stdout.write(\n                        \" SSL2 client to SSL23 server test unexpectedly failed:\\n %s\\n\"\n                        % str(x))\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS, True)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1, 'TLSv1')\n\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv3, False, ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS, True, ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1, 'TLSv1', ssl.CERT_OPTIONAL)\n\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv3, False, ssl.CERT_REQUIRED)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS, True, ssl.CERT_REQUIRED)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1, 'TLSv1', ssl.CERT_REQUIRED)\n\n        # Server with specific SSL options\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv3, False,\n                           server_options=ssl.OP_NO_SSLv3)\n        # Will choose TLSv1\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLS, True,\n                           server_options=ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1, False,\n                           server_options=ssl.OP_NO_TLSv1)\n\n\n    @skip_if_broken_ubuntu_ssl\n    @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv3'),\n                         \"OpenSSL is compiled without SSLv3 support\")\n    def test_protocol_sslv3(self):\n        \"\"\"Connecting to an SSLv3 server with various client options\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, 'SSLv3')\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, 'SSLv3', ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, 'SSLv3', ssl.CERT_REQUIRED)\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv2, False)\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_SSLv3)\n        try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLSv1, False)\n        if no_sslv2_implies_sslv3_hello():\n            # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLS,\n                               False, client_options=ssl.OP_NO_SSLv2)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol_tlsv1(self):\n        \"\"\"Connecting to a TLSv1 server with various client options\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, 'TLSv1')\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, 'TLSv1', ssl.CERT_OPTIONAL)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, 'TLSv1', ssl.CERT_REQUIRED)\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv2, False)\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_TLSv1)\n\n    @skip_if_broken_ubuntu_ssl\n    @unittest.skipUnless(hasattr(ssl, \"PROTOCOL_TLSv1_1\"),\n                         \"TLS version 1.1 not supported.\")\n    def test_protocol_tlsv1_1(self):\n        \"\"\"Connecting to a TLSv1.1 server with various client options.\n           Testing against older TLS versions.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1_1, 'TLSv1.1')\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv2, False)\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_TLSv1_1)\n\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1_1, 'TLSv1.1')\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1_1, False)\n\n    @skip_if_broken_ubuntu_ssl\n    @unittest.skipUnless(hasattr(ssl, \"PROTOCOL_TLSv1_2\"),\n                         \"TLS version 1.2 not supported.\")\n    def test_protocol_tlsv1_2(self):\n        \"\"\"Connecting to a TLSv1.2 server with various client options.\n           Testing against older TLS versions.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1_2, 'TLSv1.2',\n                           server_options=ssl.OP_NO_SSLv3|ssl.OP_NO_SSLv2,\n                           client_options=ssl.OP_NO_SSLv3|ssl.OP_NO_SSLv2,)\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv2, False)\n        if hasattr(ssl, 'PROTOCOL_SSLv3'):\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv3, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLS, False,\n                           client_options=ssl.OP_NO_TLSv1_2)\n\n        try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1_2, 'TLSv1.2')\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1_2, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1_1, False)\n        try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1_2, False)\n\n    def test_starttls(self):\n        \"\"\"Switching from clear text to encrypted and back again.\"\"\"\n        msgs = (b\"msg 1\", b\"MSG 2\", b\"STARTTLS\", b\"MSG 3\", b\"msg 4\", b\"ENDTLS\", b\"msg 5\", b\"msg 6\")\n\n        server = ThreadedEchoServer(CERTFILE,\n                                    starttls_server=True,\n                                    chatty=True,\n                                    connectionchatty=True)\n        wrapped = False\n        with server:\n            s = socket.socket()\n            s.setblocking(1)\n            s.connect((HOST, server.port))\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            for indata in msgs:\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client:  sending %r...\\n\" % indata)\n                if wrapped:\n                    conn.write(indata)\n                    outdata = conn.read()\n                else:\n                    s.send(indata)\n                    outdata = s.recv(1024)\n                msg = outdata.strip().lower()\n                if indata == b\"STARTTLS\" and msg.startswith(b\"ok\"):\n                    # STARTTLS ok, switch to secure mode\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  read %r from server, starting TLS...\\n\"\n                            % msg)\n                    conn = test_wrap_socket(s)\n                    wrapped = True\n                elif indata == b\"ENDTLS\" and msg.startswith(b\"ok\"):\n                    # ENDTLS ok, switch back to clear text\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  read %r from server, ending TLS...\\n\"\n                            % msg)\n                    s = conn.unwrap()\n                    wrapped = False\n                else:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  read %r from server\\n\" % msg)\n            if support.verbose:\n                sys.stdout.write(\" client:  closing connection.\\n\")\n            if wrapped:\n                conn.write(b\"over\\n\")\n            else:\n                s.send(b\"over\\n\")\n            if wrapped:\n                conn.close()\n            else:\n                s.close()\n\n    def test_socketserver(self):\n        \"\"\"Using socketserver to create and manage SSL connections.\"\"\"\n        server = make_https_server(self, certfile=SIGNED_CERTFILE)\n        # try to connect\n        if support.verbose:\n            sys.stdout.write('\\n')\n        with open(CERTFILE, 'rb') as f:\n            d1 = f.read()\n        d2 = ''\n        # now fetch the same data from the HTTPS server\n        url = 'https://localhost:%d/%s' % (\n            server.port, os.path.split(CERTFILE)[1])\n        context = ssl.create_default_context(cafile=SIGNING_CA)\n        f = urllib.request.urlopen(url, context=context)\n        try:\n            dlen = f.info().get(\"content-length\")\n            if dlen and (int(dlen) > 0):\n                d2 = f.read(int(dlen))\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client: read %d bytes from remote server '%s'\\n\"\n                        % (len(d2), server))\n        finally:\n            f.close()\n        self.assertEqual(d1, d2)\n\n    def test_asyncore_server(self):\n        \"\"\"Check the example asyncore integration.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        indata = b\"FOO\\n\"\n        server = AsyncoreEchoServer(CERTFILE)\n        with server:\n            s = test_wrap_socket(socket.socket())\n            s.connect(('127.0.0.1', server.port))\n            if support.verbose:\n                sys.stdout.write(\n                    \" client:  sending %r...\\n\" % indata)\n            s.write(indata)\n            outdata = s.read()\n            if support.verbose:\n                sys.stdout.write(\" client:  read %r\\n\" % outdata)\n            if outdata != indata.lower():\n                self.fail(\n                    \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                    % (outdata[:20], len(outdata),\n                       indata[:20].lower(), len(indata)))\n            s.write(b\"over\\n\")\n            if support.verbose:\n                sys.stdout.write(\" client:  closing connection.\\n\")\n            s.close()\n            if support.verbose:\n                sys.stdout.write(\" client:  connection closed.\\n\")\n\n    def test_recv_send(self):\n        \"\"\"Test recv(), send() and friends.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLS_SERVER,\n                                    cacerts=CERTFILE,\n                                    chatty=True,\n                                    connectionchatty=False)\n        with server:\n            s = test_wrap_socket(socket.socket(),\n                                server_side=False,\n                                certfile=CERTFILE,\n                                ca_certs=CERTFILE,\n                                cert_reqs=ssl.CERT_NONE,\n                                ssl_version=ssl.PROTOCOL_TLS_CLIENT)\n            s.connect((HOST, server.port))\n            # helper methods for standardising recv* method signatures\n            def _recv_into():\n                b = bytearray(b\"\\0\"*100)\n                count = s.recv_into(b)\n                return b[:count]\n\n            def _recvfrom_into():\n                b = bytearray(b\"\\0\"*100)\n                count, addr = s.recvfrom_into(b)\n                return b[:count]\n\n            # (name, method, expect success?, *args, return value func)\n            send_methods = [\n                ('send', s.send, True, [], len),\n                ('sendto', s.sendto, False, [\"some.address\"], len),\n                ('sendall', s.sendall, True, [], lambda x: None),\n            ]\n            # (name, method, whether to expect success, *args)\n            recv_methods = [\n                ('recv', s.recv, True, []),\n                ('recvfrom', s.recvfrom, False, [\"some.address\"]),\n                ('recv_into', _recv_into, True, []),\n                ('recvfrom_into', _recvfrom_into, False, []),\n            ]\n            data_prefix = \"PREFIX_\"\n\n            for (meth_name, send_meth, expect_success, args,\n                    ret_val_meth) in send_methods:\n                indata = (data_prefix + meth_name).encode('ascii')\n                try:\n                    ret = send_meth(indata, *args)\n                    msg = \"sending with {}\".format(meth_name)\n                    self.assertEqual(ret, ret_val_meth(indata), msg=msg)\n                    outdata = s.read()\n                    if outdata != indata.lower():\n                        self.fail(\n                            \"While sending with <<{name:s}>> bad data \"\n                            \"<<{outdata:r}>> ({nout:d}) received; \"\n                            \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                name=meth_name, outdata=outdata[:20],\n                                nout=len(outdata),\n                                indata=indata[:20], nin=len(indata)\n                            )\n                        )\n                except ValueError as e:\n                    if expect_success:\n                        self.fail(\n                            \"Failed to send with method <<{name:s}>>; \"\n                            \"expected to succeed.\\n\".format(name=meth_name)\n                        )\n                    if not str(e).startswith(meth_name):\n                        self.fail(\n                            \"Method <<{name:s}>> failed with unexpected \"\n                            \"exception message: {exp:s}\\n\".format(\n                                name=meth_name, exp=e\n                            )\n                        )\n\n            for meth_name, recv_meth, expect_success, args in recv_methods:\n                indata = (data_prefix + meth_name).encode('ascii')\n                try:\n                    s.send(indata)\n                    outdata = recv_meth(*args)\n                    if outdata != indata.lower():\n                        self.fail(\n                            \"While receiving with <<{name:s}>> bad data \"\n                            \"<<{outdata:r}>> ({nout:d}) received; \"\n                            \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                name=meth_name, outdata=outdata[:20],\n                                nout=len(outdata),\n                                indata=indata[:20], nin=len(indata)\n                            )\n                        )\n                except ValueError as e:\n                    if expect_success:\n                        self.fail(\n                            \"Failed to receive with method <<{name:s}>>; \"\n                            \"expected to succeed.\\n\".format(name=meth_name)\n                        )\n                    if not str(e).startswith(meth_name):\n                        self.fail(\n                            \"Method <<{name:s}>> failed with unexpected \"\n                            \"exception message: {exp:s}\\n\".format(\n                                name=meth_name, exp=e\n                            )\n                        )\n                    # consume data\n                    s.read()\n\n            # read(-1, buffer) is supported, even though read(-1) is not\n            data = b\"data\"\n            s.send(data)\n            buffer = bytearray(len(data))\n            self.assertEqual(s.read(-1, buffer), len(data))\n            self.assertEqual(buffer, data)\n\n            # sendall accepts bytes-like objects\n            if ctypes is not None:\n                ubyte = ctypes.c_ubyte * len(data)\n                byteslike = ubyte.from_buffer_copy(data)\n                s.sendall(byteslike)\n                self.assertEqual(s.read(), data)\n\n            # Make sure sendmsg et al are disallowed to avoid\n            # inadvertent disclosure of data and/or corruption\n            # of the encrypted data stream\n            self.assertRaises(NotImplementedError, s.sendmsg, [b\"data\"])\n            self.assertRaises(NotImplementedError, s.recvmsg, 100)\n            self.assertRaises(NotImplementedError,\n                              s.recvmsg_into, bytearray(100))\n            s.write(b\"over\\n\")\n\n            self.assertRaises(ValueError, s.recv, -1)\n            self.assertRaises(ValueError, s.read, -1)\n\n            s.close()\n\n    def test_recv_zero(self):\n        server = ThreadedEchoServer(CERTFILE)\n        server.__enter__()\n        self.addCleanup(server.__exit__, None, None)\n        s = socket.create_connection((HOST, server.port))\n        self.addCleanup(s.close)\n        s = test_wrap_socket(s, suppress_ragged_eofs=False)\n        self.addCleanup(s.close)\n\n        # recv/read(0) should return no data\n        s.send(b\"data\")\n        self.assertEqual(s.recv(0), b\"\")\n        self.assertEqual(s.read(0), b\"\")\n        self.assertEqual(s.read(), b\"data\")\n\n        # Should not block if the other end sends no data\n        s.setblocking(False)\n        self.assertEqual(s.recv(0), b\"\")\n        self.assertEqual(s.recv_into(bytearray()), 0)\n\n    def test_nonblocking_send(self):\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLS_SERVER,\n                                    cacerts=CERTFILE,\n                                    chatty=True,\n                                    connectionchatty=False)\n        with server:\n            s = test_wrap_socket(socket.socket(),\n                                server_side=False,\n                                certfile=CERTFILE,\n                                ca_certs=CERTFILE,\n                                cert_reqs=ssl.CERT_NONE,\n                                ssl_version=ssl.PROTOCOL_TLS_CLIENT)\n            s.connect((HOST, server.port))\n            s.setblocking(False)\n\n            # If we keep sending data, at some point the buffers\n            # will be full and the call will block\n            buf = bytearray(8192)\n            def fill_buffer():\n                while True:\n                    s.send(buf)\n            self.assertRaises((ssl.SSLWantWriteError,\n                               ssl.SSLWantReadError), fill_buffer)\n\n            # Now read all the output and discard it\n            s.setblocking(True)\n            s.close()\n\n    def test_handshake_timeout(self):\n        # Issue #5103: SSL handshake must respect the socket timeout\n        server = socket.socket(socket.AF_INET)\n        host = \"127.0.0.1\"\n        port = support.bind_port(server)\n        started = threading.Event()\n        finish = False\n\n        def serve():\n            server.listen()\n            started.set()\n            conns = []\n            while not finish:\n                r, w, e = select.select([server], [], [], 0.1)\n                if server in r:\n                    # Let the socket hang around rather than having\n                    # it closed by garbage collection.\n                    conns.append(server.accept()[0])\n            for sock in conns:\n                sock.close()\n\n        t = threading.Thread(target=serve)\n        t.start()\n        started.wait()\n\n        try:\n            try:\n                c = socket.socket(socket.AF_INET)\n                c.settimeout(0.2)\n                c.connect((host, port))\n                # Will attempt handshake and time out\n                self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                       test_wrap_socket, c)\n            finally:\n                c.close()\n            try:\n                c = socket.socket(socket.AF_INET)\n                c = test_wrap_socket(c)\n                c.settimeout(0.2)\n                # Will attempt handshake and time out\n                self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                       c.connect, (host, port))\n            finally:\n                c.close()\n        finally:\n            finish = True\n            t.join()\n            server.close()\n\n    def test_server_accept(self):\n        # Issue #16357: accept() on a SSLSocket created through\n        # SSLContext.wrap_socket().\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        context.verify_mode = ssl.CERT_REQUIRED\n        context.load_verify_locations(SIGNING_CA)\n        context.load_cert_chain(SIGNED_CERTFILE)\n        server = socket.socket(socket.AF_INET)\n        host = \"127.0.0.1\"\n        port = support.bind_port(server)\n        server = context.wrap_socket(server, server_side=True)\n        self.assertTrue(server.server_side)\n\n        evt = threading.Event()\n        remote = None\n        peer = None\n        def serve():\n            nonlocal remote, peer\n            server.listen()\n            # Block on the accept and wait on the connection to close.\n            evt.set()\n            remote, peer = server.accept()\n            remote.recv(1)\n\n        t = threading.Thread(target=serve)\n        t.start()\n        # Client wait until server setup and perform a connect.\n        evt.wait()\n        client = context.wrap_socket(socket.socket())\n        client.connect((host, port))\n        client_addr = client.getsockname()\n        client.close()\n        t.join()\n        remote.close()\n        server.close()\n        # Sanity checks.\n        self.assertIsInstance(remote, ssl.SSLSocket)\n        self.assertEqual(peer, client_addr)\n\n    def test_getpeercert_enotconn(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        with context.wrap_socket(socket.socket()) as sock:\n            with self.assertRaises(OSError) as cm:\n                sock.getpeercert()\n            self.assertEqual(cm.exception.errno, errno.ENOTCONN)\n\n    def test_do_handshake_enotconn(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        with context.wrap_socket(socket.socket()) as sock:\n            with self.assertRaises(OSError) as cm:\n                sock.do_handshake()\n            self.assertEqual(cm.exception.errno, errno.ENOTCONN)\n\n    def test_default_ciphers(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        try:\n            # Force a set of weak ciphers on our client context\n            context.set_ciphers(\"DES\")\n        except ssl.SSLError:\n            self.skipTest(\"no DES cipher available\")\n        with ThreadedEchoServer(CERTFILE,\n                                ssl_version=ssl.PROTOCOL_TLS,\n                                chatty=False) as server:\n            with context.wrap_socket(socket.socket()) as s:\n                with self.assertRaises(OSError):\n                    s.connect((HOST, server.port))\n        self.assertIn(\"no shared cipher\", server.conn_errors[0])\n\n    def test_version_basic(self):\n        \"\"\"\n        Basic tests for SSLSocket.version().\n        More tests are done in the test_protocol_*() methods.\n        \"\"\"\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        context.check_hostname = False\n        context.verify_mode = ssl.CERT_NONE\n        with ThreadedEchoServer(CERTFILE,\n                                ssl_version=ssl.PROTOCOL_TLS_SERVER,\n                                chatty=False) as server:\n            with context.wrap_socket(socket.socket()) as s:\n                self.assertIs(s.version(), None)\n                self.assertIs(s._sslobj, None)\n                s.connect((HOST, server.port))\n                if ssl.OPENSSL_VERSION_INFO >= (1, 1, 1):\n                    self.assertEqual(s.version(), 'TLSv1.3')\n                elif ssl.OPENSSL_VERSION_INFO >= (1, 0, 2):\n                    self.assertEqual(s.version(), 'TLSv1.2')\n                else:  # 0.9.8 to 1.0.1\n                    self.assertIn(s.version(), ('TLSv1', 'TLSv1.2'))\n            self.assertIs(s._sslobj, None)\n            self.assertIs(s.version(), None)\n\n    @unittest.skipUnless(ssl.HAS_TLSv1_3,\n                         \"test requires TLSv1.3 enabled OpenSSL\")\n    def test_tls1_3(self):\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        context.load_cert_chain(CERTFILE)\n        context.options |= (\n            ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1 | ssl.OP_NO_TLSv1_2\n        )\n        with ThreadedEchoServer(context=context) as server:\n            with context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                self.assertIn(s.cipher()[0], {\n                    'TLS13-AES-256-GCM-SHA384',\n                    'TLS13-CHACHA20-POLY1305-SHA256',\n                    'TLS13-AES-128-GCM-SHA256',\n                })\n                self.assertEqual(s.version(), 'TLSv1.3')\n\n    @unittest.skipUnless(hasattr(ssl.SSLContext, 'minimum_version'),\n                         \"required OpenSSL 1.1.0g\")\n    def test_min_max_version(self):\n        client_context, server_context, hostname = testing_context()\n        # client TLSv1.0 to 1.2\n        client_context.minimum_version = ssl.TLSVersion.TLSv1\n        client_context.maximum_version = ssl.TLSVersion.TLSv1_2\n        # server only TLSv1.2\n        server_context.minimum_version = ssl.TLSVersion.TLSv1_2\n        server_context.maximum_version = ssl.TLSVersion.TLSv1_2\n\n        with ThreadedEchoServer(context=server_context) as server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                self.assertEqual(s.version(), 'TLSv1.2')\n\n        # client 1.0 to 1.2, server 1.0 to 1.1\n        server_context.minimum_version = ssl.TLSVersion.TLSv1\n        server_context.maximum_version = ssl.TLSVersion.TLSv1_1\n\n        with ThreadedEchoServer(context=server_context) as server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                self.assertEqual(s.version(), 'TLSv1.1')\n\n        # client 1.0, server 1.2 (mismatch)\n        server_context.minimum_version = ssl.TLSVersion.TLSv1_2\n        server_context.maximum_version = ssl.TLSVersion.TLSv1_2\n        client_context.minimum_version = ssl.TLSVersion.TLSv1\n        client_context.maximum_version = ssl.TLSVersion.TLSv1\n        with ThreadedEchoServer(context=server_context) as server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                with self.assertRaises(ssl.SSLError) as e:\n                    s.connect((HOST, server.port))\n                self.assertIn(\"alert\", str(e.exception))\n\n\n    @unittest.skipUnless(hasattr(ssl.SSLContext, 'minimum_version'),\n                         \"required OpenSSL 1.1.0g\")\n    @unittest.skipUnless(ssl.HAS_SSLv3, \"requires SSLv3 support\")\n    def test_min_max_version_sslv3(self):\n        client_context, server_context, hostname = testing_context()\n        server_context.minimum_version = ssl.TLSVersion.SSLv3\n        client_context.minimum_version = ssl.TLSVersion.SSLv3\n        client_context.maximum_version = ssl.TLSVersion.SSLv3\n        with ThreadedEchoServer(context=server_context) as server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                self.assertEqual(s.version(), 'SSLv3')\n\n    @unittest.skipUnless(ssl.HAS_ECDH, \"test requires ECDH-enabled OpenSSL\")\n    def test_default_ecdh_curve(self):\n        # Issue #21015: elliptic curve-based Diffie Hellman key exchange\n        # should be enabled by default on SSL contexts.\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        context.load_cert_chain(CERTFILE)\n        # TLSv1.3 defaults to PFS key agreement and no longer has KEA in\n        # cipher name.\n        context.options |= ssl.OP_NO_TLSv1_3\n        # Prior to OpenSSL 1.0.0, ECDH ciphers have to be enabled\n        # explicitly using the 'ECCdraft' cipher alias.  Otherwise,\n        # our default cipher list should prefer ECDH-based ciphers\n        # automatically.\n        if ssl.OPENSSL_VERSION_INFO < (1, 0, 0):\n            context.set_ciphers(\"ECCdraft:ECDH\")\n        with ThreadedEchoServer(context=context) as server:\n            with context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                self.assertIn(\"ECDH\", s.cipher()[0])\n\n    @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                         \"'tls-unique' channel binding not available\")\n    def test_tls_unique_channel_binding(self):\n        \"\"\"Test tls-unique channel binding.\"\"\"\n        if support.verbose:\n            sys.stdout.write(\"\\n\")\n\n        client_context, server_context, hostname = testing_context()\n        # TODO: fix TLSv1.3 support\n        client_context.options |= ssl.OP_NO_TLSv1_3\n\n        server = ThreadedEchoServer(context=server_context,\n                                    chatty=True,\n                                    connectionchatty=False)\n\n        with server:\n            with client_context.wrap_socket(\n                    socket.socket(),\n                    server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                # get the data\n                cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\n                        \" got channel binding data: {0!r}\\n\".format(cb_data))\n\n                # check if it is sane\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n\n                # and compare with the peers version\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(cb_data).encode(\"us-ascii\"))\n\n            # now, again\n            with client_context.wrap_socket(\n                    socket.socket(),\n                    server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                new_cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\n                        \"got another channel binding data: {0!r}\\n\".format(\n                            new_cb_data)\n                    )\n                # is it really unique\n                self.assertNotEqual(cb_data, new_cb_data)\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(new_cb_data).encode(\"us-ascii\"))\n\n    def test_compression(self):\n        client_context, server_context, hostname = testing_context()\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        if support.verbose:\n            sys.stdout.write(\" got compression: {!r}\\n\".format(stats['compression']))\n        self.assertIn(stats['compression'], { None, 'ZLIB', 'RLE' })\n\n    @unittest.skipUnless(hasattr(ssl, 'OP_NO_COMPRESSION'),\n                         \"ssl.OP_NO_COMPRESSION needed for this test\")\n    def test_compression_disabled(self):\n        client_context, server_context, hostname = testing_context()\n        client_context.options |= ssl.OP_NO_COMPRESSION\n        server_context.options |= ssl.OP_NO_COMPRESSION\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        self.assertIs(stats['compression'], None)\n\n    def test_dh_params(self):\n        # Check we can get a connection with ephemeral Diffie-Hellman\n        client_context, server_context, hostname = testing_context()\n        # test scenario needs TLS <= 1.2\n        client_context.options |= ssl.OP_NO_TLSv1_3\n        server_context.load_dh_params(DHFILE)\n        server_context.set_ciphers(\"kEDH\")\n        server_context.options |= ssl.OP_NO_TLSv1_3\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        cipher = stats[\"cipher\"][0]\n        parts = cipher.split(\"-\")\n        if \"ADH\" not in parts and \"EDH\" not in parts and \"DHE\" not in parts:\n            self.fail(\"Non-DH cipher: \" + cipher[0])\n\n    @unittest.skipUnless(HAVE_SECP_CURVES, \"needs secp384r1 curve support\")\n    @unittest.skipIf(IS_OPENSSL_1_1_1, \"TODO: Test doesn't work on 1.1.1\")\n    def test_ecdh_curve(self):\n        # server secp384r1, client auto\n        client_context, server_context, hostname = testing_context()\n\n        server_context.set_ecdh_curve(\"secp384r1\")\n        server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")\n        server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n\n        # server auto, client secp384r1\n        client_context, server_context, hostname = testing_context()\n        client_context.set_ecdh_curve(\"secp384r1\")\n        server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")\n        server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n\n        # server / client curve mismatch\n        client_context, server_context, hostname = testing_context()\n        client_context.set_ecdh_curve(\"prime256v1\")\n        server_context.set_ecdh_curve(\"secp384r1\")\n        server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")\n        server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n        try:\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True, connectionchatty=True,\n                                       sni_name=hostname)\n        except ssl.SSLError:\n            pass\n        else:\n            # OpenSSL 1.0.2 does not fail although it should.\n            if IS_OPENSSL_1_1_0:\n                self.fail(\"mismatch curve did not fail\")\n\n    def test_selected_alpn_protocol(self):\n        # selected_alpn_protocol() is None unless ALPN is used.\n        client_context, server_context, hostname = testing_context()\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        self.assertIs(stats['client_alpn_protocol'], None)\n\n    @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support required\")\n    def test_selected_alpn_protocol_if_server_uses_alpn(self):\n        # selected_alpn_protocol() is None unless ALPN is used by the client.\n        client_context, server_context, hostname = testing_context()\n        server_context.set_alpn_protocols(['foo', 'bar'])\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        self.assertIs(stats['client_alpn_protocol'], None)\n\n    @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support needed for this test\")\n    def test_alpn_protocols(self):\n        server_protocols = ['foo', 'bar', 'milkshake']\n        protocol_tests = [\n            (['foo', 'bar'], 'foo'),\n            (['bar', 'foo'], 'foo'),\n            (['milkshake'], 'milkshake'),\n            (['http/3.0', 'http/4.0'], None)\n        ]\n        for client_protocols, expected in protocol_tests:\n            client_context, server_context, hostname = testing_context()\n            server_context.set_alpn_protocols(server_protocols)\n            client_context.set_alpn_protocols(client_protocols)\n\n            try:\n                stats = server_params_test(client_context,\n                                           server_context,\n                                           chatty=True,\n                                           connectionchatty=True,\n                                           sni_name=hostname)\n            except ssl.SSLError as e:\n                stats = e\n\n            if (expected is None and IS_OPENSSL_1_1_0\n                    and ssl.OPENSSL_VERSION_INFO < (1, 1, 0, 6)):\n                # OpenSSL 1.1.0 to 1.1.0e raises handshake error\n                self.assertIsInstance(stats, ssl.SSLError)\n            else:\n                msg = \"failed trying %s (s) and %s (c).\\n\" \\\n                    \"was expecting %s, but got %%s from the %%s\" \\\n                        % (str(server_protocols), str(client_protocols),\n                            str(expected))\n                client_result = stats['client_alpn_protocol']\n                self.assertEqual(client_result, expected,\n                                 msg % (client_result, \"client\"))\n                server_result = stats['server_alpn_protocols'][-1] \\\n                    if len(stats['server_alpn_protocols']) else 'nothing'\n                self.assertEqual(server_result, expected,\n                                 msg % (server_result, \"server\"))\n\n    def test_selected_npn_protocol(self):\n        # selected_npn_protocol() is None unless NPN is used\n        client_context, server_context, hostname = testing_context()\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True, connectionchatty=True,\n                                   sni_name=hostname)\n        self.assertIs(stats['client_npn_protocol'], None)\n\n    @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")\n    def test_npn_protocols(self):\n        server_protocols = ['http/1.1', 'spdy/2']\n        protocol_tests = [\n            (['http/1.1', 'spdy/2'], 'http/1.1'),\n            (['spdy/2', 'http/1.1'], 'http/1.1'),\n            (['spdy/2', 'test'], 'spdy/2'),\n            (['abc', 'def'], 'abc')\n        ]\n        for client_protocols, expected in protocol_tests:\n            client_context, server_context, hostname = testing_context()\n            server_context.set_npn_protocols(server_protocols)\n            client_context.set_npn_protocols(client_protocols)\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True, connectionchatty=True,\n                                       sni_name=hostname)\n            msg = \"failed trying %s (s) and %s (c).\\n\" \\\n                  \"was expecting %s, but got %%s from the %%s\" \\\n                      % (str(server_protocols), str(client_protocols),\n                         str(expected))\n            client_result = stats['client_npn_protocol']\n            self.assertEqual(client_result, expected, msg % (client_result, \"client\"))\n            server_result = stats['server_npn_protocols'][-1] \\\n                if len(stats['server_npn_protocols']) else 'nothing'\n            self.assertEqual(server_result, expected, msg % (server_result, \"server\"))\n\n    def sni_contexts(self):\n        server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        server_context.load_cert_chain(SIGNED_CERTFILE)\n        other_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n        other_context.load_cert_chain(SIGNED_CERTFILE2)\n        client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n        client_context.load_verify_locations(SIGNING_CA)\n        return server_context, other_context, client_context\n\n    def check_common_name(self, stats, name):\n        cert = stats['peercert']\n        self.assertIn((('commonName', name),), cert['subject'])\n\n    @needs_sni\n    def test_sni_callback(self):\n        calls = []\n        server_context, other_context, client_context = self.sni_contexts()\n\n        client_context.check_hostname = False\n\n        def servername_cb(ssl_sock, server_name, initial_context):\n            calls.append((server_name, initial_context))\n            if server_name is not None:\n                ssl_sock.context = other_context\n        server_context.set_servername_callback(servername_cb)\n\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True,\n                                   sni_name='supermessage')\n        # The hostname was fetched properly, and the certificate was\n        # changed for the connection.\n        self.assertEqual(calls, [(\"supermessage\", server_context)])\n        # CERTFILE4 was selected\n        self.check_common_name(stats, 'fakehostname')\n\n        calls = []\n        # The callback is called with server_name=None\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True,\n                                   sni_name=None)\n        self.assertEqual(calls, [(None, server_context)])\n        self.check_common_name(stats, SIGNED_CERTFILE_HOSTNAME)\n\n        # Check disabling the callback\n        calls = []\n        server_context.set_servername_callback(None)\n\n        stats = server_params_test(client_context, server_context,\n                                   chatty=True,\n                                   sni_name='notfunny')\n        # Certificate didn't change\n        self.check_common_name(stats, SIGNED_CERTFILE_HOSTNAME)\n        self.assertEqual(calls, [])\n\n    @needs_sni\n    def test_sni_callback_alert(self):\n        # Returning a TLS alert is reflected to the connecting client\n        server_context, other_context, client_context = self.sni_contexts()\n\n        def cb_returning_alert(ssl_sock, server_name, initial_context):\n            return ssl.ALERT_DESCRIPTION_ACCESS_DENIED\n        server_context.set_servername_callback(cb_returning_alert)\n        with self.assertRaises(ssl.SSLError) as cm:\n            stats = server_params_test(client_context, server_context,\n                                       chatty=False,\n                                       sni_name='supermessage')\n        self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_ACCESS_DENIED')\n\n    @needs_sni\n    def test_sni_callback_raising(self):\n        # Raising fails the connection with a TLS handshake failure alert.\n        server_context, other_context, client_context = self.sni_contexts()\n\n        def cb_raising(ssl_sock, server_name, initial_context):\n            1/0\n        server_context.set_servername_callback(cb_raising)\n\n        with self.assertRaises(ssl.SSLError) as cm, \\\n             support.captured_stderr() as stderr:\n            stats = server_params_test(client_context, server_context,\n                                       chatty=False,\n                                       sni_name='supermessage')\n        self.assertEqual(cm.exception.reason, 'SSLV3_ALERT_HANDSHAKE_FAILURE')\n        self.assertIn(\"ZeroDivisionError\", stderr.getvalue())\n\n    @needs_sni\n    def test_sni_callback_wrong_return_type(self):\n        # Returning the wrong return type terminates the TLS connection\n        # with an internal error alert.\n        server_context, other_context, client_context = self.sni_contexts()\n\n        def cb_wrong_return_type(ssl_sock, server_name, initial_context):\n            return \"foo\"\n        server_context.set_servername_callback(cb_wrong_return_type)\n\n        with self.assertRaises(ssl.SSLError) as cm, \\\n             support.captured_stderr() as stderr:\n            stats = server_params_test(client_context, server_context,\n                                       chatty=False,\n                                       sni_name='supermessage')\n        self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_INTERNAL_ERROR')\n        self.assertIn(\"TypeError\", stderr.getvalue())\n\n    def test_shared_ciphers(self):\n        client_context, server_context, hostname = testing_context()\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0, 2):\n            client_context.set_ciphers(\"AES128:AES256\")\n            server_context.set_ciphers(\"AES256\")\n            alg1 = \"AES256\"\n            alg2 = \"AES-256\"\n        else:\n            client_context.set_ciphers(\"AES:3DES\")\n            server_context.set_ciphers(\"3DES\")\n            alg1 = \"3DES\"\n            alg2 = \"DES-CBC3\"\n\n        stats = server_params_test(client_context, server_context,\n                                   sni_name=hostname)\n        ciphers = stats['server_shared_ciphers'][0]\n        self.assertGreater(len(ciphers), 0)\n        for name, tls_version, bits in ciphers:\n            if not alg1 in name.split(\"-\") and alg2 not in name:\n                self.fail(name)\n\n    def test_read_write_after_close_raises_valuerror(self):\n        client_context, server_context, hostname = testing_context()\n        server = ThreadedEchoServer(context=server_context, chatty=False)\n\n        with server:\n            s = client_context.wrap_socket(socket.socket(),\n                                           server_hostname=hostname)\n            s.connect((HOST, server.port))\n            s.close()\n\n            self.assertRaises(ValueError, s.read, 1024)\n            self.assertRaises(ValueError, s.write, b'hello')\n\n    def test_sendfile(self):\n        TEST_DATA = b\"x\" * 512\n        with open(support.TESTFN, 'wb') as f:\n            f.write(TEST_DATA)\n        self.addCleanup(support.unlink, support.TESTFN)\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS)\n        context.verify_mode = ssl.CERT_REQUIRED\n        context.load_verify_locations(SIGNING_CA)\n        context.load_cert_chain(SIGNED_CERTFILE)\n        server = ThreadedEchoServer(context=context, chatty=False)\n        with server:\n            with context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                with open(support.TESTFN, 'rb') as file:\n                    s.sendfile(file)\n                    self.assertEqual(s.recv(1024), TEST_DATA)\n\n    def test_session(self):\n        client_context, server_context, hostname = testing_context()\n        # TODO: sessions aren't compatible with TLSv1.3 yet\n        client_context.options |= ssl.OP_NO_TLSv1_3\n\n        # first connection without session\n        stats = server_params_test(client_context, server_context,\n                                   sni_name=hostname)\n        session = stats['session']\n        self.assertTrue(session.id)\n        self.assertGreater(session.time, 0)\n        self.assertGreater(session.timeout, 0)\n        self.assertTrue(session.has_ticket)\n        if ssl.OPENSSL_VERSION_INFO > (1, 0, 1):\n            self.assertGreater(session.ticket_lifetime_hint, 0)\n        self.assertFalse(stats['session_reused'])\n        sess_stat = server_context.session_stats()\n        self.assertEqual(sess_stat['accept'], 1)\n        self.assertEqual(sess_stat['hits'], 0)\n\n        # reuse session\n        stats = server_params_test(client_context, server_context,\n                                   session=session, sni_name=hostname)\n        sess_stat = server_context.session_stats()\n        self.assertEqual(sess_stat['accept'], 2)\n        self.assertEqual(sess_stat['hits'], 1)\n        self.assertTrue(stats['session_reused'])\n        session2 = stats['session']\n        self.assertEqual(session2.id, session.id)\n        self.assertEqual(session2, session)\n        self.assertIsNot(session2, session)\n        self.assertGreaterEqual(session2.time, session.time)\n        self.assertGreaterEqual(session2.timeout, session.timeout)\n\n        # another one without session\n        stats = server_params_test(client_context, server_context,\n                                   sni_name=hostname)\n        self.assertFalse(stats['session_reused'])\n        session3 = stats['session']\n        self.assertNotEqual(session3.id, session.id)\n        self.assertNotEqual(session3, session)\n        sess_stat = server_context.session_stats()\n        self.assertEqual(sess_stat['accept'], 3)\n        self.assertEqual(sess_stat['hits'], 1)\n\n        # reuse session again\n        stats = server_params_test(client_context, server_context,\n                                   session=session, sni_name=hostname)\n        self.assertTrue(stats['session_reused'])\n        session4 = stats['session']\n        self.assertEqual(session4.id, session.id)\n        self.assertEqual(session4, session)\n        self.assertGreaterEqual(session4.time, session.time)\n        self.assertGreaterEqual(session4.timeout, session.timeout)\n        sess_stat = server_context.session_stats()\n        self.assertEqual(sess_stat['accept'], 4)\n        self.assertEqual(sess_stat['hits'], 2)\n\n    def test_session_handling(self):\n        client_context, server_context, hostname = testing_context()\n        client_context2, _, _ = testing_context()\n\n        # TODO: session reuse does not work with TLSv1.3\n        client_context.options |= ssl.OP_NO_TLSv1_3\n        client_context2.options |= ssl.OP_NO_TLSv1_3\n\n        server = ThreadedEchoServer(context=server_context, chatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                # session is None before handshake\n                self.assertEqual(s.session, None)\n                self.assertEqual(s.session_reused, None)\n                s.connect((HOST, server.port))\n                session = s.session\n                self.assertTrue(session)\n                with self.assertRaises(TypeError) as e:\n                    s.session = object\n                self.assertEqual(str(e.exception), 'Value is not a SSLSession.')\n\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                s.connect((HOST, server.port))\n                # cannot set session after handshake\n                with self.assertRaises(ValueError) as e:\n                    s.session = session\n                self.assertEqual(str(e.exception),\n                                 'Cannot set session after handshake.')\n\n            with client_context.wrap_socket(socket.socket(),\n                                            server_hostname=hostname) as s:\n                # can set session before handshake and before the\n                # connection was established\n                s.session = session\n                s.connect((HOST, server.port))\n                self.assertEqual(s.session.id, session.id)\n                self.assertEqual(s.session, session)\n                self.assertEqual(s.session_reused, True)\n\n            with client_context2.wrap_socket(socket.socket(),\n                                             server_hostname=hostname) as s:\n                # cannot re-use session with a different SSLContext\n                with self.assertRaises(ValueError) as e:\n                    s.session = session\n                    s.connect((HOST, server.port))\n                self.assertEqual(str(e.exception),\n                                 'Session refers to a different SSLContext.')\n\n\ndef test_main(verbose=False):\n    if support.verbose:\n        import warnings\n        plats = {\n            'Linux': platform.linux_distribution,\n            'Mac': platform.mac_ver,\n            'Windows': platform.win32_ver,\n        }\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                'ignore',\n                r'dist\\(\\) and linux_distribution\\(\\) '\n                'functions are deprecated .*',\n                PendingDeprecationWarning,\n            )\n            for name, func in plats.items():\n                plat = func()\n                if plat and plat[0]:\n                    plat = '%s %r' % (name, plat)\n                    break\n            else:\n                plat = repr(platform.platform())\n        print(\"test_ssl: testing with %r %r\" %\n            (ssl.OPENSSL_VERSION, ssl.OPENSSL_VERSION_INFO))\n        print(\"          under %s\" % plat)\n        print(\"          HAS_SNI = %r\" % ssl.HAS_SNI)\n        print(\"          OP_ALL = 0x%8x\" % ssl.OP_ALL)\n        try:\n            print(\"          OP_NO_TLSv1_1 = 0x%8x\" % ssl.OP_NO_TLSv1_1)\n        except AttributeError:\n            pass\n\n    for filename in [\n        CERTFILE, BYTES_CERTFILE,\n        ONLYCERT, ONLYKEY, BYTES_ONLYCERT, BYTES_ONLYKEY,\n        SIGNED_CERTFILE, SIGNED_CERTFILE2, SIGNING_CA,\n        BADCERT, BADKEY, EMPTYCERT]:\n        if not os.path.exists(filename):\n            raise support.TestFailed(\"Can't read certificate file %r\" % filename)\n\n    tests = [\n        ContextTests, BasicSocketTests, SSLErrorTests, MemoryBIOTests,\n        SSLObjectTests, SimpleBackgroundTests, ThreadedTests,\n    ]\n\n    if support.is_resource_enabled('network'):\n        tests.append(NetworkedTests)\n\n    thread_info = support.threading_setup()\n    try:\n        support.run_unittest(*tests)\n    finally:\n        support.threading_cleanup(*thread_info)\n\nif __name__ == \"__main__\":\n    test_main()\n"
  },
  {
    "patch": "diff --git a/Lib/test/test_ssl.py b/Lib/test/test_ssl.py\nindex 5c8df8bad86..d90e46dc49f 100644\n--- a/Lib/test/test_ssl.py\n+++ b/Lib/test/test_ssl.py\n@@ -52,6 +52,7 @@\n WRONGCERT = data_file(\"XXXnonexisting.pem\")\n BADKEY = data_file(\"badkey.pem\")\n NOKIACERT = data_file(\"nokia.pem\")\n+NULLBYTECERT = data_file(\"nullbytecert.pem\")\n \n \n def handle_error(prefix):\n@@ -140,6 +141,27 @@ def test_parse_cert(self):\n                           ('DNS', 'projects.forum.nokia.com'))\n                         )\n \n+    def test_parse_cert_CVE_2013_4073(self):\n+        p = ssl._ssl._test_decode_cert(NULLBYTECERT)\n+        if support.verbose:\n+            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n+        subject = ((('countryName', 'US'),),\n+                   (('stateOrProvinceName', 'Oregon'),),\n+                   (('localityName', 'Beaverton'),),\n+                   (('organizationName', 'Python Software Foundation'),),\n+                   (('organizationalUnitName', 'Python Core Development'),),\n+                   (('commonName', 'null.python.org\\x00example.org'),),\n+                   (('emailAddress', 'python-dev@python.org'),))\n+        self.assertEqual(p['subject'], subject)\n+        self.assertEqual(p['issuer'], subject)\n+        self.assertEqual(p['subjectAltName'],\n+                         (('DNS', 'altnull.python.org\\x00example.com'),\n+                         ('email', 'null@python.org\\x00user@example.org'),\n+                         ('URI', 'http://null.python.org\\x00http://example.org'),\n+                         ('IP Address', '192.0.2.1'),\n+                         ('IP Address', '2001:DB8:0:0:0:0:0:1\\n'))\n+                        )\n+\n     def test_DER_to_PEM(self):\n         with open(SVN_PYTHON_ORG_ROOT_CERT, 'r') as f:\n             pem = f.read()\n@@ -271,6 +293,13 @@ def fail(cert, hostname):\n         fail(cert, 'foo.a.com')\n         fail(cert, 'bar.foo.com')\n \n+        # NULL bytes are bad, CVE-2013-4073\n+        cert = {'subject': ((('commonName',\n+                              'null.python.org\\x00example.org'),),)}\n+        ok(cert, 'null.python.org\\x00example.org') # or raise an error?\n+        fail(cert, 'example.org')\n+        fail(cert, 'null.python.org')\n+\n         # Slightly fake real-world example\n         cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                 'subject': ((('commonName', 'linuxfrz.org'),),),\n",
    "commit_message": "Issue #18709: Fix CVE-2013-4238. The SSL module now handles NULL bytes\ninside subjectAltName correctly. Formerly the module has used OpenSSL's\nGENERAL_NAME_print() function to get the string represention of ASN.1\nstrings for ``rfc822Name`` (email), ``dNSName`` (DNS) and\n``uniformResourceIdentifier`` (URI).\n\n",
    "code_before": "# Test the support for SSL and sockets\n\nimport sys\nimport unittest\nfrom test import support\nimport socket\nimport select\nimport time\nimport gc\nimport os\nimport errno\nimport pprint\nimport tempfile\nimport urllib.request\nimport traceback\nimport asyncore\nimport weakref\nimport platform\nimport functools\n\nssl = support.import_module(\"ssl\")\n\nPROTOCOLS = [\n    ssl.PROTOCOL_SSLv3,\n    ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1\n]\nif hasattr(ssl, 'PROTOCOL_SSLv2'):\n    PROTOCOLS.append(ssl.PROTOCOL_SSLv2)\n\nHOST = support.HOST\n\ndata_file = lambda name: os.path.join(os.path.dirname(__file__), name)\n\n# The custom key and certificate files used in test_ssl are generated\n# using Lib/test/make_ssl_certs.py.\n# Other certificates are simply fetched from the Internet servers they\n# are meant to authenticate.\n\nCERTFILE = data_file(\"keycert.pem\")\nBYTES_CERTFILE = os.fsencode(CERTFILE)\nONLYCERT = data_file(\"ssl_cert.pem\")\nONLYKEY = data_file(\"ssl_key.pem\")\nBYTES_ONLYCERT = os.fsencode(ONLYCERT)\nBYTES_ONLYKEY = os.fsencode(ONLYKEY)\nCAPATH = data_file(\"capath\")\nBYTES_CAPATH = os.fsencode(CAPATH)\n\nSVN_PYTHON_ORG_ROOT_CERT = data_file(\"https_svn_python_org_root.pem\")\n\nEMPTYCERT = data_file(\"nullcert.pem\")\nBADCERT = data_file(\"badcert.pem\")\nWRONGCERT = data_file(\"XXXnonexisting.pem\")\nBADKEY = data_file(\"badkey.pem\")\nNOKIACERT = data_file(\"nokia.pem\")\n\n\ndef handle_error(prefix):\n    exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))\n    if support.verbose:\n        sys.stdout.write(prefix + exc_format)\n\ndef can_clear_options():\n    # 0.9.8m or higher\n    return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)\n\ndef no_sslv2_implies_sslv3_hello():\n    # 0.9.7h or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)\n\n\n# Issue #9415: Ubuntu hijacks their OpenSSL and forcefully disables SSLv2\ndef skip_if_broken_ubuntu_ssl(func):\n    if hasattr(ssl, 'PROTOCOL_SSLv2'):\n        @functools.wraps(func)\n        def f(*args, **kwargs):\n            try:\n                ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n            except ssl.SSLError:\n                if (ssl.OPENSSL_VERSION_INFO == (0, 9, 8, 15, 15) and\n                    platform.linux_distribution() == ('debian', 'squeeze/sid', '')):\n                    raise unittest.SkipTest(\"Patched Ubuntu OpenSSL breaks behaviour\")\n            return func(*args, **kwargs)\n        return f\n    else:\n        return func\n\n\nclass BasicSocketTests(unittest.TestCase):\n\n    def test_constants(self):\n        #ssl.PROTOCOL_SSLv2\n        ssl.PROTOCOL_SSLv23\n        ssl.PROTOCOL_SSLv3\n        ssl.PROTOCOL_TLSv1\n        ssl.CERT_NONE\n        ssl.CERT_OPTIONAL\n        ssl.CERT_REQUIRED\n        self.assertIn(ssl.HAS_SNI, {True, False})\n\n    def test_random(self):\n        v = ssl.RAND_status()\n        if support.verbose:\n            sys.stdout.write(\"\\n RAND_status is %d (%s)\\n\"\n                             % (v, (v and \"sufficient randomness\") or\n                                \"insufficient randomness\"))\n        self.assertRaises(TypeError, ssl.RAND_egd, 1)\n        self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)\n        ssl.RAND_add(\"this is a random string\", 75.0)\n\n    def test_parse_cert(self):\n        # note that this uses an 'unofficial' function in _ssl.c,\n        # provided solely for this test, to exercise the certificate\n        # parsing code\n        p = ssl._ssl._test_decode_cert(CERTFILE)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['issuer'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['notAfter'], 'Oct  5 23:01:56 2020 GMT')\n        self.assertEqual(p['notBefore'], 'Oct  8 23:01:56 2010 GMT')\n        self.assertEqual(p['serialNumber'], 'D7C7381919AFC24E')\n        self.assertEqual(p['subject'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['subjectAltName'], (('DNS', 'localhost'),))\n        # Issue #13034: the subjectAltName in some certificates\n        # (notably projects.developer.nokia.com:443) wasn't parsed\n        p = ssl._ssl._test_decode_cert(NOKIACERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'projects.developer.nokia.com'),\n                          ('DNS', 'projects.forum.nokia.com'))\n                        )\n\n    def test_DER_to_PEM(self):\n        with open(SVN_PYTHON_ORG_ROOT_CERT, 'r') as f:\n            pem = f.read()\n        d1 = ssl.PEM_cert_to_DER_cert(pem)\n        p2 = ssl.DER_cert_to_PEM_cert(d1)\n        d2 = ssl.PEM_cert_to_DER_cert(p2)\n        self.assertEqual(d1, d2)\n        if not p2.startswith(ssl.PEM_HEADER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct header:\\n%r\\n\" % p2)\n        if not p2.endswith('\\n' + ssl.PEM_FOOTER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct footer:\\n%r\\n\" % p2)\n\n    def test_openssl_version(self):\n        n = ssl.OPENSSL_VERSION_NUMBER\n        t = ssl.OPENSSL_VERSION_INFO\n        s = ssl.OPENSSL_VERSION\n        self.assertIsInstance(n, int)\n        self.assertIsInstance(t, tuple)\n        self.assertIsInstance(s, str)\n        # Some sanity checks follow\n        # >= 0.9\n        self.assertGreaterEqual(n, 0x900000)\n        # < 2.0\n        self.assertLess(n, 0x20000000)\n        major, minor, fix, patch, status = t\n        self.assertGreaterEqual(major, 0)\n        self.assertLess(major, 2)\n        self.assertGreaterEqual(minor, 0)\n        self.assertLess(minor, 256)\n        self.assertGreaterEqual(fix, 0)\n        self.assertLess(fix, 256)\n        self.assertGreaterEqual(patch, 0)\n        self.assertLessEqual(patch, 26)\n        self.assertGreaterEqual(status, 0)\n        self.assertLessEqual(status, 15)\n        # Version string as returned by OpenSSL, the format might change\n        self.assertTrue(s.startswith(\"OpenSSL {:d}.{:d}.{:d}\".format(major, minor, fix)),\n                        (s, t))\n\n    @support.cpython_only\n    def test_refcycle(self):\n        # Issue #7943: an SSL object doesn't create reference cycles with\n        # itself.\n        s = socket.socket(socket.AF_INET)\n        ss = ssl.wrap_socket(s)\n        wr = weakref.ref(ss)\n        del ss\n        self.assertEqual(wr(), None)\n\n    def test_wrapped_unconnected(self):\n        # Methods on an unconnected SSLSocket propagate the original\n        # socket.error raise by the underlying socket object.\n        s = socket.socket(socket.AF_INET)\n        ss = ssl.wrap_socket(s)\n        self.assertRaises(socket.error, ss.recv, 1)\n        self.assertRaises(socket.error, ss.recv_into, bytearray(b'x'))\n        self.assertRaises(socket.error, ss.recvfrom, 1)\n        self.assertRaises(socket.error, ss.recvfrom_into, bytearray(b'x'), 1)\n        self.assertRaises(socket.error, ss.send, b'x')\n        self.assertRaises(socket.error, ss.sendto, b'x', ('0.0.0.0', 0))\n\n    def test_timeout(self):\n        # Issue #8524: when creating an SSL socket, the timeout of the\n        # original socket should be retained.\n        for timeout in (None, 0.0, 5.0):\n            s = socket.socket(socket.AF_INET)\n            s.settimeout(timeout)\n            ss = ssl.wrap_socket(s)\n            self.assertEqual(timeout, ss.gettimeout())\n\n    def test_errors(self):\n        sock = socket.socket()\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified\",\n                        ssl.wrap_socket, sock, keyfile=CERTFILE)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True, certfile=\"\")\n        s = ssl.wrap_socket(sock, server_side=True, certfile=CERTFILE)\n        self.assertRaisesRegex(ValueError, \"can't connect in server-side mode\",\n                                s.connect, (HOST, 8080))\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=CERTFILE, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n\n    def test_match_hostname(self):\n        def ok(cert, hostname):\n            ssl.match_hostname(cert, hostname)\n        def fail(cert, hostname):\n            self.assertRaises(ssl.CertificateError,\n                              ssl.match_hostname, cert, hostname)\n\n        cert = {'subject': ((('commonName', 'example.com'),),)}\n        ok(cert, 'example.com')\n        ok(cert, 'ExAmple.cOm')\n        fail(cert, 'www.example.com')\n        fail(cert, '.example.com')\n        fail(cert, 'example.org')\n        fail(cert, 'exampleXcom')\n\n        cert = {'subject': ((('commonName', '*.a.com'),),)}\n        ok(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        cert = {'subject': ((('commonName', 'a.*.com'),),)}\n        ok(cert, 'a.foo.com')\n        fail(cert, 'a..com')\n        fail(cert, 'a.com')\n\n        cert = {'subject': ((('commonName', 'f*.com'),),)}\n        ok(cert, 'foo.com')\n        ok(cert, 'f.com')\n        fail(cert, 'bar.com')\n        fail(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.com')\n\n        # Slightly fake real-world example\n        cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                'subject': ((('commonName', 'linuxfrz.org'),),),\n                'subjectAltName': (('DNS', 'linuxfr.org'),\n                                   ('DNS', 'linuxfr.com'),\n                                   ('othername', '<unsupported>'))}\n        ok(cert, 'linuxfr.org')\n        ok(cert, 'linuxfr.com')\n        # Not a \"DNS\" entry\n        fail(cert, '<unsupported>')\n        # When there is a subjectAltName, commonName isn't used\n        fail(cert, 'linuxfrz.org')\n\n        # A pristine real-world example\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),),\n                            (('commonName', 'mail.google.com'),))}\n        ok(cert, 'mail.google.com')\n        fail(cert, 'gmail.com')\n        # Only commonName is considered\n        fail(cert, 'California')\n\n        # Neither commonName nor subjectAltName\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),))}\n        fail(cert, 'mail.google.com')\n\n        # No DNS entry in subjectAltName but a commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('commonName', 'mail.google.com'),)),\n                'subjectAltName': (('othername', 'blabla'), )}\n        ok(cert, 'mail.google.com')\n\n        # No DNS entry subjectAltName and no commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),)),\n                'subjectAltName': (('othername', 'blabla'),)}\n        fail(cert, 'google.com')\n\n        # Empty cert / no cert\n        self.assertRaises(ValueError, ssl.match_hostname, None, 'example.com')\n        self.assertRaises(ValueError, ssl.match_hostname, {}, 'example.com')\n\n        # Issue #17980: avoid denials of service by refusing more than one\n        # wildcard per fragment.\n        cert = {'subject': ((('commonName', 'a*b.com'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b.co*'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b*.com'),),)}\n        with self.assertRaises(ssl.CertificateError) as cm:\n            ssl.match_hostname(cert, 'axxbxxc.com')\n        self.assertIn(\"too many wildcards\", str(cm.exception))\n\n    def test_server_side(self):\n        # server_hostname doesn't work for server sockets\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        with socket.socket() as sock:\n            self.assertRaises(ValueError, ctx.wrap_socket, sock, True,\n                              server_hostname=\"some.hostname\")\n\nclass ContextTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_constructor(self):\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        self.assertRaises(TypeError, ssl.SSLContext)\n        self.assertRaises(ValueError, ssl.SSLContext, -1)\n        self.assertRaises(ValueError, ssl.SSLContext, 42)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.protocol, proto)\n\n    def test_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ciphers(\"ALL\")\n        ctx.set_ciphers(\"DEFAULT\")\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            ctx.set_ciphers(\"^$:,;?*'dorothyx\")\n\n    @skip_if_broken_ubuntu_ssl\n    def test_options(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # OP_ALL is the default value\n        self.assertEqual(ssl.OP_ALL, ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv2\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2,\n                         ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv3\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3,\n                         ctx.options)\n        if can_clear_options():\n            ctx.options = (ctx.options & ~ssl.OP_NO_SSLv2) | ssl.OP_NO_TLSv1\n            self.assertEqual(ssl.OP_ALL | ssl.OP_NO_TLSv1 | ssl.OP_NO_SSLv3,\n                             ctx.options)\n            ctx.options = 0\n            self.assertEqual(0, ctx.options)\n        else:\n            with self.assertRaises(ValueError):\n                ctx.options = 0\n\n    def test_verify(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Default value\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        with self.assertRaises(TypeError):\n            ctx.verify_mode = None\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = 42\n\n    def test_load_cert_chain(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Combined key and cert in a single file\n        ctx.load_cert_chain(CERTFILE)\n        ctx.load_cert_chain(CERTFILE, keyfile=CERTFILE)\n        self.assertRaises(TypeError, ctx.load_cert_chain, keyfile=CERTFILE)\n        with self.assertRaises(IOError) as cm:\n            ctx.load_cert_chain(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(BADCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(EMPTYCERT)\n        # Separate key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY)\n        ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)\n        ctx.load_cert_chain(certfile=BYTES_ONLYCERT, keyfile=BYTES_ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)\n        # Mismatching key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaisesRegex(ssl.SSLError, \"key values mismatch\"):\n            ctx.load_cert_chain(SVN_PYTHON_ORG_ROOT_CERT, ONLYKEY)\n\n    def test_load_verify_locations(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_verify_locations(CERTFILE)\n        ctx.load_verify_locations(cafile=CERTFILE, capath=None)\n        ctx.load_verify_locations(BYTES_CERTFILE)\n        ctx.load_verify_locations(cafile=BYTES_CERTFILE, capath=None)\n        self.assertRaises(TypeError, ctx.load_verify_locations)\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, None)\n        with self.assertRaises(IOError) as cm:\n            ctx.load_verify_locations(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_verify_locations(BADCERT)\n        ctx.load_verify_locations(CERTFILE, CAPATH)\n        ctx.load_verify_locations(CERTFILE, capath=BYTES_CAPATH)\n\n        # Issue #10989: crash if the second argument type is invalid\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, True)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_session_stats(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.session_stats(), {\n                'number': 0,\n                'connect': 0,\n                'connect_good': 0,\n                'connect_renegotiate': 0,\n                'accept': 0,\n                'accept_good': 0,\n                'accept_renegotiate': 0,\n                'hits': 0,\n                'misses': 0,\n                'timeouts': 0,\n                'cache_full': 0,\n            })\n\n    def test_set_default_verify_paths(self):\n        # There's not much we can do to test that it acts as expected,\n        # so just check it doesn't crash or raise an exception.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_default_verify_paths()\n\n\nclass NetworkedTests(unittest.TestCase):\n\n    def test_connect(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n\n            # this should fail because we have no verification certs\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED)\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                   s.connect, (\"svn.python.org\", 443))\n            s.close()\n\n            # this should succeed because we specify the root cert\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_connect_ex(self):\n        # Issue #11326: check connect_ex() implementation\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(0, s.connect_ex((\"svn.python.org\", 443)))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_non_blocking_connect_ex(self):\n        # Issue #11326: non-blocking connect_ex() should allow handshake\n        # to proceed after the socket gets ready.\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.setblocking(False)\n                rc = s.connect_ex(('svn.python.org', 443))\n                # EWOULDBLOCK under Windows, EINPROGRESS elsewhere\n                self.assertIn(rc, (0, errno.EINPROGRESS, errno.EWOULDBLOCK))\n                # Wait for connect to finish\n                select.select([], [s], [], 5.0)\n                # Non-blocking handshake\n                while True:\n                    try:\n                        s.do_handshake()\n                        break\n                    except ssl.SSLError as err:\n                        if err.args[0] == ssl.SSL_ERROR_WANT_READ:\n                            select.select([s], [], [], 5.0)\n                        elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n                            select.select([], [s], [], 5.0)\n                        else:\n                            raise\n                # SSL established\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_timeout_connect_ex(self):\n        # Issue #12065: on a timeout, connect_ex() should return the original\n        # errno (mimicking the behaviour of non-SSL sockets).\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.settimeout(0.0000001)\n                rc = s.connect_ex(('svn.python.org', 443))\n                if rc == 0:\n                    self.skipTest(\"svn.python.org responded too quickly\")\n                self.assertIn(rc, (errno.EAGAIN, errno.EWOULDBLOCK))\n            finally:\n                s.close()\n\n    def test_connect_ex_error(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(errno.ECONNREFUSED,\n                                 s.connect_ex((\"svn.python.org\", 444)))\n            finally:\n                s.close()\n\n    def test_connect_with_context(self):\n        with support.transient_internet(\"svn.python.org\"):\n            # Same as test_connect, but with a separately created context\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n            # Same with a server hostname\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"svn.python.org\")\n            if ssl.HAS_SNI:\n                s.connect((\"svn.python.org\", 443))\n                s.close()\n            else:\n                self.assertRaises(ValueError, s.connect, (\"svn.python.org\", 443))\n            # This should fail because we have no verification certs\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                    s.connect, (\"svn.python.org\", 443))\n            s.close()\n            # This should succeed because we specify the root cert\n            ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    def test_connect_capath(self):\n        # Verify server certificates using the `capath` argument\n        # NOTE: the subject hashing algorithm has been changed between\n        # OpenSSL 0.9.8n and 1.0.0, as a result the capath directory must\n        # contain both versions of each certificate (same content, different\n        # filename) for this test to be portable across OpenSSL releases.\n        with support.transient_internet(\"svn.python.org\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n            # Same with a bytes `capath` argument\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=BYTES_CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    @unittest.skipIf(os.name == \"nt\", \"Can't use a socket as a file under Windows\")\n    def test_makefile_close(self):\n        # Issue #5238: creating a file-like object with makefile() shouldn't\n        # delay closing the underlying \"real socket\" (here tested with its\n        # file descriptor, hence skipping the test under Windows).\n        with support.transient_internet(\"svn.python.org\"):\n            ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n            ss.connect((\"svn.python.org\", 443))\n            fd = ss.fileno()\n            f = ss.makefile()\n            f.close()\n            # The fd is still open\n            os.read(fd, 0)\n            # Closing the SSL socket should close the fd too\n            ss.close()\n            gc.collect()\n            with self.assertRaises(OSError) as e:\n                os.read(fd, 0)\n            self.assertEqual(e.exception.errno, errno.EBADF)\n\n    def test_non_blocking_handshake(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = socket.socket(socket.AF_INET)\n            s.connect((\"svn.python.org\", 443))\n            s.setblocking(False)\n            s = ssl.wrap_socket(s,\n                                cert_reqs=ssl.CERT_NONE,\n                                do_handshake_on_connect=False)\n            count = 0\n            while True:\n                try:\n                    count += 1\n                    s.do_handshake()\n                    break\n                except ssl.SSLError as err:\n                    if err.args[0] == ssl.SSL_ERROR_WANT_READ:\n                        select.select([s], [], [])\n                    elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n                        select.select([], [s], [])\n                    else:\n                        raise\n            s.close()\n            if support.verbose:\n                sys.stdout.write(\"\\nNeeded %d calls to do_handshake() to establish session.\\n\" % count)\n\n    def test_get_server_certificate(self):\n        with support.transient_internet(\"svn.python.org\"):\n            pem = ssl.get_server_certificate((\"svn.python.org\", 443),\n                                             ssl.PROTOCOL_SSLv23)\n            if not pem:\n                self.fail(\"No server certificate on svn.python.org:443!\")\n\n            try:\n                pem = ssl.get_server_certificate((\"svn.python.org\", 443),\n                                                 ssl.PROTOCOL_SSLv23,\n                                                 ca_certs=CERTFILE)\n            except ssl.SSLError as x:\n                #should fail\n                if support.verbose:\n                    sys.stdout.write(\"%s\\n\" % x)\n            else:\n                self.fail(\"Got server certificate %s for svn.python.org!\" % pem)\n\n            pem = ssl.get_server_certificate((\"svn.python.org\", 443),\n                                             ssl.PROTOCOL_SSLv23,\n                                             ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            if not pem:\n                self.fail(\"No server certificate on svn.python.org:443!\")\n            if support.verbose:\n                sys.stdout.write(\"\\nVerified certificate for svn.python.org:443 is\\n%s\\n\" % pem)\n\n    def test_ciphers(self):\n        remote = (\"svn.python.org\", 443)\n        with support.transient_internet(remote[0]):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE, ciphers=\"ALL\")\n            s.connect(remote)\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE, ciphers=\"DEFAULT\")\n            s.connect(remote)\n            # Error checking can happen at instantiation or when connecting\n            with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n                with socket.socket(socket.AF_INET) as sock:\n                    s = ssl.wrap_socket(sock,\n                                        cert_reqs=ssl.CERT_NONE, ciphers=\"^$:,;?*'dorothyx\")\n                    s.connect(remote)\n\n    def test_algorithms(self):\n        # Issue #8484: all algorithms should be available when verifying a\n        # certificate.\n        # SHA256 was added in OpenSSL 0.9.8\n        if ssl.OPENSSL_VERSION_INFO < (0, 9, 8, 0, 15):\n            self.skipTest(\"SHA256 not available on %r\" % ssl.OPENSSL_VERSION)\n        # sha256.tbs-internet.com needs SNI to use the correct certificate\n        if not ssl.HAS_SNI:\n            self.skipTest(\"SNI needed for this test\")\n        # https://sha2.hboeck.de/ was used until 2011-01-08 (no route to host)\n        remote = (\"sha256.tbs-internet.com\", 443)\n        sha256_cert = os.path.join(os.path.dirname(__file__), \"sha256.pem\")\n        with support.transient_internet(\"sha256.tbs-internet.com\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(sha256_cert)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"sha256.tbs-internet.com\")\n            try:\n                s.connect(remote)\n                if support.verbose:\n                    sys.stdout.write(\"\\nCipher with %r is %r\\n\" %\n                                     (remote, s.cipher()))\n                    sys.stdout.write(\"Certificate is:\\n%s\\n\" %\n                                     pprint.pformat(s.getpeercert()))\n            finally:\n                s.close()\n\n\ntry:\n    import threading\nexcept ImportError:\n    _have_threads = False\nelse:\n    _have_threads = True\n\n    from test.ssl_servers import make_https_server\n\n    class ThreadedEchoServer(threading.Thread):\n\n        class ConnectionHandler(threading.Thread):\n\n            \"\"\"A mildly complicated class, because we want it to work both\n            with and without the SSL wrapper around the socket connection, so\n            that we can test the STARTTLS functionality.\"\"\"\n\n            def __init__(self, server, connsock, addr):\n                self.server = server\n                self.running = False\n                self.sock = connsock\n                self.addr = addr\n                self.sock.setblocking(1)\n                self.sslconn = None\n                threading.Thread.__init__(self)\n                self.daemon = True\n\n            def wrap_conn(self):\n                try:\n                    self.sslconn = self.server.context.wrap_socket(\n                        self.sock, server_side=True)\n                except (ssl.SSLError, socket.error) as e:\n                    # Treat ECONNRESET as though it were an SSLError - OpenSSL\n                    # on Ubuntu abruptly closes the connection when asked to use\n                    # an unsupported protocol.\n                    if (not isinstance(e, ssl.SSLError) and\n                        e.errno != errno.ECONNRESET):\n                        raise\n                    # XXX Various errors can have happened here, for example\n                    # a mismatching protocol version, an invalid certificate,\n                    # or a low-level bug. This should be made more discriminating.\n                    self.server.conn_errors.append(e)\n                    if self.server.chatty:\n                        handle_error(\"\\n server:  bad connection attempt from \" + repr(self.addr) + \":\\n\")\n                    self.running = False\n                    self.server.stop()\n                    self.close()\n                    return False\n                else:\n                    if self.server.context.verify_mode == ssl.CERT_REQUIRED:\n                        cert = self.sslconn.getpeercert()\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" client cert is \" + pprint.pformat(cert) + \"\\n\")\n                        cert_binary = self.sslconn.getpeercert(True)\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" cert binary is \" + str(len(cert_binary)) + \" bytes\\n\")\n                    cipher = self.sslconn.cipher()\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" server: connection cipher is now \" + str(cipher) + \"\\n\")\n                    return True\n\n            def read(self):\n                if self.sslconn:\n                    return self.sslconn.read()\n                else:\n                    return self.sock.recv(1024)\n\n            def write(self, bytes):\n                if self.sslconn:\n                    return self.sslconn.write(bytes)\n                else:\n                    return self.sock.send(bytes)\n\n            def close(self):\n                if self.sslconn:\n                    self.sslconn.close()\n                else:\n                    self.sock.close()\n\n            def run(self):\n                self.running = True\n                if not self.server.starttls_server:\n                    if not self.wrap_conn():\n                        return\n                while self.running:\n                    try:\n                        msg = self.read()\n                        stripped = msg.strip()\n                        if not stripped:\n                            # eof, so quit this handler\n                            self.running = False\n                            self.close()\n                        elif stripped == b'over':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: client closed connection\\n\")\n                            self.close()\n                            return\n                        elif (self.server.starttls_server and\n                              stripped == b'STARTTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read STARTTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            if not self.wrap_conn():\n                                return\n                        elif (self.server.starttls_server and self.sslconn\n                              and stripped == b'ENDTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read ENDTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            self.sock = self.sslconn.unwrap()\n                            self.sslconn = None\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: connection is now unencrypted...\\n\")\n                        else:\n                            if (support.verbose and\n                                self.server.connectionchatty):\n                                ctype = (self.sslconn and \"encrypted\") or \"unencrypted\"\n                                sys.stdout.write(\" server: read %r (%s), sending back %r (%s)...\\n\"\n                                                 % (msg, ctype, msg.lower(), ctype))\n                            self.write(msg.lower())\n                    except socket.error:\n                        if self.server.chatty:\n                            handle_error(\"Test server failure:\\n\")\n                        self.close()\n                        self.running = False\n                        # normally, we'd just stop here, but for the test\n                        # harness, we want to stop the server\n                        self.server.stop()\n\n        def __init__(self, certificate=None, ssl_version=None,\n                     certreqs=None, cacerts=None,\n                     chatty=True, connectionchatty=False, starttls_server=False,\n                     ciphers=None, context=None):\n            if context:\n                self.context = context\n            else:\n                self.context = ssl.SSLContext(ssl_version\n                                              if ssl_version is not None\n                                              else ssl.PROTOCOL_TLSv1)\n                self.context.verify_mode = (certreqs if certreqs is not None\n                                            else ssl.CERT_NONE)\n                if cacerts:\n                    self.context.load_verify_locations(cacerts)\n                if certificate:\n                    self.context.load_cert_chain(certificate)\n                if ciphers:\n                    self.context.set_ciphers(ciphers)\n            self.chatty = chatty\n            self.connectionchatty = connectionchatty\n            self.starttls_server = starttls_server\n            self.sock = socket.socket()\n            self.port = support.bind_port(self.sock)\n            self.flag = None\n            self.active = False\n            self.conn_errors = []\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            self.stop()\n            self.join()\n\n        def start(self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.sock.settimeout(0.05)\n            self.sock.listen(5)\n            self.active = True\n            if self.flag:\n                # signal an event\n                self.flag.set()\n            while self.active:\n                try:\n                    newconn, connaddr = self.sock.accept()\n                    if support.verbose and self.chatty:\n                        sys.stdout.write(' server:  new connection from '\n                                         + repr(connaddr) + '\\n')\n                    handler = self.ConnectionHandler(self, newconn, connaddr)\n                    handler.start()\n                    handler.join()\n                except socket.timeout:\n                    pass\n                except KeyboardInterrupt:\n                    self.stop()\n            self.sock.close()\n\n        def stop(self):\n            self.active = False\n\n    class AsyncoreEchoServer(threading.Thread):\n\n        # this one's based on asyncore.dispatcher\n\n        class EchoServer (asyncore.dispatcher):\n\n            class ConnectionHandler (asyncore.dispatcher_with_send):\n\n                def __init__(self, conn, certfile):\n                    self.socket = ssl.wrap_socket(conn, server_side=True,\n                                                  certfile=certfile,\n                                                  do_handshake_on_connect=False)\n                    asyncore.dispatcher_with_send.__init__(self, self.socket)\n                    self._ssl_accepting = True\n                    self._do_ssl_handshake()\n\n                def readable(self):\n                    if isinstance(self.socket, ssl.SSLSocket):\n                        while self.socket.pending() > 0:\n                            self.handle_read_event()\n                    return True\n\n                def _do_ssl_handshake(self):\n                    try:\n                        self.socket.do_handshake()\n                    except ssl.SSLError as err:\n                        if err.args[0] in (ssl.SSL_ERROR_WANT_READ,\n                                           ssl.SSL_ERROR_WANT_WRITE):\n                            return\n                        elif err.args[0] == ssl.SSL_ERROR_EOF:\n                            return self.handle_close()\n                        raise\n                    except socket.error as err:\n                        if err.args[0] == errno.ECONNABORTED:\n                            return self.handle_close()\n                    else:\n                        self._ssl_accepting = False\n\n                def handle_read(self):\n                    if self._ssl_accepting:\n                        self._do_ssl_handshake()\n                    else:\n                        data = self.recv(1024)\n                        if support.verbose:\n                            sys.stdout.write(\" server:  read %s from client\\n\" % repr(data))\n                        if not data:\n                            self.close()\n                        else:\n                            self.send(data.lower())\n\n                def handle_close(self):\n                    self.close()\n                    if support.verbose:\n                        sys.stdout.write(\" server:  closed connection %s\\n\" % self.socket)\n\n                def handle_error(self):\n                    raise\n\n            def __init__(self, certfile):\n                self.certfile = certfile\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.port = support.bind_port(sock, '')\n                asyncore.dispatcher.__init__(self, sock)\n                self.listen(5)\n\n            def handle_accepted(self, sock_obj, addr):\n                if support.verbose:\n                    sys.stdout.write(\" server:  new connection from %s:%s\\n\" %addr)\n                self.ConnectionHandler(sock_obj, self.certfile)\n\n            def handle_error(self):\n                raise\n\n        def __init__(self, certfile):\n            self.flag = None\n            self.active = False\n            self.server = self.EchoServer(certfile)\n            self.port = self.server.port\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __str__(self):\n            return \"<%s %s>\" % (self.__class__.__name__, self.server)\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            if support.verbose:\n                sys.stdout.write(\" cleanup: stopping server.\\n\")\n            self.stop()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: joining server thread.\\n\")\n            self.join()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: successfully joined.\\n\")\n\n        def start (self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.active = True\n            if self.flag:\n                self.flag.set()\n            while self.active:\n                try:\n                    asyncore.loop(1)\n                except:\n                    pass\n\n        def stop(self):\n            self.active = False\n            self.server.close()\n\n    def bad_cert_test(certfile):\n        \"\"\"\n        Launch a server with CERT_REQUIRED, and check that trying to\n        connect to it with the given client certificate fails.\n        \"\"\"\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_REQUIRED,\n                                    cacerts=CERTFILE, chatty=False,\n                                    connectionchatty=False)\n        with server:\n            try:\n                with socket.socket() as sock:\n                    s = ssl.wrap_socket(sock,\n                                        certfile=certfile,\n                                        ssl_version=ssl.PROTOCOL_TLSv1)\n                    s.connect((HOST, server.port))\n            except ssl.SSLError as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nSSLError is %s\\n\" % x.args[1])\n            except socket.error as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nsocket.error is %s\\n\" % x.args[1])\n            except IOError as x:\n                if x.errno != errno.ENOENT:\n                    raise\n                if support.verbose:\n                    sys.stdout.write(\"\\IOError is %s\\n\" % str(x))\n            else:\n                raise AssertionError(\"Use of invalid cert should have failed!\")\n\n    def server_params_test(client_context, server_context, indata=b\"FOO\\n\",\n                           chatty=True, connectionchatty=False):\n        \"\"\"\n        Launch a server, connect a client to it and try various reads\n        and writes.\n        \"\"\"\n        server = ThreadedEchoServer(context=server_context,\n                                    chatty=chatty,\n                                    connectionchatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                for arg in [indata, bytearray(indata), memoryview(indata)]:\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  sending %r...\\n\" % indata)\n                    s.write(arg)\n                    outdata = s.read()\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                    if outdata != indata.lower():\n                        raise AssertionError(\n                            \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                            % (outdata[:20], len(outdata),\n                               indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\" client:  closing connection.\\n\")\n                s.close()\n\n    def try_protocol_combo(server_protocol, client_protocol, expect_success,\n                           certsreqs=None, server_options=0, client_options=0):\n        if certsreqs is None:\n            certsreqs = ssl.CERT_NONE\n        certtype = {\n            ssl.CERT_NONE: \"CERT_NONE\",\n            ssl.CERT_OPTIONAL: \"CERT_OPTIONAL\",\n            ssl.CERT_REQUIRED: \"CERT_REQUIRED\",\n        }[certsreqs]\n        if support.verbose:\n            formatstr = (expect_success and \" %s->%s %s\\n\") or \" {%s->%s} %s\\n\"\n            sys.stdout.write(formatstr %\n                             (ssl.get_protocol_name(client_protocol),\n                              ssl.get_protocol_name(server_protocol),\n                              certtype))\n        client_context = ssl.SSLContext(client_protocol)\n        client_context.options = ssl.OP_ALL | client_options\n        server_context = ssl.SSLContext(server_protocol)\n        server_context.options = ssl.OP_ALL | server_options\n        for ctx in (client_context, server_context):\n            ctx.verify_mode = certsreqs\n            # NOTE: we must enable \"ALL\" ciphers, otherwise an SSLv23 client\n            # will send an SSLv3 hello (rather than SSLv2) starting from\n            # OpenSSL 1.0.0 (see issue #8322).\n            ctx.set_ciphers(\"ALL\")\n            ctx.load_cert_chain(CERTFILE)\n            ctx.load_verify_locations(CERTFILE)\n        try:\n            server_params_test(client_context, server_context,\n                               chatty=False, connectionchatty=False)\n        # Protocol mismatch can result in either an SSLError, or a\n        # \"Connection reset by peer\" error.\n        except ssl.SSLError:\n            if expect_success:\n                raise\n        except socket.error as e:\n            if expect_success or e.errno != errno.ECONNRESET:\n                raise\n        else:\n            if not expect_success:\n                raise AssertionError(\n                    \"Client protocol %s succeeded with server protocol %s!\"\n                    % (ssl.get_protocol_name(client_protocol),\n                       ssl.get_protocol_name(server_protocol)))\n\n\n    class ThreadedTests(unittest.TestCase):\n\n        @skip_if_broken_ubuntu_ssl\n        def test_echo(self):\n            \"\"\"Basic test of an SSL client connecting to a server\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            for protocol in PROTOCOLS:\n                context = ssl.SSLContext(protocol)\n                context.load_cert_chain(CERTFILE)\n                server_params_test(context, context,\n                                   chatty=True, connectionchatty=True)\n\n        def test_getpeercert(self):\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = ThreadedEchoServer(context=context, chatty=False)\n            with server:\n                s = context.wrap_socket(socket.socket())\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()\n                if support.verbose:\n                    sys.stdout.write(pprint.pformat(cert) + '\\n')\n                    sys.stdout.write(\"Connection cipher is \" + str(cipher) + '.\\n')\n                if 'subject' not in cert:\n                    self.fail(\"No subject field in certificate: %s.\" %\n                              pprint.pformat(cert))\n                if ((('organizationName', 'Python Software Foundation'),)\n                    not in cert['subject']):\n                    self.fail(\n                        \"Missing or invalid 'organizationName' field in certificate subject; \"\n                        \"should be 'Python Software Foundation'.\")\n                self.assertIn('notBefore', cert)\n                self.assertIn('notAfter', cert)\n                before = ssl.cert_time_to_seconds(cert['notBefore'])\n                after = ssl.cert_time_to_seconds(cert['notAfter'])\n                self.assertLess(before, after)\n                s.close()\n\n        def test_empty_cert(self):\n            \"\"\"Connecting with an empty cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                      \"nullcert.pem\"))\n        def test_malformed_cert(self):\n            \"\"\"Connecting with a badly formatted certificate (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badcert.pem\"))\n        def test_nonexisting_cert(self):\n            \"\"\"Connecting with a non-existing cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"wrongcert.pem\"))\n        def test_malformed_key(self):\n            \"\"\"Connecting with a badly formatted key (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badkey.pem\"))\n\n        def test_rude_shutdown(self):\n            \"\"\"A brutal shutdown of an SSL server should raise an IOError\n            in the client when attempting handshake.\n            \"\"\"\n            listener_ready = threading.Event()\n            listener_gone = threading.Event()\n\n            s = socket.socket()\n            port = support.bind_port(s, HOST)\n\n            # `listener` runs in a thread.  It sits in an accept() until\n            # the main thread connects.  Then it rudely closes the socket,\n            # and sets Event `listener_gone` to let the main thread know\n            # the socket is gone.\n            def listener():\n                s.listen(5)\n                listener_ready.set()\n                newsock, addr = s.accept()\n                newsock.close()\n                s.close()\n                listener_gone.set()\n\n            def connector():\n                listener_ready.wait()\n                with socket.socket() as c:\n                    c.connect((HOST, port))\n                    listener_gone.wait()\n                    try:\n                        ssl_sock = ssl.wrap_socket(c)\n                    except IOError:\n                        pass\n                    else:\n                        self.fail('connecting to closed SSL socket should have failed')\n\n            t = threading.Thread(target=listener)\n            t.start()\n            try:\n                connector()\n            finally:\n                t.join()\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv2'), \"need SSLv2\")\n        def test_protocol_sslv2(self):\n            \"\"\"Connecting to an SSLv2 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLSv1, False)\n            # SSLv23 client with specific SSL options\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, False,\n                                   client_options=ssl.OP_NO_SSLv2)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv23(self):\n            \"\"\"Connecting to an SSLv23 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try:\n                    try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv2, True)\n                except (ssl.SSLError, socket.error) as x:\n                    # this fails on some older versions of OpenSSL (0.9.7l, for instance)\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" SSL2 client to SSL23 server test unexpectedly failed:\\n %s\\n\"\n                            % str(x))\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n\n            # Server with specific SSL options\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, False,\n                               server_options=ssl.OP_NO_SSLv3)\n            # Will choose TLSv1\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True,\n                               server_options=ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, False,\n                               server_options=ssl.OP_NO_TLSv1)\n\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv3(self):\n            \"\"\"Connecting to an SSLv3 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLSv1, False)\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, True,\n                                   client_options=ssl.OP_NO_SSLv2)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_tlsv1(self):\n            \"\"\"Connecting to a TLSv1 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        def test_starttls(self):\n            \"\"\"Switching from clear text to encrypted and back again.\"\"\"\n            msgs = (b\"msg 1\", b\"MSG 2\", b\"STARTTLS\", b\"MSG 3\", b\"msg 4\", b\"ENDTLS\", b\"msg 5\", b\"msg 6\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        starttls_server=True,\n                                        chatty=True,\n                                        connectionchatty=True)\n            wrapped = False\n            with server:\n                s = socket.socket()\n                s.setblocking(1)\n                s.connect((HOST, server.port))\n                if support.verbose:\n                    sys.stdout.write(\"\\n\")\n                for indata in msgs:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  sending %r...\\n\" % indata)\n                    if wrapped:\n                        conn.write(indata)\n                        outdata = conn.read()\n                    else:\n                        s.send(indata)\n                        outdata = s.recv(1024)\n                    msg = outdata.strip().lower()\n                    if indata == b\"STARTTLS\" and msg.startswith(b\"ok\"):\n                        # STARTTLS ok, switch to secure mode\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, starting TLS...\\n\"\n                                % msg)\n                        conn = ssl.wrap_socket(s, ssl_version=ssl.PROTOCOL_TLSv1)\n                        wrapped = True\n                    elif indata == b\"ENDTLS\" and msg.startswith(b\"ok\"):\n                        # ENDTLS ok, switch back to clear text\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, ending TLS...\\n\"\n                                % msg)\n                        s = conn.unwrap()\n                        wrapped = False\n                    else:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server\\n\" % msg)\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                if wrapped:\n                    conn.write(b\"over\\n\")\n                else:\n                    s.send(b\"over\\n\")\n                if wrapped:\n                    conn.close()\n                else:\n                    s.close()\n\n        def test_socketserver(self):\n            \"\"\"Using a SocketServer to create and manage SSL connections.\"\"\"\n            server = make_https_server(self, CERTFILE)\n            # try to connect\n            if support.verbose:\n                sys.stdout.write('\\n')\n            with open(CERTFILE, 'rb') as f:\n                d1 = f.read()\n            d2 = ''\n            # now fetch the same data from the HTTPS server\n            url = 'https://%s:%d/%s' % (\n                HOST, server.port, os.path.split(CERTFILE)[1])\n            f = urllib.request.urlopen(url)\n            try:\n                dlen = f.info().get(\"content-length\")\n                if dlen and (int(dlen) > 0):\n                    d2 = f.read(int(dlen))\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client: read %d bytes from remote server '%s'\\n\"\n                            % (len(d2), server))\n            finally:\n                f.close()\n            self.assertEqual(d1, d2)\n\n        def test_asyncore_server(self):\n            \"\"\"Check the example asyncore integration.\"\"\"\n            indata = \"TEST MESSAGE of mixed case\\n\"\n\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            indata = b\"FOO\\n\"\n            server = AsyncoreEchoServer(CERTFILE)\n            with server:\n                s = ssl.wrap_socket(socket.socket())\n                s.connect(('127.0.0.1', server.port))\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client:  sending %r...\\n\" % indata)\n                s.write(indata)\n                outdata = s.read()\n                if support.verbose:\n                    sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                if outdata != indata.lower():\n                    self.fail(\n                        \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                        % (outdata[:20], len(outdata),\n                           indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                s.close()\n                if support.verbose:\n                    sys.stdout.write(\" client:  connection closed.\\n\")\n\n        def test_recv_send(self):\n            \"\"\"Test recv(), send() and friends.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # helper methods for standardising recv* method signatures\n                def _recv_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count = s.recv_into(b)\n                    return b[:count]\n\n                def _recvfrom_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count, addr = s.recvfrom_into(b)\n                    return b[:count]\n\n                # (name, method, whether to expect success, *args)\n                send_methods = [\n                    ('send', s.send, True, []),\n                    ('sendto', s.sendto, False, [\"some.address\"]),\n                    ('sendall', s.sendall, True, []),\n                ]\n                recv_methods = [\n                    ('recv', s.recv, True, []),\n                    ('recvfrom', s.recvfrom, False, [\"some.address\"]),\n                    ('recv_into', _recv_into, True, []),\n                    ('recvfrom_into', _recvfrom_into, False, []),\n                ]\n                data_prefix = \"PREFIX_\"\n\n                for meth_name, send_meth, expect_success, args in send_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        send_meth(indata, *args)\n                        outdata = s.read()\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While sending with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to send with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n\n                for meth_name, recv_meth, expect_success, args in recv_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        s.send(indata)\n                        outdata = recv_meth(*args)\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While receiving with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to receive with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n                        # consume data\n                        s.read()\n                s.write(b\"over\\n\")\n                s.close()\n\n        def test_handshake_timeout(self):\n            # Issue #5103: SSL handshake must respect the socket timeout\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            started = threading.Event()\n            finish = False\n\n            def serve():\n                server.listen(5)\n                started.set()\n                conns = []\n                while not finish:\n                    r, w, e = select.select([server], [], [], 0.1)\n                    if server in r:\n                        # Let the socket hang around rather than having\n                        # it closed by garbage collection.\n                        conns.append(server.accept()[0])\n                for sock in conns:\n                    sock.close()\n\n            t = threading.Thread(target=serve)\n            t.start()\n            started.wait()\n\n            try:\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c.settimeout(0.2)\n                    c.connect((host, port))\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           ssl.wrap_socket, c)\n                finally:\n                    c.close()\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c = ssl.wrap_socket(c)\n                    c.settimeout(0.2)\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           c.connect, (host, port))\n                finally:\n                    c.close()\n            finally:\n                finish = True\n                t.join()\n                server.close()\n\n        def test_server_accept(self):\n            # Issue #16357: accept() on a SSLSocket created through\n            # SSLContext.wrap_socket().\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            server = context.wrap_socket(server, server_side=True)\n\n            evt = threading.Event()\n            remote = None\n            peer = None\n            def serve():\n                nonlocal remote, peer\n                server.listen(5)\n                # Block on the accept and wait on the connection to close.\n                evt.set()\n                remote, peer = server.accept()\n                remote.recv(1)\n\n            t = threading.Thread(target=serve)\n            t.start()\n            # Client wait until server setup and perform a connect.\n            evt.wait()\n            client = context.wrap_socket(socket.socket())\n            client.connect((host, port))\n            client_addr = client.getsockname()\n            client.close()\n            t.join()\n            # Sanity checks.\n            self.assertIsInstance(remote, ssl.SSLSocket)\n            self.assertEqual(peer, client_addr)\n\n        def test_default_ciphers(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            try:\n                # Force a set of weak ciphers on our client context\n                context.set_ciphers(\"DES\")\n            except ssl.SSLError:\n                self.skipTest(\"no DES cipher available\")\n            with ThreadedEchoServer(CERTFILE,\n                                    ssl_version=ssl.PROTOCOL_SSLv23,\n                                    chatty=False) as server:\n                with socket.socket() as sock:\n                    s = context.wrap_socket(sock)\n                    with self.assertRaises((OSError, ssl.SSLError)):\n                        s.connect((HOST, server.port))\n            self.assertIn(\"no shared cipher\", str(server.conn_errors[0]))\n\n\ndef test_main(verbose=False):\n    if support.verbose:\n        plats = {\n            'Linux': platform.linux_distribution,\n            'Mac': platform.mac_ver,\n            'Windows': platform.win32_ver,\n        }\n        for name, func in plats.items():\n            plat = func()\n            if plat and plat[0]:\n                plat = '%s %r' % (name, plat)\n                break\n        else:\n            plat = repr(platform.platform())\n        print(\"test_ssl: testing with %r %r\" %\n            (ssl.OPENSSL_VERSION, ssl.OPENSSL_VERSION_INFO))\n        print(\"          under %s\" % plat)\n        print(\"          HAS_SNI = %r\" % ssl.HAS_SNI)\n\n    for filename in [\n        CERTFILE, SVN_PYTHON_ORG_ROOT_CERT, BYTES_CERTFILE,\n        ONLYCERT, ONLYKEY, BYTES_ONLYCERT, BYTES_ONLYKEY,\n        BADCERT, BADKEY, EMPTYCERT]:\n        if not os.path.exists(filename):\n            raise support.TestFailed(\"Can't read certificate file %r\" % filename)\n\n    tests = [ContextTests, BasicSocketTests]\n\n    if support.is_resource_enabled('network'):\n        tests.append(NetworkedTests)\n\n    if _have_threads:\n        thread_info = support.threading_setup()\n        if thread_info and support.is_resource_enabled('network'):\n            tests.append(ThreadedTests)\n\n    try:\n        support.run_unittest(*tests)\n    finally:\n        if _have_threads:\n            support.threading_cleanup(*thread_info)\n\nif __name__ == \"__main__\":\n    test_main()\n",
    "code_after": "# Test the support for SSL and sockets\n\nimport sys\nimport unittest\nfrom test import support\nimport socket\nimport select\nimport time\nimport gc\nimport os\nimport errno\nimport pprint\nimport tempfile\nimport urllib.request\nimport traceback\nimport asyncore\nimport weakref\nimport platform\nimport functools\n\nssl = support.import_module(\"ssl\")\n\nPROTOCOLS = [\n    ssl.PROTOCOL_SSLv3,\n    ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1\n]\nif hasattr(ssl, 'PROTOCOL_SSLv2'):\n    PROTOCOLS.append(ssl.PROTOCOL_SSLv2)\n\nHOST = support.HOST\n\ndata_file = lambda name: os.path.join(os.path.dirname(__file__), name)\n\n# The custom key and certificate files used in test_ssl are generated\n# using Lib/test/make_ssl_certs.py.\n# Other certificates are simply fetched from the Internet servers they\n# are meant to authenticate.\n\nCERTFILE = data_file(\"keycert.pem\")\nBYTES_CERTFILE = os.fsencode(CERTFILE)\nONLYCERT = data_file(\"ssl_cert.pem\")\nONLYKEY = data_file(\"ssl_key.pem\")\nBYTES_ONLYCERT = os.fsencode(ONLYCERT)\nBYTES_ONLYKEY = os.fsencode(ONLYKEY)\nCAPATH = data_file(\"capath\")\nBYTES_CAPATH = os.fsencode(CAPATH)\n\nSVN_PYTHON_ORG_ROOT_CERT = data_file(\"https_svn_python_org_root.pem\")\n\nEMPTYCERT = data_file(\"nullcert.pem\")\nBADCERT = data_file(\"badcert.pem\")\nWRONGCERT = data_file(\"XXXnonexisting.pem\")\nBADKEY = data_file(\"badkey.pem\")\nNOKIACERT = data_file(\"nokia.pem\")\nNULLBYTECERT = data_file(\"nullbytecert.pem\")\n\n\ndef handle_error(prefix):\n    exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))\n    if support.verbose:\n        sys.stdout.write(prefix + exc_format)\n\ndef can_clear_options():\n    # 0.9.8m or higher\n    return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)\n\ndef no_sslv2_implies_sslv3_hello():\n    # 0.9.7h or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)\n\n\n# Issue #9415: Ubuntu hijacks their OpenSSL and forcefully disables SSLv2\ndef skip_if_broken_ubuntu_ssl(func):\n    if hasattr(ssl, 'PROTOCOL_SSLv2'):\n        @functools.wraps(func)\n        def f(*args, **kwargs):\n            try:\n                ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n            except ssl.SSLError:\n                if (ssl.OPENSSL_VERSION_INFO == (0, 9, 8, 15, 15) and\n                    platform.linux_distribution() == ('debian', 'squeeze/sid', '')):\n                    raise unittest.SkipTest(\"Patched Ubuntu OpenSSL breaks behaviour\")\n            return func(*args, **kwargs)\n        return f\n    else:\n        return func\n\n\nclass BasicSocketTests(unittest.TestCase):\n\n    def test_constants(self):\n        #ssl.PROTOCOL_SSLv2\n        ssl.PROTOCOL_SSLv23\n        ssl.PROTOCOL_SSLv3\n        ssl.PROTOCOL_TLSv1\n        ssl.CERT_NONE\n        ssl.CERT_OPTIONAL\n        ssl.CERT_REQUIRED\n        self.assertIn(ssl.HAS_SNI, {True, False})\n\n    def test_random(self):\n        v = ssl.RAND_status()\n        if support.verbose:\n            sys.stdout.write(\"\\n RAND_status is %d (%s)\\n\"\n                             % (v, (v and \"sufficient randomness\") or\n                                \"insufficient randomness\"))\n        self.assertRaises(TypeError, ssl.RAND_egd, 1)\n        self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)\n        ssl.RAND_add(\"this is a random string\", 75.0)\n\n    def test_parse_cert(self):\n        # note that this uses an 'unofficial' function in _ssl.c,\n        # provided solely for this test, to exercise the certificate\n        # parsing code\n        p = ssl._ssl._test_decode_cert(CERTFILE)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['issuer'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['notAfter'], 'Oct  5 23:01:56 2020 GMT')\n        self.assertEqual(p['notBefore'], 'Oct  8 23:01:56 2010 GMT')\n        self.assertEqual(p['serialNumber'], 'D7C7381919AFC24E')\n        self.assertEqual(p['subject'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['subjectAltName'], (('DNS', 'localhost'),))\n        # Issue #13034: the subjectAltName in some certificates\n        # (notably projects.developer.nokia.com:443) wasn't parsed\n        p = ssl._ssl._test_decode_cert(NOKIACERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'projects.developer.nokia.com'),\n                          ('DNS', 'projects.forum.nokia.com'))\n                        )\n\n    def test_parse_cert_CVE_2013_4073(self):\n        p = ssl._ssl._test_decode_cert(NULLBYTECERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        subject = ((('countryName', 'US'),),\n                   (('stateOrProvinceName', 'Oregon'),),\n                   (('localityName', 'Beaverton'),),\n                   (('organizationName', 'Python Software Foundation'),),\n                   (('organizationalUnitName', 'Python Core Development'),),\n                   (('commonName', 'null.python.org\\x00example.org'),),\n                   (('emailAddress', 'python-dev@python.org'),))\n        self.assertEqual(p['subject'], subject)\n        self.assertEqual(p['issuer'], subject)\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'altnull.python.org\\x00example.com'),\n                         ('email', 'null@python.org\\x00user@example.org'),\n                         ('URI', 'http://null.python.org\\x00http://example.org'),\n                         ('IP Address', '192.0.2.1'),\n                         ('IP Address', '2001:DB8:0:0:0:0:0:1\\n'))\n                        )\n\n    def test_DER_to_PEM(self):\n        with open(SVN_PYTHON_ORG_ROOT_CERT, 'r') as f:\n            pem = f.read()\n        d1 = ssl.PEM_cert_to_DER_cert(pem)\n        p2 = ssl.DER_cert_to_PEM_cert(d1)\n        d2 = ssl.PEM_cert_to_DER_cert(p2)\n        self.assertEqual(d1, d2)\n        if not p2.startswith(ssl.PEM_HEADER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct header:\\n%r\\n\" % p2)\n        if not p2.endswith('\\n' + ssl.PEM_FOOTER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct footer:\\n%r\\n\" % p2)\n\n    def test_openssl_version(self):\n        n = ssl.OPENSSL_VERSION_NUMBER\n        t = ssl.OPENSSL_VERSION_INFO\n        s = ssl.OPENSSL_VERSION\n        self.assertIsInstance(n, int)\n        self.assertIsInstance(t, tuple)\n        self.assertIsInstance(s, str)\n        # Some sanity checks follow\n        # >= 0.9\n        self.assertGreaterEqual(n, 0x900000)\n        # < 2.0\n        self.assertLess(n, 0x20000000)\n        major, minor, fix, patch, status = t\n        self.assertGreaterEqual(major, 0)\n        self.assertLess(major, 2)\n        self.assertGreaterEqual(minor, 0)\n        self.assertLess(minor, 256)\n        self.assertGreaterEqual(fix, 0)\n        self.assertLess(fix, 256)\n        self.assertGreaterEqual(patch, 0)\n        self.assertLessEqual(patch, 26)\n        self.assertGreaterEqual(status, 0)\n        self.assertLessEqual(status, 15)\n        # Version string as returned by OpenSSL, the format might change\n        self.assertTrue(s.startswith(\"OpenSSL {:d}.{:d}.{:d}\".format(major, minor, fix)),\n                        (s, t))\n\n    @support.cpython_only\n    def test_refcycle(self):\n        # Issue #7943: an SSL object doesn't create reference cycles with\n        # itself.\n        s = socket.socket(socket.AF_INET)\n        ss = ssl.wrap_socket(s)\n        wr = weakref.ref(ss)\n        del ss\n        self.assertEqual(wr(), None)\n\n    def test_wrapped_unconnected(self):\n        # Methods on an unconnected SSLSocket propagate the original\n        # socket.error raise by the underlying socket object.\n        s = socket.socket(socket.AF_INET)\n        ss = ssl.wrap_socket(s)\n        self.assertRaises(socket.error, ss.recv, 1)\n        self.assertRaises(socket.error, ss.recv_into, bytearray(b'x'))\n        self.assertRaises(socket.error, ss.recvfrom, 1)\n        self.assertRaises(socket.error, ss.recvfrom_into, bytearray(b'x'), 1)\n        self.assertRaises(socket.error, ss.send, b'x')\n        self.assertRaises(socket.error, ss.sendto, b'x', ('0.0.0.0', 0))\n\n    def test_timeout(self):\n        # Issue #8524: when creating an SSL socket, the timeout of the\n        # original socket should be retained.\n        for timeout in (None, 0.0, 5.0):\n            s = socket.socket(socket.AF_INET)\n            s.settimeout(timeout)\n            ss = ssl.wrap_socket(s)\n            self.assertEqual(timeout, ss.gettimeout())\n\n    def test_errors(self):\n        sock = socket.socket()\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified\",\n                        ssl.wrap_socket, sock, keyfile=CERTFILE)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True, certfile=\"\")\n        s = ssl.wrap_socket(sock, server_side=True, certfile=CERTFILE)\n        self.assertRaisesRegex(ValueError, \"can't connect in server-side mode\",\n                                s.connect, (HOST, 8080))\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=CERTFILE, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n\n    def test_match_hostname(self):\n        def ok(cert, hostname):\n            ssl.match_hostname(cert, hostname)\n        def fail(cert, hostname):\n            self.assertRaises(ssl.CertificateError,\n                              ssl.match_hostname, cert, hostname)\n\n        cert = {'subject': ((('commonName', 'example.com'),),)}\n        ok(cert, 'example.com')\n        ok(cert, 'ExAmple.cOm')\n        fail(cert, 'www.example.com')\n        fail(cert, '.example.com')\n        fail(cert, 'example.org')\n        fail(cert, 'exampleXcom')\n\n        cert = {'subject': ((('commonName', '*.a.com'),),)}\n        ok(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        cert = {'subject': ((('commonName', 'a.*.com'),),)}\n        ok(cert, 'a.foo.com')\n        fail(cert, 'a..com')\n        fail(cert, 'a.com')\n\n        cert = {'subject': ((('commonName', 'f*.com'),),)}\n        ok(cert, 'foo.com')\n        ok(cert, 'f.com')\n        fail(cert, 'bar.com')\n        fail(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.com')\n\n        # NULL bytes are bad, CVE-2013-4073\n        cert = {'subject': ((('commonName',\n                              'null.python.org\\x00example.org'),),)}\n        ok(cert, 'null.python.org\\x00example.org') # or raise an error?\n        fail(cert, 'example.org')\n        fail(cert, 'null.python.org')\n\n        # Slightly fake real-world example\n        cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                'subject': ((('commonName', 'linuxfrz.org'),),),\n                'subjectAltName': (('DNS', 'linuxfr.org'),\n                                   ('DNS', 'linuxfr.com'),\n                                   ('othername', '<unsupported>'))}\n        ok(cert, 'linuxfr.org')\n        ok(cert, 'linuxfr.com')\n        # Not a \"DNS\" entry\n        fail(cert, '<unsupported>')\n        # When there is a subjectAltName, commonName isn't used\n        fail(cert, 'linuxfrz.org')\n\n        # A pristine real-world example\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),),\n                            (('commonName', 'mail.google.com'),))}\n        ok(cert, 'mail.google.com')\n        fail(cert, 'gmail.com')\n        # Only commonName is considered\n        fail(cert, 'California')\n\n        # Neither commonName nor subjectAltName\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),))}\n        fail(cert, 'mail.google.com')\n\n        # No DNS entry in subjectAltName but a commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('commonName', 'mail.google.com'),)),\n                'subjectAltName': (('othername', 'blabla'), )}\n        ok(cert, 'mail.google.com')\n\n        # No DNS entry subjectAltName and no commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),)),\n                'subjectAltName': (('othername', 'blabla'),)}\n        fail(cert, 'google.com')\n\n        # Empty cert / no cert\n        self.assertRaises(ValueError, ssl.match_hostname, None, 'example.com')\n        self.assertRaises(ValueError, ssl.match_hostname, {}, 'example.com')\n\n        # Issue #17980: avoid denials of service by refusing more than one\n        # wildcard per fragment.\n        cert = {'subject': ((('commonName', 'a*b.com'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b.co*'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b*.com'),),)}\n        with self.assertRaises(ssl.CertificateError) as cm:\n            ssl.match_hostname(cert, 'axxbxxc.com')\n        self.assertIn(\"too many wildcards\", str(cm.exception))\n\n    def test_server_side(self):\n        # server_hostname doesn't work for server sockets\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        with socket.socket() as sock:\n            self.assertRaises(ValueError, ctx.wrap_socket, sock, True,\n                              server_hostname=\"some.hostname\")\n\nclass ContextTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_constructor(self):\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        self.assertRaises(TypeError, ssl.SSLContext)\n        self.assertRaises(ValueError, ssl.SSLContext, -1)\n        self.assertRaises(ValueError, ssl.SSLContext, 42)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.protocol, proto)\n\n    def test_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ciphers(\"ALL\")\n        ctx.set_ciphers(\"DEFAULT\")\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            ctx.set_ciphers(\"^$:,;?*'dorothyx\")\n\n    @skip_if_broken_ubuntu_ssl\n    def test_options(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # OP_ALL is the default value\n        self.assertEqual(ssl.OP_ALL, ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv2\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2,\n                         ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv3\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3,\n                         ctx.options)\n        if can_clear_options():\n            ctx.options = (ctx.options & ~ssl.OP_NO_SSLv2) | ssl.OP_NO_TLSv1\n            self.assertEqual(ssl.OP_ALL | ssl.OP_NO_TLSv1 | ssl.OP_NO_SSLv3,\n                             ctx.options)\n            ctx.options = 0\n            self.assertEqual(0, ctx.options)\n        else:\n            with self.assertRaises(ValueError):\n                ctx.options = 0\n\n    def test_verify(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Default value\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        with self.assertRaises(TypeError):\n            ctx.verify_mode = None\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = 42\n\n    def test_load_cert_chain(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Combined key and cert in a single file\n        ctx.load_cert_chain(CERTFILE)\n        ctx.load_cert_chain(CERTFILE, keyfile=CERTFILE)\n        self.assertRaises(TypeError, ctx.load_cert_chain, keyfile=CERTFILE)\n        with self.assertRaises(IOError) as cm:\n            ctx.load_cert_chain(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(BADCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(EMPTYCERT)\n        # Separate key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY)\n        ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)\n        ctx.load_cert_chain(certfile=BYTES_ONLYCERT, keyfile=BYTES_ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)\n        # Mismatching key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaisesRegex(ssl.SSLError, \"key values mismatch\"):\n            ctx.load_cert_chain(SVN_PYTHON_ORG_ROOT_CERT, ONLYKEY)\n\n    def test_load_verify_locations(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_verify_locations(CERTFILE)\n        ctx.load_verify_locations(cafile=CERTFILE, capath=None)\n        ctx.load_verify_locations(BYTES_CERTFILE)\n        ctx.load_verify_locations(cafile=BYTES_CERTFILE, capath=None)\n        self.assertRaises(TypeError, ctx.load_verify_locations)\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, None)\n        with self.assertRaises(IOError) as cm:\n            ctx.load_verify_locations(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_verify_locations(BADCERT)\n        ctx.load_verify_locations(CERTFILE, CAPATH)\n        ctx.load_verify_locations(CERTFILE, capath=BYTES_CAPATH)\n\n        # Issue #10989: crash if the second argument type is invalid\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, True)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_session_stats(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.session_stats(), {\n                'number': 0,\n                'connect': 0,\n                'connect_good': 0,\n                'connect_renegotiate': 0,\n                'accept': 0,\n                'accept_good': 0,\n                'accept_renegotiate': 0,\n                'hits': 0,\n                'misses': 0,\n                'timeouts': 0,\n                'cache_full': 0,\n            })\n\n    def test_set_default_verify_paths(self):\n        # There's not much we can do to test that it acts as expected,\n        # so just check it doesn't crash or raise an exception.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_default_verify_paths()\n\n\nclass NetworkedTests(unittest.TestCase):\n\n    def test_connect(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n\n            # this should fail because we have no verification certs\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED)\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                   s.connect, (\"svn.python.org\", 443))\n            s.close()\n\n            # this should succeed because we specify the root cert\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_connect_ex(self):\n        # Issue #11326: check connect_ex() implementation\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(0, s.connect_ex((\"svn.python.org\", 443)))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_non_blocking_connect_ex(self):\n        # Issue #11326: non-blocking connect_ex() should allow handshake\n        # to proceed after the socket gets ready.\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.setblocking(False)\n                rc = s.connect_ex(('svn.python.org', 443))\n                # EWOULDBLOCK under Windows, EINPROGRESS elsewhere\n                self.assertIn(rc, (0, errno.EINPROGRESS, errno.EWOULDBLOCK))\n                # Wait for connect to finish\n                select.select([], [s], [], 5.0)\n                # Non-blocking handshake\n                while True:\n                    try:\n                        s.do_handshake()\n                        break\n                    except ssl.SSLError as err:\n                        if err.args[0] == ssl.SSL_ERROR_WANT_READ:\n                            select.select([s], [], [], 5.0)\n                        elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n                            select.select([], [s], [], 5.0)\n                        else:\n                            raise\n                # SSL established\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_timeout_connect_ex(self):\n        # Issue #12065: on a timeout, connect_ex() should return the original\n        # errno (mimicking the behaviour of non-SSL sockets).\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.settimeout(0.0000001)\n                rc = s.connect_ex(('svn.python.org', 443))\n                if rc == 0:\n                    self.skipTest(\"svn.python.org responded too quickly\")\n                self.assertIn(rc, (errno.EAGAIN, errno.EWOULDBLOCK))\n            finally:\n                s.close()\n\n    def test_connect_ex_error(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(errno.ECONNREFUSED,\n                                 s.connect_ex((\"svn.python.org\", 444)))\n            finally:\n                s.close()\n\n    def test_connect_with_context(self):\n        with support.transient_internet(\"svn.python.org\"):\n            # Same as test_connect, but with a separately created context\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n            # Same with a server hostname\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"svn.python.org\")\n            if ssl.HAS_SNI:\n                s.connect((\"svn.python.org\", 443))\n                s.close()\n            else:\n                self.assertRaises(ValueError, s.connect, (\"svn.python.org\", 443))\n            # This should fail because we have no verification certs\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                    s.connect, (\"svn.python.org\", 443))\n            s.close()\n            # This should succeed because we specify the root cert\n            ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    def test_connect_capath(self):\n        # Verify server certificates using the `capath` argument\n        # NOTE: the subject hashing algorithm has been changed between\n        # OpenSSL 0.9.8n and 1.0.0, as a result the capath directory must\n        # contain both versions of each certificate (same content, different\n        # filename) for this test to be portable across OpenSSL releases.\n        with support.transient_internet(\"svn.python.org\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n            # Same with a bytes `capath` argument\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=BYTES_CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    @unittest.skipIf(os.name == \"nt\", \"Can't use a socket as a file under Windows\")\n    def test_makefile_close(self):\n        # Issue #5238: creating a file-like object with makefile() shouldn't\n        # delay closing the underlying \"real socket\" (here tested with its\n        # file descriptor, hence skipping the test under Windows).\n        with support.transient_internet(\"svn.python.org\"):\n            ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n            ss.connect((\"svn.python.org\", 443))\n            fd = ss.fileno()\n            f = ss.makefile()\n            f.close()\n            # The fd is still open\n            os.read(fd, 0)\n            # Closing the SSL socket should close the fd too\n            ss.close()\n            gc.collect()\n            with self.assertRaises(OSError) as e:\n                os.read(fd, 0)\n            self.assertEqual(e.exception.errno, errno.EBADF)\n\n    def test_non_blocking_handshake(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = socket.socket(socket.AF_INET)\n            s.connect((\"svn.python.org\", 443))\n            s.setblocking(False)\n            s = ssl.wrap_socket(s,\n                                cert_reqs=ssl.CERT_NONE,\n                                do_handshake_on_connect=False)\n            count = 0\n            while True:\n                try:\n                    count += 1\n                    s.do_handshake()\n                    break\n                except ssl.SSLError as err:\n                    if err.args[0] == ssl.SSL_ERROR_WANT_READ:\n                        select.select([s], [], [])\n                    elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n                        select.select([], [s], [])\n                    else:\n                        raise\n            s.close()\n            if support.verbose:\n                sys.stdout.write(\"\\nNeeded %d calls to do_handshake() to establish session.\\n\" % count)\n\n    def test_get_server_certificate(self):\n        with support.transient_internet(\"svn.python.org\"):\n            pem = ssl.get_server_certificate((\"svn.python.org\", 443),\n                                             ssl.PROTOCOL_SSLv23)\n            if not pem:\n                self.fail(\"No server certificate on svn.python.org:443!\")\n\n            try:\n                pem = ssl.get_server_certificate((\"svn.python.org\", 443),\n                                                 ssl.PROTOCOL_SSLv23,\n                                                 ca_certs=CERTFILE)\n            except ssl.SSLError as x:\n                #should fail\n                if support.verbose:\n                    sys.stdout.write(\"%s\\n\" % x)\n            else:\n                self.fail(\"Got server certificate %s for svn.python.org!\" % pem)\n\n            pem = ssl.get_server_certificate((\"svn.python.org\", 443),\n                                             ssl.PROTOCOL_SSLv23,\n                                             ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            if not pem:\n                self.fail(\"No server certificate on svn.python.org:443!\")\n            if support.verbose:\n                sys.stdout.write(\"\\nVerified certificate for svn.python.org:443 is\\n%s\\n\" % pem)\n\n    def test_ciphers(self):\n        remote = (\"svn.python.org\", 443)\n        with support.transient_internet(remote[0]):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE, ciphers=\"ALL\")\n            s.connect(remote)\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE, ciphers=\"DEFAULT\")\n            s.connect(remote)\n            # Error checking can happen at instantiation or when connecting\n            with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n                with socket.socket(socket.AF_INET) as sock:\n                    s = ssl.wrap_socket(sock,\n                                        cert_reqs=ssl.CERT_NONE, ciphers=\"^$:,;?*'dorothyx\")\n                    s.connect(remote)\n\n    def test_algorithms(self):\n        # Issue #8484: all algorithms should be available when verifying a\n        # certificate.\n        # SHA256 was added in OpenSSL 0.9.8\n        if ssl.OPENSSL_VERSION_INFO < (0, 9, 8, 0, 15):\n            self.skipTest(\"SHA256 not available on %r\" % ssl.OPENSSL_VERSION)\n        # sha256.tbs-internet.com needs SNI to use the correct certificate\n        if not ssl.HAS_SNI:\n            self.skipTest(\"SNI needed for this test\")\n        # https://sha2.hboeck.de/ was used until 2011-01-08 (no route to host)\n        remote = (\"sha256.tbs-internet.com\", 443)\n        sha256_cert = os.path.join(os.path.dirname(__file__), \"sha256.pem\")\n        with support.transient_internet(\"sha256.tbs-internet.com\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(sha256_cert)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"sha256.tbs-internet.com\")\n            try:\n                s.connect(remote)\n                if support.verbose:\n                    sys.stdout.write(\"\\nCipher with %r is %r\\n\" %\n                                     (remote, s.cipher()))\n                    sys.stdout.write(\"Certificate is:\\n%s\\n\" %\n                                     pprint.pformat(s.getpeercert()))\n            finally:\n                s.close()\n\n\ntry:\n    import threading\nexcept ImportError:\n    _have_threads = False\nelse:\n    _have_threads = True\n\n    from test.ssl_servers import make_https_server\n\n    class ThreadedEchoServer(threading.Thread):\n\n        class ConnectionHandler(threading.Thread):\n\n            \"\"\"A mildly complicated class, because we want it to work both\n            with and without the SSL wrapper around the socket connection, so\n            that we can test the STARTTLS functionality.\"\"\"\n\n            def __init__(self, server, connsock, addr):\n                self.server = server\n                self.running = False\n                self.sock = connsock\n                self.addr = addr\n                self.sock.setblocking(1)\n                self.sslconn = None\n                threading.Thread.__init__(self)\n                self.daemon = True\n\n            def wrap_conn(self):\n                try:\n                    self.sslconn = self.server.context.wrap_socket(\n                        self.sock, server_side=True)\n                except (ssl.SSLError, socket.error) as e:\n                    # Treat ECONNRESET as though it were an SSLError - OpenSSL\n                    # on Ubuntu abruptly closes the connection when asked to use\n                    # an unsupported protocol.\n                    if (not isinstance(e, ssl.SSLError) and\n                        e.errno != errno.ECONNRESET):\n                        raise\n                    # XXX Various errors can have happened here, for example\n                    # a mismatching protocol version, an invalid certificate,\n                    # or a low-level bug. This should be made more discriminating.\n                    self.server.conn_errors.append(e)\n                    if self.server.chatty:\n                        handle_error(\"\\n server:  bad connection attempt from \" + repr(self.addr) + \":\\n\")\n                    self.running = False\n                    self.server.stop()\n                    self.close()\n                    return False\n                else:\n                    if self.server.context.verify_mode == ssl.CERT_REQUIRED:\n                        cert = self.sslconn.getpeercert()\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" client cert is \" + pprint.pformat(cert) + \"\\n\")\n                        cert_binary = self.sslconn.getpeercert(True)\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" cert binary is \" + str(len(cert_binary)) + \" bytes\\n\")\n                    cipher = self.sslconn.cipher()\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" server: connection cipher is now \" + str(cipher) + \"\\n\")\n                    return True\n\n            def read(self):\n                if self.sslconn:\n                    return self.sslconn.read()\n                else:\n                    return self.sock.recv(1024)\n\n            def write(self, bytes):\n                if self.sslconn:\n                    return self.sslconn.write(bytes)\n                else:\n                    return self.sock.send(bytes)\n\n            def close(self):\n                if self.sslconn:\n                    self.sslconn.close()\n                else:\n                    self.sock.close()\n\n            def run(self):\n                self.running = True\n                if not self.server.starttls_server:\n                    if not self.wrap_conn():\n                        return\n                while self.running:\n                    try:\n                        msg = self.read()\n                        stripped = msg.strip()\n                        if not stripped:\n                            # eof, so quit this handler\n                            self.running = False\n                            self.close()\n                        elif stripped == b'over':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: client closed connection\\n\")\n                            self.close()\n                            return\n                        elif (self.server.starttls_server and\n                              stripped == b'STARTTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read STARTTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            if not self.wrap_conn():\n                                return\n                        elif (self.server.starttls_server and self.sslconn\n                              and stripped == b'ENDTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read ENDTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            self.sock = self.sslconn.unwrap()\n                            self.sslconn = None\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: connection is now unencrypted...\\n\")\n                        else:\n                            if (support.verbose and\n                                self.server.connectionchatty):\n                                ctype = (self.sslconn and \"encrypted\") or \"unencrypted\"\n                                sys.stdout.write(\" server: read %r (%s), sending back %r (%s)...\\n\"\n                                                 % (msg, ctype, msg.lower(), ctype))\n                            self.write(msg.lower())\n                    except socket.error:\n                        if self.server.chatty:\n                            handle_error(\"Test server failure:\\n\")\n                        self.close()\n                        self.running = False\n                        # normally, we'd just stop here, but for the test\n                        # harness, we want to stop the server\n                        self.server.stop()\n\n        def __init__(self, certificate=None, ssl_version=None,\n                     certreqs=None, cacerts=None,\n                     chatty=True, connectionchatty=False, starttls_server=False,\n                     ciphers=None, context=None):\n            if context:\n                self.context = context\n            else:\n                self.context = ssl.SSLContext(ssl_version\n                                              if ssl_version is not None\n                                              else ssl.PROTOCOL_TLSv1)\n                self.context.verify_mode = (certreqs if certreqs is not None\n                                            else ssl.CERT_NONE)\n                if cacerts:\n                    self.context.load_verify_locations(cacerts)\n                if certificate:\n                    self.context.load_cert_chain(certificate)\n                if ciphers:\n                    self.context.set_ciphers(ciphers)\n            self.chatty = chatty\n            self.connectionchatty = connectionchatty\n            self.starttls_server = starttls_server\n            self.sock = socket.socket()\n            self.port = support.bind_port(self.sock)\n            self.flag = None\n            self.active = False\n            self.conn_errors = []\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            self.stop()\n            self.join()\n\n        def start(self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.sock.settimeout(0.05)\n            self.sock.listen(5)\n            self.active = True\n            if self.flag:\n                # signal an event\n                self.flag.set()\n            while self.active:\n                try:\n                    newconn, connaddr = self.sock.accept()\n                    if support.verbose and self.chatty:\n                        sys.stdout.write(' server:  new connection from '\n                                         + repr(connaddr) + '\\n')\n                    handler = self.ConnectionHandler(self, newconn, connaddr)\n                    handler.start()\n                    handler.join()\n                except socket.timeout:\n                    pass\n                except KeyboardInterrupt:\n                    self.stop()\n            self.sock.close()\n\n        def stop(self):\n            self.active = False\n\n    class AsyncoreEchoServer(threading.Thread):\n\n        # this one's based on asyncore.dispatcher\n\n        class EchoServer (asyncore.dispatcher):\n\n            class ConnectionHandler (asyncore.dispatcher_with_send):\n\n                def __init__(self, conn, certfile):\n                    self.socket = ssl.wrap_socket(conn, server_side=True,\n                                                  certfile=certfile,\n                                                  do_handshake_on_connect=False)\n                    asyncore.dispatcher_with_send.__init__(self, self.socket)\n                    self._ssl_accepting = True\n                    self._do_ssl_handshake()\n\n                def readable(self):\n                    if isinstance(self.socket, ssl.SSLSocket):\n                        while self.socket.pending() > 0:\n                            self.handle_read_event()\n                    return True\n\n                def _do_ssl_handshake(self):\n                    try:\n                        self.socket.do_handshake()\n                    except ssl.SSLError as err:\n                        if err.args[0] in (ssl.SSL_ERROR_WANT_READ,\n                                           ssl.SSL_ERROR_WANT_WRITE):\n                            return\n                        elif err.args[0] == ssl.SSL_ERROR_EOF:\n                            return self.handle_close()\n                        raise\n                    except socket.error as err:\n                        if err.args[0] == errno.ECONNABORTED:\n                            return self.handle_close()\n                    else:\n                        self._ssl_accepting = False\n\n                def handle_read(self):\n                    if self._ssl_accepting:\n                        self._do_ssl_handshake()\n                    else:\n                        data = self.recv(1024)\n                        if support.verbose:\n                            sys.stdout.write(\" server:  read %s from client\\n\" % repr(data))\n                        if not data:\n                            self.close()\n                        else:\n                            self.send(data.lower())\n\n                def handle_close(self):\n                    self.close()\n                    if support.verbose:\n                        sys.stdout.write(\" server:  closed connection %s\\n\" % self.socket)\n\n                def handle_error(self):\n                    raise\n\n            def __init__(self, certfile):\n                self.certfile = certfile\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.port = support.bind_port(sock, '')\n                asyncore.dispatcher.__init__(self, sock)\n                self.listen(5)\n\n            def handle_accepted(self, sock_obj, addr):\n                if support.verbose:\n                    sys.stdout.write(\" server:  new connection from %s:%s\\n\" %addr)\n                self.ConnectionHandler(sock_obj, self.certfile)\n\n            def handle_error(self):\n                raise\n\n        def __init__(self, certfile):\n            self.flag = None\n            self.active = False\n            self.server = self.EchoServer(certfile)\n            self.port = self.server.port\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __str__(self):\n            return \"<%s %s>\" % (self.__class__.__name__, self.server)\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            if support.verbose:\n                sys.stdout.write(\" cleanup: stopping server.\\n\")\n            self.stop()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: joining server thread.\\n\")\n            self.join()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: successfully joined.\\n\")\n\n        def start (self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.active = True\n            if self.flag:\n                self.flag.set()\n            while self.active:\n                try:\n                    asyncore.loop(1)\n                except:\n                    pass\n\n        def stop(self):\n            self.active = False\n            self.server.close()\n\n    def bad_cert_test(certfile):\n        \"\"\"\n        Launch a server with CERT_REQUIRED, and check that trying to\n        connect to it with the given client certificate fails.\n        \"\"\"\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_REQUIRED,\n                                    cacerts=CERTFILE, chatty=False,\n                                    connectionchatty=False)\n        with server:\n            try:\n                with socket.socket() as sock:\n                    s = ssl.wrap_socket(sock,\n                                        certfile=certfile,\n                                        ssl_version=ssl.PROTOCOL_TLSv1)\n                    s.connect((HOST, server.port))\n            except ssl.SSLError as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nSSLError is %s\\n\" % x.args[1])\n            except socket.error as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nsocket.error is %s\\n\" % x.args[1])\n            except IOError as x:\n                if x.errno != errno.ENOENT:\n                    raise\n                if support.verbose:\n                    sys.stdout.write(\"\\IOError is %s\\n\" % str(x))\n            else:\n                raise AssertionError(\"Use of invalid cert should have failed!\")\n\n    def server_params_test(client_context, server_context, indata=b\"FOO\\n\",\n                           chatty=True, connectionchatty=False):\n        \"\"\"\n        Launch a server, connect a client to it and try various reads\n        and writes.\n        \"\"\"\n        server = ThreadedEchoServer(context=server_context,\n                                    chatty=chatty,\n                                    connectionchatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                for arg in [indata, bytearray(indata), memoryview(indata)]:\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  sending %r...\\n\" % indata)\n                    s.write(arg)\n                    outdata = s.read()\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                    if outdata != indata.lower():\n                        raise AssertionError(\n                            \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                            % (outdata[:20], len(outdata),\n                               indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\" client:  closing connection.\\n\")\n                s.close()\n\n    def try_protocol_combo(server_protocol, client_protocol, expect_success,\n                           certsreqs=None, server_options=0, client_options=0):\n        if certsreqs is None:\n            certsreqs = ssl.CERT_NONE\n        certtype = {\n            ssl.CERT_NONE: \"CERT_NONE\",\n            ssl.CERT_OPTIONAL: \"CERT_OPTIONAL\",\n            ssl.CERT_REQUIRED: \"CERT_REQUIRED\",\n        }[certsreqs]\n        if support.verbose:\n            formatstr = (expect_success and \" %s->%s %s\\n\") or \" {%s->%s} %s\\n\"\n            sys.stdout.write(formatstr %\n                             (ssl.get_protocol_name(client_protocol),\n                              ssl.get_protocol_name(server_protocol),\n                              certtype))\n        client_context = ssl.SSLContext(client_protocol)\n        client_context.options = ssl.OP_ALL | client_options\n        server_context = ssl.SSLContext(server_protocol)\n        server_context.options = ssl.OP_ALL | server_options\n        for ctx in (client_context, server_context):\n            ctx.verify_mode = certsreqs\n            # NOTE: we must enable \"ALL\" ciphers, otherwise an SSLv23 client\n            # will send an SSLv3 hello (rather than SSLv2) starting from\n            # OpenSSL 1.0.0 (see issue #8322).\n            ctx.set_ciphers(\"ALL\")\n            ctx.load_cert_chain(CERTFILE)\n            ctx.load_verify_locations(CERTFILE)\n        try:\n            server_params_test(client_context, server_context,\n                               chatty=False, connectionchatty=False)\n        # Protocol mismatch can result in either an SSLError, or a\n        # \"Connection reset by peer\" error.\n        except ssl.SSLError:\n            if expect_success:\n                raise\n        except socket.error as e:\n            if expect_success or e.errno != errno.ECONNRESET:\n                raise\n        else:\n            if not expect_success:\n                raise AssertionError(\n                    \"Client protocol %s succeeded with server protocol %s!\"\n                    % (ssl.get_protocol_name(client_protocol),\n                       ssl.get_protocol_name(server_protocol)))\n\n\n    class ThreadedTests(unittest.TestCase):\n\n        @skip_if_broken_ubuntu_ssl\n        def test_echo(self):\n            \"\"\"Basic test of an SSL client connecting to a server\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            for protocol in PROTOCOLS:\n                context = ssl.SSLContext(protocol)\n                context.load_cert_chain(CERTFILE)\n                server_params_test(context, context,\n                                   chatty=True, connectionchatty=True)\n\n        def test_getpeercert(self):\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = ThreadedEchoServer(context=context, chatty=False)\n            with server:\n                s = context.wrap_socket(socket.socket())\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()\n                if support.verbose:\n                    sys.stdout.write(pprint.pformat(cert) + '\\n')\n                    sys.stdout.write(\"Connection cipher is \" + str(cipher) + '.\\n')\n                if 'subject' not in cert:\n                    self.fail(\"No subject field in certificate: %s.\" %\n                              pprint.pformat(cert))\n                if ((('organizationName', 'Python Software Foundation'),)\n                    not in cert['subject']):\n                    self.fail(\n                        \"Missing or invalid 'organizationName' field in certificate subject; \"\n                        \"should be 'Python Software Foundation'.\")\n                self.assertIn('notBefore', cert)\n                self.assertIn('notAfter', cert)\n                before = ssl.cert_time_to_seconds(cert['notBefore'])\n                after = ssl.cert_time_to_seconds(cert['notAfter'])\n                self.assertLess(before, after)\n                s.close()\n\n        def test_empty_cert(self):\n            \"\"\"Connecting with an empty cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                      \"nullcert.pem\"))\n        def test_malformed_cert(self):\n            \"\"\"Connecting with a badly formatted certificate (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badcert.pem\"))\n        def test_nonexisting_cert(self):\n            \"\"\"Connecting with a non-existing cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"wrongcert.pem\"))\n        def test_malformed_key(self):\n            \"\"\"Connecting with a badly formatted key (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badkey.pem\"))\n\n        def test_rude_shutdown(self):\n            \"\"\"A brutal shutdown of an SSL server should raise an IOError\n            in the client when attempting handshake.\n            \"\"\"\n            listener_ready = threading.Event()\n            listener_gone = threading.Event()\n\n            s = socket.socket()\n            port = support.bind_port(s, HOST)\n\n            # `listener` runs in a thread.  It sits in an accept() until\n            # the main thread connects.  Then it rudely closes the socket,\n            # and sets Event `listener_gone` to let the main thread know\n            # the socket is gone.\n            def listener():\n                s.listen(5)\n                listener_ready.set()\n                newsock, addr = s.accept()\n                newsock.close()\n                s.close()\n                listener_gone.set()\n\n            def connector():\n                listener_ready.wait()\n                with socket.socket() as c:\n                    c.connect((HOST, port))\n                    listener_gone.wait()\n                    try:\n                        ssl_sock = ssl.wrap_socket(c)\n                    except IOError:\n                        pass\n                    else:\n                        self.fail('connecting to closed SSL socket should have failed')\n\n            t = threading.Thread(target=listener)\n            t.start()\n            try:\n                connector()\n            finally:\n                t.join()\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv2'), \"need SSLv2\")\n        def test_protocol_sslv2(self):\n            \"\"\"Connecting to an SSLv2 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLSv1, False)\n            # SSLv23 client with specific SSL options\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, False,\n                                   client_options=ssl.OP_NO_SSLv2)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv23(self):\n            \"\"\"Connecting to an SSLv23 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try:\n                    try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv2, True)\n                except (ssl.SSLError, socket.error) as x:\n                    # this fails on some older versions of OpenSSL (0.9.7l, for instance)\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" SSL2 client to SSL23 server test unexpectedly failed:\\n %s\\n\"\n                            % str(x))\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n\n            # Server with specific SSL options\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, False,\n                               server_options=ssl.OP_NO_SSLv3)\n            # Will choose TLSv1\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True,\n                               server_options=ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, False,\n                               server_options=ssl.OP_NO_TLSv1)\n\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv3(self):\n            \"\"\"Connecting to an SSLv3 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLSv1, False)\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, True,\n                                   client_options=ssl.OP_NO_SSLv2)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_tlsv1(self):\n            \"\"\"Connecting to a TLSv1 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        def test_starttls(self):\n            \"\"\"Switching from clear text to encrypted and back again.\"\"\"\n            msgs = (b\"msg 1\", b\"MSG 2\", b\"STARTTLS\", b\"MSG 3\", b\"msg 4\", b\"ENDTLS\", b\"msg 5\", b\"msg 6\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        starttls_server=True,\n                                        chatty=True,\n                                        connectionchatty=True)\n            wrapped = False\n            with server:\n                s = socket.socket()\n                s.setblocking(1)\n                s.connect((HOST, server.port))\n                if support.verbose:\n                    sys.stdout.write(\"\\n\")\n                for indata in msgs:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  sending %r...\\n\" % indata)\n                    if wrapped:\n                        conn.write(indata)\n                        outdata = conn.read()\n                    else:\n                        s.send(indata)\n                        outdata = s.recv(1024)\n                    msg = outdata.strip().lower()\n                    if indata == b\"STARTTLS\" and msg.startswith(b\"ok\"):\n                        # STARTTLS ok, switch to secure mode\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, starting TLS...\\n\"\n                                % msg)\n                        conn = ssl.wrap_socket(s, ssl_version=ssl.PROTOCOL_TLSv1)\n                        wrapped = True\n                    elif indata == b\"ENDTLS\" and msg.startswith(b\"ok\"):\n                        # ENDTLS ok, switch back to clear text\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, ending TLS...\\n\"\n                                % msg)\n                        s = conn.unwrap()\n                        wrapped = False\n                    else:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server\\n\" % msg)\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                if wrapped:\n                    conn.write(b\"over\\n\")\n                else:\n                    s.send(b\"over\\n\")\n                if wrapped:\n                    conn.close()\n                else:\n                    s.close()\n\n        def test_socketserver(self):\n            \"\"\"Using a SocketServer to create and manage SSL connections.\"\"\"\n            server = make_https_server(self, CERTFILE)\n            # try to connect\n            if support.verbose:\n                sys.stdout.write('\\n')\n            with open(CERTFILE, 'rb') as f:\n                d1 = f.read()\n            d2 = ''\n            # now fetch the same data from the HTTPS server\n            url = 'https://%s:%d/%s' % (\n                HOST, server.port, os.path.split(CERTFILE)[1])\n            f = urllib.request.urlopen(url)\n            try:\n                dlen = f.info().get(\"content-length\")\n                if dlen and (int(dlen) > 0):\n                    d2 = f.read(int(dlen))\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client: read %d bytes from remote server '%s'\\n\"\n                            % (len(d2), server))\n            finally:\n                f.close()\n            self.assertEqual(d1, d2)\n\n        def test_asyncore_server(self):\n            \"\"\"Check the example asyncore integration.\"\"\"\n            indata = \"TEST MESSAGE of mixed case\\n\"\n\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            indata = b\"FOO\\n\"\n            server = AsyncoreEchoServer(CERTFILE)\n            with server:\n                s = ssl.wrap_socket(socket.socket())\n                s.connect(('127.0.0.1', server.port))\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client:  sending %r...\\n\" % indata)\n                s.write(indata)\n                outdata = s.read()\n                if support.verbose:\n                    sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                if outdata != indata.lower():\n                    self.fail(\n                        \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                        % (outdata[:20], len(outdata),\n                           indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                s.close()\n                if support.verbose:\n                    sys.stdout.write(\" client:  connection closed.\\n\")\n\n        def test_recv_send(self):\n            \"\"\"Test recv(), send() and friends.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # helper methods for standardising recv* method signatures\n                def _recv_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count = s.recv_into(b)\n                    return b[:count]\n\n                def _recvfrom_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count, addr = s.recvfrom_into(b)\n                    return b[:count]\n\n                # (name, method, whether to expect success, *args)\n                send_methods = [\n                    ('send', s.send, True, []),\n                    ('sendto', s.sendto, False, [\"some.address\"]),\n                    ('sendall', s.sendall, True, []),\n                ]\n                recv_methods = [\n                    ('recv', s.recv, True, []),\n                    ('recvfrom', s.recvfrom, False, [\"some.address\"]),\n                    ('recv_into', _recv_into, True, []),\n                    ('recvfrom_into', _recvfrom_into, False, []),\n                ]\n                data_prefix = \"PREFIX_\"\n\n                for meth_name, send_meth, expect_success, args in send_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        send_meth(indata, *args)\n                        outdata = s.read()\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While sending with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to send with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n\n                for meth_name, recv_meth, expect_success, args in recv_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        s.send(indata)\n                        outdata = recv_meth(*args)\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While receiving with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to receive with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n                        # consume data\n                        s.read()\n                s.write(b\"over\\n\")\n                s.close()\n\n        def test_handshake_timeout(self):\n            # Issue #5103: SSL handshake must respect the socket timeout\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            started = threading.Event()\n            finish = False\n\n            def serve():\n                server.listen(5)\n                started.set()\n                conns = []\n                while not finish:\n                    r, w, e = select.select([server], [], [], 0.1)\n                    if server in r:\n                        # Let the socket hang around rather than having\n                        # it closed by garbage collection.\n                        conns.append(server.accept()[0])\n                for sock in conns:\n                    sock.close()\n\n            t = threading.Thread(target=serve)\n            t.start()\n            started.wait()\n\n            try:\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c.settimeout(0.2)\n                    c.connect((host, port))\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           ssl.wrap_socket, c)\n                finally:\n                    c.close()\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c = ssl.wrap_socket(c)\n                    c.settimeout(0.2)\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           c.connect, (host, port))\n                finally:\n                    c.close()\n            finally:\n                finish = True\n                t.join()\n                server.close()\n\n        def test_server_accept(self):\n            # Issue #16357: accept() on a SSLSocket created through\n            # SSLContext.wrap_socket().\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            server = context.wrap_socket(server, server_side=True)\n\n            evt = threading.Event()\n            remote = None\n            peer = None\n            def serve():\n                nonlocal remote, peer\n                server.listen(5)\n                # Block on the accept and wait on the connection to close.\n                evt.set()\n                remote, peer = server.accept()\n                remote.recv(1)\n\n            t = threading.Thread(target=serve)\n            t.start()\n            # Client wait until server setup and perform a connect.\n            evt.wait()\n            client = context.wrap_socket(socket.socket())\n            client.connect((host, port))\n            client_addr = client.getsockname()\n            client.close()\n            t.join()\n            # Sanity checks.\n            self.assertIsInstance(remote, ssl.SSLSocket)\n            self.assertEqual(peer, client_addr)\n\n        def test_default_ciphers(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            try:\n                # Force a set of weak ciphers on our client context\n                context.set_ciphers(\"DES\")\n            except ssl.SSLError:\n                self.skipTest(\"no DES cipher available\")\n            with ThreadedEchoServer(CERTFILE,\n                                    ssl_version=ssl.PROTOCOL_SSLv23,\n                                    chatty=False) as server:\n                with socket.socket() as sock:\n                    s = context.wrap_socket(sock)\n                    with self.assertRaises((OSError, ssl.SSLError)):\n                        s.connect((HOST, server.port))\n            self.assertIn(\"no shared cipher\", str(server.conn_errors[0]))\n\n\ndef test_main(verbose=False):\n    if support.verbose:\n        plats = {\n            'Linux': platform.linux_distribution,\n            'Mac': platform.mac_ver,\n            'Windows': platform.win32_ver,\n        }\n        for name, func in plats.items():\n            plat = func()\n            if plat and plat[0]:\n                plat = '%s %r' % (name, plat)\n                break\n        else:\n            plat = repr(platform.platform())\n        print(\"test_ssl: testing with %r %r\" %\n            (ssl.OPENSSL_VERSION, ssl.OPENSSL_VERSION_INFO))\n        print(\"          under %s\" % plat)\n        print(\"          HAS_SNI = %r\" % ssl.HAS_SNI)\n\n    for filename in [\n        CERTFILE, SVN_PYTHON_ORG_ROOT_CERT, BYTES_CERTFILE,\n        ONLYCERT, ONLYKEY, BYTES_ONLYCERT, BYTES_ONLYKEY,\n        BADCERT, BADKEY, EMPTYCERT]:\n        if not os.path.exists(filename):\n            raise support.TestFailed(\"Can't read certificate file %r\" % filename)\n\n    tests = [ContextTests, BasicSocketTests]\n\n    if support.is_resource_enabled('network'):\n        tests.append(NetworkedTests)\n\n    if _have_threads:\n        thread_info = support.threading_setup()\n        if thread_info and support.is_resource_enabled('network'):\n            tests.append(ThreadedTests)\n\n    try:\n        support.run_unittest(*tests)\n    finally:\n        if _have_threads:\n            support.threading_cleanup(*thread_info)\n\nif __name__ == \"__main__\":\n    test_main()\n"
  },
  {
    "patch": "diff --git a/Lib/test/test_ssl.py b/Lib/test/test_ssl.py\nindex 75dc2029b66..7ccffadca34 100644\n--- a/Lib/test/test_ssl.py\n+++ b/Lib/test/test_ssl.py\n@@ -56,6 +56,7 @@\n WRONGCERT = data_file(\"XXXnonexisting.pem\")\n BADKEY = data_file(\"badkey.pem\")\n NOKIACERT = data_file(\"nokia.pem\")\n+NULLBYTECERT = data_file(\"nullbytecert.pem\")\n \n DHFILE = data_file(\"dh512.pem\")\n BYTES_DHFILE = os.fsencode(DHFILE)\n@@ -176,6 +177,27 @@ def test_parse_cert(self):\n                           ('DNS', 'projects.forum.nokia.com'))\n                         )\n \n+    def test_parse_cert_CVE_2013_4238(self):\n+        p = ssl._ssl._test_decode_cert(NULLBYTECERT)\n+        if support.verbose:\n+            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n+        subject = ((('countryName', 'US'),),\n+                   (('stateOrProvinceName', 'Oregon'),),\n+                   (('localityName', 'Beaverton'),),\n+                   (('organizationName', 'Python Software Foundation'),),\n+                   (('organizationalUnitName', 'Python Core Development'),),\n+                   (('commonName', 'null.python.org\\x00example.org'),),\n+                   (('emailAddress', 'python-dev@python.org'),))\n+        self.assertEqual(p['subject'], subject)\n+        self.assertEqual(p['issuer'], subject)\n+        self.assertEqual(p['subjectAltName'],\n+                         (('DNS', 'altnull.python.org\\x00example.com'),\n+                         ('email', 'null@python.org\\x00user@example.org'),\n+                         ('URI', 'http://null.python.org\\x00http://example.org'),\n+                         ('IP Address', '192.0.2.1'),\n+                         ('IP Address', '2001:DB8:0:0:0:0:0:1\\n'))\n+                        )\n+\n     def test_DER_to_PEM(self):\n         with open(SVN_PYTHON_ORG_ROOT_CERT, 'r') as f:\n             pem = f.read()\n@@ -308,6 +330,13 @@ def fail(cert, hostname):\n         fail(cert, 'foo.a.com')\n         fail(cert, 'bar.foo.com')\n \n+        # NULL bytes are bad, CVE-2013-4073\n+        cert = {'subject': ((('commonName',\n+                              'null.python.org\\x00example.org'),),)}\n+        ok(cert, 'null.python.org\\x00example.org') # or raise an error?\n+        fail(cert, 'example.org')\n+        fail(cert, 'null.python.org')\n+\n         # Slightly fake real-world example\n         cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                 'subject': ((('commonName', 'linuxfrz.org'),),),\n",
    "commit_message": "Issue #18709: Fix CVE-2013-4238. The SSL module now handles NULL bytes\ninside subjectAltName correctly. Formerly the module has used OpenSSL's\nGENERAL_NAME_print() function to get the string represention of ASN.1\nstrings for rfc822Name (email), dNSName (DNS) and\nuniformResourceIdentifier (URI).\n\n",
    "code_before": "# Test the support for SSL and sockets\n\nimport sys\nimport unittest\nfrom test import support\nimport socket\nimport select\nimport time\nimport datetime\nimport gc\nimport os\nimport errno\nimport pprint\nimport tempfile\nimport urllib.request\nimport traceback\nimport asyncore\nimport weakref\nimport platform\nimport functools\nfrom unittest import mock\n\nssl = support.import_module(\"ssl\")\n\nPROTOCOLS = sorted(ssl._PROTOCOL_NAMES)\nHOST = support.HOST\n\ndata_file = lambda name: os.path.join(os.path.dirname(__file__), name)\n\n# The custom key and certificate files used in test_ssl are generated\n# using Lib/test/make_ssl_certs.py.\n# Other certificates are simply fetched from the Internet servers they\n# are meant to authenticate.\n\nCERTFILE = data_file(\"keycert.pem\")\nBYTES_CERTFILE = os.fsencode(CERTFILE)\nONLYCERT = data_file(\"ssl_cert.pem\")\nONLYKEY = data_file(\"ssl_key.pem\")\nBYTES_ONLYCERT = os.fsencode(ONLYCERT)\nBYTES_ONLYKEY = os.fsencode(ONLYKEY)\nCERTFILE_PROTECTED = data_file(\"keycert.passwd.pem\")\nONLYKEY_PROTECTED = data_file(\"ssl_key.passwd.pem\")\nKEY_PASSWORD = \"somepass\"\nCAPATH = data_file(\"capath\")\nBYTES_CAPATH = os.fsencode(CAPATH)\n\n# Two keys and certs signed by the same CA (for SNI tests)\nSIGNED_CERTFILE = data_file(\"keycert3.pem\")\nSIGNED_CERTFILE2 = data_file(\"keycert4.pem\")\nSIGNING_CA = data_file(\"pycacert.pem\")\n\nSVN_PYTHON_ORG_ROOT_CERT = data_file(\"https_svn_python_org_root.pem\")\n\nEMPTYCERT = data_file(\"nullcert.pem\")\nBADCERT = data_file(\"badcert.pem\")\nWRONGCERT = data_file(\"XXXnonexisting.pem\")\nBADKEY = data_file(\"badkey.pem\")\nNOKIACERT = data_file(\"nokia.pem\")\n\nDHFILE = data_file(\"dh512.pem\")\nBYTES_DHFILE = os.fsencode(DHFILE)\n\n\ndef handle_error(prefix):\n    exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))\n    if support.verbose:\n        sys.stdout.write(prefix + exc_format)\n\ndef can_clear_options():\n    # 0.9.8m or higher\n    return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)\n\ndef no_sslv2_implies_sslv3_hello():\n    # 0.9.7h or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)\n\ndef asn1time(cert_time):\n    # Some versions of OpenSSL ignore seconds, see #18207\n    # 0.9.8.i\n    if ssl._OPENSSL_API_VERSION == (0, 9, 8, 9, 15):\n        fmt = \"%b %d %H:%M:%S %Y GMT\"\n        dt = datetime.datetime.strptime(cert_time, fmt)\n        dt = dt.replace(second=0)\n        cert_time = dt.strftime(fmt)\n        # %d adds leading zero but ASN1_TIME_print() uses leading space\n        if cert_time[4] == \"0\":\n            cert_time = cert_time[:4] + \" \" + cert_time[5:]\n\n    return cert_time\n\n# Issue #9415: Ubuntu hijacks their OpenSSL and forcefully disables SSLv2\ndef skip_if_broken_ubuntu_ssl(func):\n    if hasattr(ssl, 'PROTOCOL_SSLv2'):\n        @functools.wraps(func)\n        def f(*args, **kwargs):\n            try:\n                ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n            except ssl.SSLError:\n                if (ssl.OPENSSL_VERSION_INFO == (0, 9, 8, 15, 15) and\n                    platform.linux_distribution() == ('debian', 'squeeze/sid', '')):\n                    raise unittest.SkipTest(\"Patched Ubuntu OpenSSL breaks behaviour\")\n            return func(*args, **kwargs)\n        return f\n    else:\n        return func\n\nneeds_sni = unittest.skipUnless(ssl.HAS_SNI, \"SNI support needed for this test\")\n\n\nclass BasicSocketTests(unittest.TestCase):\n\n    def test_constants(self):\n        ssl.CERT_NONE\n        ssl.CERT_OPTIONAL\n        ssl.CERT_REQUIRED\n        ssl.OP_CIPHER_SERVER_PREFERENCE\n        ssl.OP_SINGLE_DH_USE\n        if ssl.HAS_ECDH:\n            ssl.OP_SINGLE_ECDH_USE\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0):\n            ssl.OP_NO_COMPRESSION\n        self.assertIn(ssl.HAS_SNI, {True, False})\n        self.assertIn(ssl.HAS_ECDH, {True, False})\n\n    def test_random(self):\n        v = ssl.RAND_status()\n        if support.verbose:\n            sys.stdout.write(\"\\n RAND_status is %d (%s)\\n\"\n                             % (v, (v and \"sufficient randomness\") or\n                                \"insufficient randomness\"))\n\n        data, is_cryptographic = ssl.RAND_pseudo_bytes(16)\n        self.assertEqual(len(data), 16)\n        self.assertEqual(is_cryptographic, v == 1)\n        if v:\n            data = ssl.RAND_bytes(16)\n            self.assertEqual(len(data), 16)\n        else:\n            self.assertRaises(ssl.SSLError, ssl.RAND_bytes, 16)\n\n        self.assertRaises(TypeError, ssl.RAND_egd, 1)\n        self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)\n        ssl.RAND_add(\"this is a random string\", 75.0)\n\n    def test_parse_cert(self):\n        # note that this uses an 'unofficial' function in _ssl.c,\n        # provided solely for this test, to exercise the certificate\n        # parsing code\n        p = ssl._ssl._test_decode_cert(CERTFILE)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['issuer'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        # Note the next three asserts will fail if the keys are regenerated\n        self.assertEqual(p['notAfter'], asn1time('Oct  5 23:01:56 2020 GMT'))\n        self.assertEqual(p['notBefore'], asn1time('Oct  8 23:01:56 2010 GMT'))\n        self.assertEqual(p['serialNumber'], 'D7C7381919AFC24E')\n        self.assertEqual(p['subject'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['subjectAltName'], (('DNS', 'localhost'),))\n        # Issue #13034: the subjectAltName in some certificates\n        # (notably projects.developer.nokia.com:443) wasn't parsed\n        p = ssl._ssl._test_decode_cert(NOKIACERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'projects.developer.nokia.com'),\n                          ('DNS', 'projects.forum.nokia.com'))\n                        )\n\n    def test_DER_to_PEM(self):\n        with open(SVN_PYTHON_ORG_ROOT_CERT, 'r') as f:\n            pem = f.read()\n        d1 = ssl.PEM_cert_to_DER_cert(pem)\n        p2 = ssl.DER_cert_to_PEM_cert(d1)\n        d2 = ssl.PEM_cert_to_DER_cert(p2)\n        self.assertEqual(d1, d2)\n        if not p2.startswith(ssl.PEM_HEADER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct header:\\n%r\\n\" % p2)\n        if not p2.endswith('\\n' + ssl.PEM_FOOTER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct footer:\\n%r\\n\" % p2)\n\n    def test_openssl_version(self):\n        n = ssl.OPENSSL_VERSION_NUMBER\n        t = ssl.OPENSSL_VERSION_INFO\n        s = ssl.OPENSSL_VERSION\n        self.assertIsInstance(n, int)\n        self.assertIsInstance(t, tuple)\n        self.assertIsInstance(s, str)\n        # Some sanity checks follow\n        # >= 0.9\n        self.assertGreaterEqual(n, 0x900000)\n        # < 2.0\n        self.assertLess(n, 0x20000000)\n        major, minor, fix, patch, status = t\n        self.assertGreaterEqual(major, 0)\n        self.assertLess(major, 2)\n        self.assertGreaterEqual(minor, 0)\n        self.assertLess(minor, 256)\n        self.assertGreaterEqual(fix, 0)\n        self.assertLess(fix, 256)\n        self.assertGreaterEqual(patch, 0)\n        self.assertLessEqual(patch, 26)\n        self.assertGreaterEqual(status, 0)\n        self.assertLessEqual(status, 15)\n        # Version string as returned by OpenSSL, the format might change\n        self.assertTrue(s.startswith(\"OpenSSL {:d}.{:d}.{:d}\".format(major, minor, fix)),\n                        (s, t))\n\n    @support.cpython_only\n    def test_refcycle(self):\n        # Issue #7943: an SSL object doesn't create reference cycles with\n        # itself.\n        s = socket.socket(socket.AF_INET)\n        ss = ssl.wrap_socket(s)\n        wr = weakref.ref(ss)\n        with support.check_warnings((\"\", ResourceWarning)):\n            del ss\n            self.assertEqual(wr(), None)\n\n    def test_wrapped_unconnected(self):\n        # Methods on an unconnected SSLSocket propagate the original\n        # OSError raise by the underlying socket object.\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            self.assertRaises(OSError, ss.recv, 1)\n            self.assertRaises(OSError, ss.recv_into, bytearray(b'x'))\n            self.assertRaises(OSError, ss.recvfrom, 1)\n            self.assertRaises(OSError, ss.recvfrom_into, bytearray(b'x'), 1)\n            self.assertRaises(OSError, ss.send, b'x')\n            self.assertRaises(OSError, ss.sendto, b'x', ('0.0.0.0', 0))\n\n    def test_timeout(self):\n        # Issue #8524: when creating an SSL socket, the timeout of the\n        # original socket should be retained.\n        for timeout in (None, 0.0, 5.0):\n            s = socket.socket(socket.AF_INET)\n            s.settimeout(timeout)\n            with ssl.wrap_socket(s) as ss:\n                self.assertEqual(timeout, ss.gettimeout())\n\n    def test_errors(self):\n        sock = socket.socket()\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified\",\n                        ssl.wrap_socket, sock, keyfile=CERTFILE)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True, certfile=\"\")\n        with ssl.wrap_socket(sock, server_side=True, certfile=CERTFILE) as s:\n            self.assertRaisesRegex(ValueError, \"can't connect in server-side mode\",\n                                    s.connect, (HOST, 8080))\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=CERTFILE, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n\n    def test_match_hostname(self):\n        def ok(cert, hostname):\n            ssl.match_hostname(cert, hostname)\n        def fail(cert, hostname):\n            self.assertRaises(ssl.CertificateError,\n                              ssl.match_hostname, cert, hostname)\n\n        cert = {'subject': ((('commonName', 'example.com'),),)}\n        ok(cert, 'example.com')\n        ok(cert, 'ExAmple.cOm')\n        fail(cert, 'www.example.com')\n        fail(cert, '.example.com')\n        fail(cert, 'example.org')\n        fail(cert, 'exampleXcom')\n\n        cert = {'subject': ((('commonName', '*.a.com'),),)}\n        ok(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        cert = {'subject': ((('commonName', 'a.*.com'),),)}\n        ok(cert, 'a.foo.com')\n        fail(cert, 'a..com')\n        fail(cert, 'a.com')\n\n        cert = {'subject': ((('commonName', 'f*.com'),),)}\n        ok(cert, 'foo.com')\n        ok(cert, 'f.com')\n        fail(cert, 'bar.com')\n        fail(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.com')\n\n        # Slightly fake real-world example\n        cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                'subject': ((('commonName', 'linuxfrz.org'),),),\n                'subjectAltName': (('DNS', 'linuxfr.org'),\n                                   ('DNS', 'linuxfr.com'),\n                                   ('othername', '<unsupported>'))}\n        ok(cert, 'linuxfr.org')\n        ok(cert, 'linuxfr.com')\n        # Not a \"DNS\" entry\n        fail(cert, '<unsupported>')\n        # When there is a subjectAltName, commonName isn't used\n        fail(cert, 'linuxfrz.org')\n\n        # A pristine real-world example\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),),\n                            (('commonName', 'mail.google.com'),))}\n        ok(cert, 'mail.google.com')\n        fail(cert, 'gmail.com')\n        # Only commonName is considered\n        fail(cert, 'California')\n\n        # Neither commonName nor subjectAltName\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),))}\n        fail(cert, 'mail.google.com')\n\n        # No DNS entry in subjectAltName but a commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('commonName', 'mail.google.com'),)),\n                'subjectAltName': (('othername', 'blabla'), )}\n        ok(cert, 'mail.google.com')\n\n        # No DNS entry subjectAltName and no commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),)),\n                'subjectAltName': (('othername', 'blabla'),)}\n        fail(cert, 'google.com')\n\n        # Empty cert / no cert\n        self.assertRaises(ValueError, ssl.match_hostname, None, 'example.com')\n        self.assertRaises(ValueError, ssl.match_hostname, {}, 'example.com')\n\n        # Issue #17980: avoid denials of service by refusing more than one\n        # wildcard per fragment.\n        cert = {'subject': ((('commonName', 'a*b.com'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b.co*'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b*.com'),),)}\n        with self.assertRaises(ssl.CertificateError) as cm:\n            ssl.match_hostname(cert, 'axxbxxc.com')\n        self.assertIn(\"too many wildcards\", str(cm.exception))\n\n    def test_server_side(self):\n        # server_hostname doesn't work for server sockets\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        with socket.socket() as sock:\n            self.assertRaises(ValueError, ctx.wrap_socket, sock, True,\n                              server_hostname=\"some.hostname\")\n\n    def test_unknown_channel_binding(self):\n        # should raise ValueError for unknown type\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            with self.assertRaises(ValueError):\n                ss.get_channel_binding(\"unknown-type\")\n\n    @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                         \"'tls-unique' channel binding not available\")\n    def test_tls_unique_channel_binding(self):\n        # unconnected should return None for known type\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n        # the same for server-side\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s, server_side=True, certfile=CERTFILE) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n\n    def test_dealloc_warn(self):\n        ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n        r = repr(ss)\n        with self.assertWarns(ResourceWarning) as cm:\n            ss = None\n            support.gc_collect()\n        self.assertIn(r, str(cm.warning.args[0]))\n\n    def test_get_default_verify_paths(self):\n        paths = ssl.get_default_verify_paths()\n        self.assertEqual(len(paths), 6)\n        self.assertIsInstance(paths, ssl.DefaultVerifyPaths)\n\n        with support.EnvironmentVarGuard() as env:\n            env[\"SSL_CERT_DIR\"] = CAPATH\n            env[\"SSL_CERT_FILE\"] = CERTFILE\n            paths = ssl.get_default_verify_paths()\n            self.assertEqual(paths.cafile, CERTFILE)\n            self.assertEqual(paths.capath, CAPATH)\n\n\n    @unittest.skipUnless(sys.platform == \"win32\", \"Windows specific\")\n    def test_enum_cert_store(self):\n        self.assertEqual(ssl.X509_ASN_ENCODING, 1)\n        self.assertEqual(ssl.PKCS_7_ASN_ENCODING, 0x00010000)\n\n        self.assertEqual(ssl.enum_cert_store(\"CA\"),\n            ssl.enum_cert_store(\"CA\", \"certificate\"))\n        ssl.enum_cert_store(\"CA\", \"crl\")\n        self.assertEqual(ssl.enum_cert_store(\"ROOT\"),\n            ssl.enum_cert_store(\"ROOT\", \"certificate\"))\n        ssl.enum_cert_store(\"ROOT\", \"crl\")\n\n        self.assertRaises(TypeError, ssl.enum_cert_store)\n        self.assertRaises(WindowsError, ssl.enum_cert_store, \"\")\n        self.assertRaises(ValueError, ssl.enum_cert_store, \"CA\", \"wrong\")\n\n        ca = ssl.enum_cert_store(\"CA\")\n        self.assertIsInstance(ca, list)\n        self.assertIsInstance(ca[0], tuple)\n        self.assertEqual(len(ca[0]), 2)\n        self.assertIsInstance(ca[0][0], bytes)\n        self.assertIsInstance(ca[0][1], int)\n\nclass ContextTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_constructor(self):\n        for protocol in PROTOCOLS:\n            ssl.SSLContext(protocol)\n        self.assertRaises(TypeError, ssl.SSLContext)\n        self.assertRaises(ValueError, ssl.SSLContext, -1)\n        self.assertRaises(ValueError, ssl.SSLContext, 42)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.protocol, proto)\n\n    def test_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ciphers(\"ALL\")\n        ctx.set_ciphers(\"DEFAULT\")\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            ctx.set_ciphers(\"^$:,;?*'dorothyx\")\n\n    @skip_if_broken_ubuntu_ssl\n    def test_options(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # OP_ALL is the default value\n        self.assertEqual(ssl.OP_ALL, ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv2\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2,\n                         ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv3\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3,\n                         ctx.options)\n        if can_clear_options():\n            ctx.options = (ctx.options & ~ssl.OP_NO_SSLv2) | ssl.OP_NO_TLSv1\n            self.assertEqual(ssl.OP_ALL | ssl.OP_NO_TLSv1 | ssl.OP_NO_SSLv3,\n                             ctx.options)\n            ctx.options = 0\n            self.assertEqual(0, ctx.options)\n        else:\n            with self.assertRaises(ValueError):\n                ctx.options = 0\n\n    def test_verify(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Default value\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        with self.assertRaises(TypeError):\n            ctx.verify_mode = None\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = 42\n\n    def test_load_cert_chain(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Combined key and cert in a single file\n        ctx.load_cert_chain(CERTFILE)\n        ctx.load_cert_chain(CERTFILE, keyfile=CERTFILE)\n        self.assertRaises(TypeError, ctx.load_cert_chain, keyfile=CERTFILE)\n        with self.assertRaises(OSError) as cm:\n            ctx.load_cert_chain(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(BADCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(EMPTYCERT)\n        # Separate key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY)\n        ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)\n        ctx.load_cert_chain(certfile=BYTES_ONLYCERT, keyfile=BYTES_ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)\n        # Mismatching key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaisesRegex(ssl.SSLError, \"key values mismatch\"):\n            ctx.load_cert_chain(SVN_PYTHON_ORG_ROOT_CERT, ONLYKEY)\n        # Password protected key and cert\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD.encode())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=bytearray(KEY_PASSWORD.encode()))\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD.encode())\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED,\n                            bytearray(KEY_PASSWORD.encode()))\n        with self.assertRaisesRegex(TypeError, \"should be a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=True)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=\"badpass\")\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            # openssl has a fixed limit on the password buffer.\n            # PEM_BUFSIZE is generally set to 1kb.\n            # Return a string larger than this.\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=b'a' * 102400)\n        # Password callback\n        def getpass_unicode():\n            return KEY_PASSWORD\n        def getpass_bytes():\n            return KEY_PASSWORD.encode()\n        def getpass_bytearray():\n            return bytearray(KEY_PASSWORD.encode())\n        def getpass_badpass():\n            return \"badpass\"\n        def getpass_huge():\n            return b'a' * (1024 * 1024)\n        def getpass_bad_type():\n            return 9\n        def getpass_exception():\n            raise Exception('getpass error')\n        class GetPassCallable:\n            def __call__(self):\n                return KEY_PASSWORD\n            def getpass(self):\n                return KEY_PASSWORD\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_unicode)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytes)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytearray)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=GetPassCallable())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=GetPassCallable().getpass)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_badpass)\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_huge)\n        with self.assertRaisesRegex(TypeError, \"must return a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bad_type)\n        with self.assertRaisesRegex(Exception, \"getpass error\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_exception)\n        # Make sure the password function isn't called if it isn't needed\n        ctx.load_cert_chain(CERTFILE, password=getpass_exception)\n\n    def test_load_verify_locations(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_verify_locations(CERTFILE)\n        ctx.load_verify_locations(cafile=CERTFILE, capath=None)\n        ctx.load_verify_locations(BYTES_CERTFILE)\n        ctx.load_verify_locations(cafile=BYTES_CERTFILE, capath=None)\n        self.assertRaises(TypeError, ctx.load_verify_locations)\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, None)\n        with self.assertRaises(OSError) as cm:\n            ctx.load_verify_locations(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_verify_locations(BADCERT)\n        ctx.load_verify_locations(CERTFILE, CAPATH)\n        ctx.load_verify_locations(CERTFILE, capath=BYTES_CAPATH)\n\n        # Issue #10989: crash if the second argument type is invalid\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, True)\n\n    def test_load_dh_params(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_dh_params(DHFILE)\n        if os.name != 'nt':\n            ctx.load_dh_params(BYTES_DHFILE)\n        self.assertRaises(TypeError, ctx.load_dh_params)\n        self.assertRaises(TypeError, ctx.load_dh_params, None)\n        with self.assertRaises(FileNotFoundError) as cm:\n            ctx.load_dh_params(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_session_stats(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.session_stats(), {\n                'number': 0,\n                'connect': 0,\n                'connect_good': 0,\n                'connect_renegotiate': 0,\n                'accept': 0,\n                'accept_good': 0,\n                'accept_renegotiate': 0,\n                'hits': 0,\n                'misses': 0,\n                'timeouts': 0,\n                'cache_full': 0,\n            })\n\n    def test_set_default_verify_paths(self):\n        # There's not much we can do to test that it acts as expected,\n        # so just check it doesn't crash or raise an exception.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_default_verify_paths()\n\n    @unittest.skipUnless(ssl.HAS_ECDH, \"ECDH disabled on this OpenSSL build\")\n    def test_set_ecdh_curve(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ecdh_curve(\"prime256v1\")\n        ctx.set_ecdh_curve(b\"prime256v1\")\n        self.assertRaises(TypeError, ctx.set_ecdh_curve)\n        self.assertRaises(TypeError, ctx.set_ecdh_curve, None)\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, \"foo\")\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, b\"foo\")\n\n    @needs_sni\n    def test_sni_callback(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n\n        # set_servername_callback expects a callable, or None\n        self.assertRaises(TypeError, ctx.set_servername_callback)\n        self.assertRaises(TypeError, ctx.set_servername_callback, 4)\n        self.assertRaises(TypeError, ctx.set_servername_callback, \"\")\n        self.assertRaises(TypeError, ctx.set_servername_callback, ctx)\n\n        def dummycallback(sock, servername, ctx):\n            pass\n        ctx.set_servername_callback(None)\n        ctx.set_servername_callback(dummycallback)\n\n    @needs_sni\n    def test_sni_callback_refcycle(self):\n        # Reference cycles through the servername callback are detected\n        # and cleared.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        def dummycallback(sock, servername, ctx, cycle=ctx):\n            pass\n        ctx.set_servername_callback(dummycallback)\n        wr = weakref.ref(ctx)\n        del ctx, dummycallback\n        gc.collect()\n        self.assertIs(wr(), None)\n\n    def test_cert_store_stats(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 0})\n        ctx.load_cert_chain(CERTFILE)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 0})\n        ctx.load_verify_locations(CERTFILE)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 1})\n        ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 1, 'crl': 0, 'x509': 2})\n\n    def test_get_ca_certs(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        # CERTFILE is not flagged as X509v3 Basic Constraints: CA:TRUE\n        ctx.load_verify_locations(CERTFILE)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        # but SVN_PYTHON_ORG_ROOT_CERT is a CA cert\n        ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n        self.assertEqual(ctx.get_ca_certs(),\n            [{'issuer': ((('organizationName', 'Root CA'),),\n                         (('organizationalUnitName', 'http://www.cacert.org'),),\n                         (('commonName', 'CA Cert Signing Authority'),),\n                         (('emailAddress', 'support@cacert.org'),)),\n              'notAfter': asn1time('Mar 29 12:29:49 2033 GMT'),\n              'notBefore': asn1time('Mar 30 12:29:49 2003 GMT'),\n              'serialNumber': '00',\n              'subject': ((('organizationName', 'Root CA'),),\n                          (('organizationalUnitName', 'http://www.cacert.org'),),\n                          (('commonName', 'CA Cert Signing Authority'),),\n                          (('emailAddress', 'support@cacert.org'),)),\n              'version': 3}])\n\n        with open(SVN_PYTHON_ORG_ROOT_CERT) as f:\n            pem = f.read()\n        der = ssl.PEM_cert_to_DER_cert(pem)\n        self.assertEqual(ctx.get_ca_certs(True), [der])\n\n\nclass SSLErrorTests(unittest.TestCase):\n\n    def test_str(self):\n        # The str() of a SSLError doesn't include the errno\n        e = ssl.SSLError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n        # Same for a subclass\n        e = ssl.SSLZeroReturnError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n\n    def test_lib_reason(self):\n        # Test the library and reason attributes\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n        self.assertEqual(cm.exception.library, 'PEM')\n        self.assertEqual(cm.exception.reason, 'NO_START_LINE')\n        s = str(cm.exception)\n        self.assertTrue(s.startswith(\"[PEM: NO_START_LINE] no start line\"), s)\n\n    def test_subclass(self):\n        # Check that the appropriate SSLError subclass is raised\n        # (this only tests one of them)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with socket.socket() as s:\n            s.bind((\"127.0.0.1\", 0))\n            s.listen(5)\n            c = socket.socket()\n            c.connect(s.getsockname())\n            c.setblocking(False)\n            with ctx.wrap_socket(c, False, do_handshake_on_connect=False) as c:\n                with self.assertRaises(ssl.SSLWantReadError) as cm:\n                    c.do_handshake()\n                s = str(cm.exception)\n                self.assertTrue(s.startswith(\"The operation did not complete (read)\"), s)\n                # For compatibility\n                self.assertEqual(cm.exception.errno, ssl.SSL_ERROR_WANT_READ)\n\n\nclass NetworkedTests(unittest.TestCase):\n\n    def test_connect(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n\n            # this should fail because we have no verification certs\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED)\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                   s.connect, (\"svn.python.org\", 443))\n            s.close()\n\n            # this should succeed because we specify the root cert\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_connect_ex(self):\n        # Issue #11326: check connect_ex() implementation\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(0, s.connect_ex((\"svn.python.org\", 443)))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_non_blocking_connect_ex(self):\n        # Issue #11326: non-blocking connect_ex() should allow handshake\n        # to proceed after the socket gets ready.\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.setblocking(False)\n                rc = s.connect_ex(('svn.python.org', 443))\n                # EWOULDBLOCK under Windows, EINPROGRESS elsewhere\n                self.assertIn(rc, (0, errno.EINPROGRESS, errno.EWOULDBLOCK))\n                # Wait for connect to finish\n                select.select([], [s], [], 5.0)\n                # Non-blocking handshake\n                while True:\n                    try:\n                        s.do_handshake()\n                        break\n                    except ssl.SSLWantReadError:\n                        select.select([s], [], [], 5.0)\n                    except ssl.SSLWantWriteError:\n                        select.select([], [s], [], 5.0)\n                # SSL established\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_timeout_connect_ex(self):\n        # Issue #12065: on a timeout, connect_ex() should return the original\n        # errno (mimicking the behaviour of non-SSL sockets).\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.settimeout(0.0000001)\n                rc = s.connect_ex(('svn.python.org', 443))\n                if rc == 0:\n                    self.skipTest(\"svn.python.org responded too quickly\")\n                self.assertIn(rc, (errno.EAGAIN, errno.EWOULDBLOCK))\n            finally:\n                s.close()\n\n    def test_connect_ex_error(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(errno.ECONNREFUSED,\n                                 s.connect_ex((\"svn.python.org\", 444)))\n            finally:\n                s.close()\n\n    def test_connect_with_context(self):\n        with support.transient_internet(\"svn.python.org\"):\n            # Same as test_connect, but with a separately created context\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n            # Same with a server hostname\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"svn.python.org\")\n            if ssl.HAS_SNI:\n                s.connect((\"svn.python.org\", 443))\n                s.close()\n            else:\n                self.assertRaises(ValueError, s.connect, (\"svn.python.org\", 443))\n            # This should fail because we have no verification certs\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                    s.connect, (\"svn.python.org\", 443))\n            s.close()\n            # This should succeed because we specify the root cert\n            ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    def test_connect_capath(self):\n        # Verify server certificates using the `capath` argument\n        # NOTE: the subject hashing algorithm has been changed between\n        # OpenSSL 0.9.8n and 1.0.0, as a result the capath directory must\n        # contain both versions of each certificate (same content, different\n        # filename) for this test to be portable across OpenSSL releases.\n        with support.transient_internet(\"svn.python.org\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n            # Same with a bytes `capath` argument\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=BYTES_CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    @unittest.skipIf(os.name == \"nt\", \"Can't use a socket as a file under Windows\")\n    def test_makefile_close(self):\n        # Issue #5238: creating a file-like object with makefile() shouldn't\n        # delay closing the underlying \"real socket\" (here tested with its\n        # file descriptor, hence skipping the test under Windows).\n        with support.transient_internet(\"svn.python.org\"):\n            ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n            ss.connect((\"svn.python.org\", 443))\n            fd = ss.fileno()\n            f = ss.makefile()\n            f.close()\n            # The fd is still open\n            os.read(fd, 0)\n            # Closing the SSL socket should close the fd too\n            ss.close()\n            gc.collect()\n            with self.assertRaises(OSError) as e:\n                os.read(fd, 0)\n            self.assertEqual(e.exception.errno, errno.EBADF)\n\n    def test_non_blocking_handshake(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = socket.socket(socket.AF_INET)\n            s.connect((\"svn.python.org\", 443))\n            s.setblocking(False)\n            s = ssl.wrap_socket(s,\n                                cert_reqs=ssl.CERT_NONE,\n                                do_handshake_on_connect=False)\n            count = 0\n            while True:\n                try:\n                    count += 1\n                    s.do_handshake()\n                    break\n                except ssl.SSLWantReadError:\n                    select.select([s], [], [])\n                except ssl.SSLWantWriteError:\n                    select.select([], [s], [])\n            s.close()\n            if support.verbose:\n                sys.stdout.write(\"\\nNeeded %d calls to do_handshake() to establish session.\\n\" % count)\n\n    def test_get_server_certificate(self):\n        def _test_get_server_certificate(host, port, cert=None):\n            with support.transient_internet(host):\n                pem = ssl.get_server_certificate((host, port))\n                if not pem:\n                    self.fail(\"No server certificate on %s:%s!\" % (host, port))\n\n                try:\n                    pem = ssl.get_server_certificate((host, port), ca_certs=CERTFILE)\n                except ssl.SSLError as x:\n                    #should fail\n                    if support.verbose:\n                        sys.stdout.write(\"%s\\n\" % x)\n                else:\n                    self.fail(\"Got server certificate %s for %s:%s!\" % (pem, host, port))\n\n                pem = ssl.get_server_certificate((host, port), ca_certs=cert)\n                if not pem:\n                    self.fail(\"No server certificate on %s:%s!\" % (host, port))\n                if support.verbose:\n                    sys.stdout.write(\"\\nVerified certificate for %s:%s is\\n%s\\n\" % (host, port ,pem))\n\n        _test_get_server_certificate('svn.python.org', 443, SVN_PYTHON_ORG_ROOT_CERT)\n        if support.IPV6_ENABLED:\n            _test_get_server_certificate('ipv6.google.com', 443)\n\n    def test_ciphers(self):\n        remote = (\"svn.python.org\", 443)\n        with support.transient_internet(remote[0]):\n            with ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                 cert_reqs=ssl.CERT_NONE, ciphers=\"ALL\") as s:\n                s.connect(remote)\n            with ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                 cert_reqs=ssl.CERT_NONE, ciphers=\"DEFAULT\") as s:\n                s.connect(remote)\n            # Error checking can happen at instantiation or when connecting\n            with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n                with socket.socket(socket.AF_INET) as sock:\n                    s = ssl.wrap_socket(sock,\n                                        cert_reqs=ssl.CERT_NONE, ciphers=\"^$:,;?*'dorothyx\")\n                    s.connect(remote)\n\n    def test_algorithms(self):\n        # Issue #8484: all algorithms should be available when verifying a\n        # certificate.\n        # SHA256 was added in OpenSSL 0.9.8\n        if ssl.OPENSSL_VERSION_INFO < (0, 9, 8, 0, 15):\n            self.skipTest(\"SHA256 not available on %r\" % ssl.OPENSSL_VERSION)\n        # sha256.tbs-internet.com needs SNI to use the correct certificate\n        if not ssl.HAS_SNI:\n            self.skipTest(\"SNI needed for this test\")\n        # https://sha2.hboeck.de/ was used until 2011-01-08 (no route to host)\n        remote = (\"sha256.tbs-internet.com\", 443)\n        sha256_cert = os.path.join(os.path.dirname(__file__), \"sha256.pem\")\n        with support.transient_internet(\"sha256.tbs-internet.com\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(sha256_cert)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"sha256.tbs-internet.com\")\n            try:\n                s.connect(remote)\n                if support.verbose:\n                    sys.stdout.write(\"\\nCipher with %r is %r\\n\" %\n                                     (remote, s.cipher()))\n                    sys.stdout.write(\"Certificate is:\\n%s\\n\" %\n                                     pprint.pformat(s.getpeercert()))\n            finally:\n                s.close()\n\n    def test_get_ca_certs_capath(self):\n        # capath certs are loaded on request\n        with support.transient_internet(\"svn.python.org\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=CAPATH)\n            self.assertEqual(ctx.get_ca_certs(), [])\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n            self.assertEqual(len(ctx.get_ca_certs()), 1)\n\n\ntry:\n    import threading\nexcept ImportError:\n    _have_threads = False\nelse:\n    _have_threads = True\n\n    from test.ssl_servers import make_https_server\n\n    class ThreadedEchoServer(threading.Thread):\n\n        class ConnectionHandler(threading.Thread):\n\n            \"\"\"A mildly complicated class, because we want it to work both\n            with and without the SSL wrapper around the socket connection, so\n            that we can test the STARTTLS functionality.\"\"\"\n\n            def __init__(self, server, connsock, addr):\n                self.server = server\n                self.running = False\n                self.sock = connsock\n                self.addr = addr\n                self.sock.setblocking(1)\n                self.sslconn = None\n                threading.Thread.__init__(self)\n                self.daemon = True\n\n            def wrap_conn(self):\n                try:\n                    self.sslconn = self.server.context.wrap_socket(\n                        self.sock, server_side=True)\n                    self.server.selected_protocols.append(self.sslconn.selected_npn_protocol())\n                except (ssl.SSLError, ConnectionResetError) as e:\n                    # We treat ConnectionResetError as though it were an\n                    # SSLError - OpenSSL on Ubuntu abruptly closes the\n                    # connection when asked to use an unsupported protocol.\n                    #\n                    # XXX Various errors can have happened here, for example\n                    # a mismatching protocol version, an invalid certificate,\n                    # or a low-level bug. This should be made more discriminating.\n                    self.server.conn_errors.append(e)\n                    if self.server.chatty:\n                        handle_error(\"\\n server:  bad connection attempt from \" + repr(self.addr) + \":\\n\")\n                    self.running = False\n                    self.server.stop()\n                    self.close()\n                    return False\n                else:\n                    if self.server.context.verify_mode == ssl.CERT_REQUIRED:\n                        cert = self.sslconn.getpeercert()\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" client cert is \" + pprint.pformat(cert) + \"\\n\")\n                        cert_binary = self.sslconn.getpeercert(True)\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" cert binary is \" + str(len(cert_binary)) + \" bytes\\n\")\n                    cipher = self.sslconn.cipher()\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" server: connection cipher is now \" + str(cipher) + \"\\n\")\n                        sys.stdout.write(\" server: selected protocol is now \"\n                                + str(self.sslconn.selected_npn_protocol()) + \"\\n\")\n                    return True\n\n            def read(self):\n                if self.sslconn:\n                    return self.sslconn.read()\n                else:\n                    return self.sock.recv(1024)\n\n            def write(self, bytes):\n                if self.sslconn:\n                    return self.sslconn.write(bytes)\n                else:\n                    return self.sock.send(bytes)\n\n            def close(self):\n                if self.sslconn:\n                    self.sslconn.close()\n                else:\n                    self.sock.close()\n\n            def run(self):\n                self.running = True\n                if not self.server.starttls_server:\n                    if not self.wrap_conn():\n                        return\n                while self.running:\n                    try:\n                        msg = self.read()\n                        stripped = msg.strip()\n                        if not stripped:\n                            # eof, so quit this handler\n                            self.running = False\n                            self.close()\n                        elif stripped == b'over':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: client closed connection\\n\")\n                            self.close()\n                            return\n                        elif (self.server.starttls_server and\n                              stripped == b'STARTTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read STARTTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            if not self.wrap_conn():\n                                return\n                        elif (self.server.starttls_server and self.sslconn\n                              and stripped == b'ENDTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read ENDTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            self.sock = self.sslconn.unwrap()\n                            self.sslconn = None\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: connection is now unencrypted...\\n\")\n                        elif stripped == b'CB tls-unique':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read CB tls-unique from client, sending our CB data...\\n\")\n                            data = self.sslconn.get_channel_binding(\"tls-unique\")\n                            self.write(repr(data).encode(\"us-ascii\") + b\"\\n\")\n                        else:\n                            if (support.verbose and\n                                self.server.connectionchatty):\n                                ctype = (self.sslconn and \"encrypted\") or \"unencrypted\"\n                                sys.stdout.write(\" server: read %r (%s), sending back %r (%s)...\\n\"\n                                                 % (msg, ctype, msg.lower(), ctype))\n                            self.write(msg.lower())\n                    except OSError:\n                        if self.server.chatty:\n                            handle_error(\"Test server failure:\\n\")\n                        self.close()\n                        self.running = False\n                        # normally, we'd just stop here, but for the test\n                        # harness, we want to stop the server\n                        self.server.stop()\n\n        def __init__(self, certificate=None, ssl_version=None,\n                     certreqs=None, cacerts=None,\n                     chatty=True, connectionchatty=False, starttls_server=False,\n                     npn_protocols=None, ciphers=None, context=None):\n            if context:\n                self.context = context\n            else:\n                self.context = ssl.SSLContext(ssl_version\n                                              if ssl_version is not None\n                                              else ssl.PROTOCOL_TLSv1)\n                self.context.verify_mode = (certreqs if certreqs is not None\n                                            else ssl.CERT_NONE)\n                if cacerts:\n                    self.context.load_verify_locations(cacerts)\n                if certificate:\n                    self.context.load_cert_chain(certificate)\n                if npn_protocols:\n                    self.context.set_npn_protocols(npn_protocols)\n                if ciphers:\n                    self.context.set_ciphers(ciphers)\n            self.chatty = chatty\n            self.connectionchatty = connectionchatty\n            self.starttls_server = starttls_server\n            self.sock = socket.socket()\n            self.port = support.bind_port(self.sock)\n            self.flag = None\n            self.active = False\n            self.selected_protocols = []\n            self.conn_errors = []\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            self.stop()\n            self.join()\n\n        def start(self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.sock.settimeout(0.05)\n            self.sock.listen(5)\n            self.active = True\n            if self.flag:\n                # signal an event\n                self.flag.set()\n            while self.active:\n                try:\n                    newconn, connaddr = self.sock.accept()\n                    if support.verbose and self.chatty:\n                        sys.stdout.write(' server:  new connection from '\n                                         + repr(connaddr) + '\\n')\n                    handler = self.ConnectionHandler(self, newconn, connaddr)\n                    handler.start()\n                    handler.join()\n                except socket.timeout:\n                    pass\n                except KeyboardInterrupt:\n                    self.stop()\n            self.sock.close()\n\n        def stop(self):\n            self.active = False\n\n    class AsyncoreEchoServer(threading.Thread):\n\n        # this one's based on asyncore.dispatcher\n\n        class EchoServer (asyncore.dispatcher):\n\n            class ConnectionHandler (asyncore.dispatcher_with_send):\n\n                def __init__(self, conn, certfile):\n                    self.socket = ssl.wrap_socket(conn, server_side=True,\n                                                  certfile=certfile,\n                                                  do_handshake_on_connect=False)\n                    asyncore.dispatcher_with_send.__init__(self, self.socket)\n                    self._ssl_accepting = True\n                    self._do_ssl_handshake()\n\n                def readable(self):\n                    if isinstance(self.socket, ssl.SSLSocket):\n                        while self.socket.pending() > 0:\n                            self.handle_read_event()\n                    return True\n\n                def _do_ssl_handshake(self):\n                    try:\n                        self.socket.do_handshake()\n                    except (ssl.SSLWantReadError, ssl.SSLWantWriteError):\n                        return\n                    except ssl.SSLEOFError:\n                        return self.handle_close()\n                    except ssl.SSLError:\n                        raise\n                    except OSError as err:\n                        if err.args[0] == errno.ECONNABORTED:\n                            return self.handle_close()\n                    else:\n                        self._ssl_accepting = False\n\n                def handle_read(self):\n                    if self._ssl_accepting:\n                        self._do_ssl_handshake()\n                    else:\n                        data = self.recv(1024)\n                        if support.verbose:\n                            sys.stdout.write(\" server:  read %s from client\\n\" % repr(data))\n                        if not data:\n                            self.close()\n                        else:\n                            self.send(data.lower())\n\n                def handle_close(self):\n                    self.close()\n                    if support.verbose:\n                        sys.stdout.write(\" server:  closed connection %s\\n\" % self.socket)\n\n                def handle_error(self):\n                    raise\n\n            def __init__(self, certfile):\n                self.certfile = certfile\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.port = support.bind_port(sock, '')\n                asyncore.dispatcher.__init__(self, sock)\n                self.listen(5)\n\n            def handle_accepted(self, sock_obj, addr):\n                if support.verbose:\n                    sys.stdout.write(\" server:  new connection from %s:%s\\n\" %addr)\n                self.ConnectionHandler(sock_obj, self.certfile)\n\n            def handle_error(self):\n                raise\n\n        def __init__(self, certfile):\n            self.flag = None\n            self.active = False\n            self.server = self.EchoServer(certfile)\n            self.port = self.server.port\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __str__(self):\n            return \"<%s %s>\" % (self.__class__.__name__, self.server)\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            if support.verbose:\n                sys.stdout.write(\" cleanup: stopping server.\\n\")\n            self.stop()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: joining server thread.\\n\")\n            self.join()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: successfully joined.\\n\")\n\n        def start (self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.active = True\n            if self.flag:\n                self.flag.set()\n            while self.active:\n                try:\n                    asyncore.loop(1)\n                except:\n                    pass\n\n        def stop(self):\n            self.active = False\n            self.server.close()\n\n    def bad_cert_test(certfile):\n        \"\"\"\n        Launch a server with CERT_REQUIRED, and check that trying to\n        connect to it with the given client certificate fails.\n        \"\"\"\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_REQUIRED,\n                                    cacerts=CERTFILE, chatty=False,\n                                    connectionchatty=False)\n        with server:\n            try:\n                with socket.socket() as sock:\n                    s = ssl.wrap_socket(sock,\n                                        certfile=certfile,\n                                        ssl_version=ssl.PROTOCOL_TLSv1)\n                    s.connect((HOST, server.port))\n            except ssl.SSLError as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nSSLError is %s\\n\" % x.args[1])\n            except OSError as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nOSError is %s\\n\" % x.args[1])\n            except OSError as x:\n                if x.errno != errno.ENOENT:\n                    raise\n                if support.verbose:\n                    sys.stdout.write(\"\\OSError is %s\\n\" % str(x))\n            else:\n                raise AssertionError(\"Use of invalid cert should have failed!\")\n\n    def server_params_test(client_context, server_context, indata=b\"FOO\\n\",\n                           chatty=True, connectionchatty=False, sni_name=None):\n        \"\"\"\n        Launch a server, connect a client to it and try various reads\n        and writes.\n        \"\"\"\n        stats = {}\n        server = ThreadedEchoServer(context=server_context,\n                                    chatty=chatty,\n                                    connectionchatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                    server_hostname=sni_name) as s:\n                s.connect((HOST, server.port))\n                for arg in [indata, bytearray(indata), memoryview(indata)]:\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  sending %r...\\n\" % indata)\n                    s.write(arg)\n                    outdata = s.read()\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                    if outdata != indata.lower():\n                        raise AssertionError(\n                            \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                            % (outdata[:20], len(outdata),\n                               indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\" client:  closing connection.\\n\")\n                stats.update({\n                    'compression': s.compression(),\n                    'cipher': s.cipher(),\n                    'peercert': s.getpeercert(),\n                    'client_npn_protocol': s.selected_npn_protocol()\n                })\n                s.close()\n            stats['server_npn_protocols'] = server.selected_protocols\n        return stats\n\n    def try_protocol_combo(server_protocol, client_protocol, expect_success,\n                           certsreqs=None, server_options=0, client_options=0):\n        if certsreqs is None:\n            certsreqs = ssl.CERT_NONE\n        certtype = {\n            ssl.CERT_NONE: \"CERT_NONE\",\n            ssl.CERT_OPTIONAL: \"CERT_OPTIONAL\",\n            ssl.CERT_REQUIRED: \"CERT_REQUIRED\",\n        }[certsreqs]\n        if support.verbose:\n            formatstr = (expect_success and \" %s->%s %s\\n\") or \" {%s->%s} %s\\n\"\n            sys.stdout.write(formatstr %\n                             (ssl.get_protocol_name(client_protocol),\n                              ssl.get_protocol_name(server_protocol),\n                              certtype))\n        client_context = ssl.SSLContext(client_protocol)\n        client_context.options = ssl.OP_ALL | client_options\n        server_context = ssl.SSLContext(server_protocol)\n        server_context.options = ssl.OP_ALL | server_options\n\n        # NOTE: we must enable \"ALL\" ciphers on the client, otherwise an\n        # SSLv23 client will send an SSLv3 hello (rather than SSLv2)\n        # starting from OpenSSL 1.0.0 (see issue #8322).\n        if client_context.protocol == ssl.PROTOCOL_SSLv23:\n            client_context.set_ciphers(\"ALL\")\n\n        for ctx in (client_context, server_context):\n            ctx.verify_mode = certsreqs\n            ctx.load_cert_chain(CERTFILE)\n            ctx.load_verify_locations(CERTFILE)\n        try:\n            server_params_test(client_context, server_context,\n                               chatty=False, connectionchatty=False)\n        # Protocol mismatch can result in either an SSLError, or a\n        # \"Connection reset by peer\" error.\n        except ssl.SSLError:\n            if expect_success:\n                raise\n        except OSError as e:\n            if expect_success or e.errno != errno.ECONNRESET:\n                raise\n        else:\n            if not expect_success:\n                raise AssertionError(\n                    \"Client protocol %s succeeded with server protocol %s!\"\n                    % (ssl.get_protocol_name(client_protocol),\n                       ssl.get_protocol_name(server_protocol)))\n\n\n    class ThreadedTests(unittest.TestCase):\n\n        @skip_if_broken_ubuntu_ssl\n        def test_echo(self):\n            \"\"\"Basic test of an SSL client connecting to a server\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            for protocol in PROTOCOLS:\n                with self.subTest(protocol=ssl._PROTOCOL_NAMES[protocol]):\n                    context = ssl.SSLContext(protocol)\n                    context.load_cert_chain(CERTFILE)\n                    server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n\n        def test_getpeercert(self):\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = ThreadedEchoServer(context=context, chatty=False)\n            with server:\n                s = context.wrap_socket(socket.socket())\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()\n                if support.verbose:\n                    sys.stdout.write(pprint.pformat(cert) + '\\n')\n                    sys.stdout.write(\"Connection cipher is \" + str(cipher) + '.\\n')\n                if 'subject' not in cert:\n                    self.fail(\"No subject field in certificate: %s.\" %\n                              pprint.pformat(cert))\n                if ((('organizationName', 'Python Software Foundation'),)\n                    not in cert['subject']):\n                    self.fail(\n                        \"Missing or invalid 'organizationName' field in certificate subject; \"\n                        \"should be 'Python Software Foundation'.\")\n                self.assertIn('notBefore', cert)\n                self.assertIn('notAfter', cert)\n                before = ssl.cert_time_to_seconds(cert['notBefore'])\n                after = ssl.cert_time_to_seconds(cert['notAfter'])\n                self.assertLess(before, after)\n                s.close()\n\n        def test_empty_cert(self):\n            \"\"\"Connecting with an empty cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                      \"nullcert.pem\"))\n        def test_malformed_cert(self):\n            \"\"\"Connecting with a badly formatted certificate (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badcert.pem\"))\n        def test_nonexisting_cert(self):\n            \"\"\"Connecting with a non-existing cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"wrongcert.pem\"))\n        def test_malformed_key(self):\n            \"\"\"Connecting with a badly formatted key (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badkey.pem\"))\n\n        def test_rude_shutdown(self):\n            \"\"\"A brutal shutdown of an SSL server should raise an OSError\n            in the client when attempting handshake.\n            \"\"\"\n            listener_ready = threading.Event()\n            listener_gone = threading.Event()\n\n            s = socket.socket()\n            port = support.bind_port(s, HOST)\n\n            # `listener` runs in a thread.  It sits in an accept() until\n            # the main thread connects.  Then it rudely closes the socket,\n            # and sets Event `listener_gone` to let the main thread know\n            # the socket is gone.\n            def listener():\n                s.listen(5)\n                listener_ready.set()\n                newsock, addr = s.accept()\n                newsock.close()\n                s.close()\n                listener_gone.set()\n\n            def connector():\n                listener_ready.wait()\n                with socket.socket() as c:\n                    c.connect((HOST, port))\n                    listener_gone.wait()\n                    try:\n                        ssl_sock = ssl.wrap_socket(c)\n                    except OSError:\n                        pass\n                    else:\n                        self.fail('connecting to closed SSL socket should have failed')\n\n            t = threading.Thread(target=listener)\n            t.start()\n            try:\n                connector()\n            finally:\n                t.join()\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv2'),\n                             \"OpenSSL is compiled without SSLv2 support\")\n        def test_protocol_sslv2(self):\n            \"\"\"Connecting to an SSLv2 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLSv1, False)\n            # SSLv23 client with specific SSL options\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, False,\n                                   client_options=ssl.OP_NO_SSLv2)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv23(self):\n            \"\"\"Connecting to an SSLv23 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try:\n                    try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv2, True)\n                except OSError as x:\n                    # this fails on some older versions of OpenSSL (0.9.7l, for instance)\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" SSL2 client to SSL23 server test unexpectedly failed:\\n %s\\n\"\n                            % str(x))\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n\n            # Server with specific SSL options\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, False,\n                               server_options=ssl.OP_NO_SSLv3)\n            # Will choose TLSv1\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True,\n                               server_options=ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, False,\n                               server_options=ssl.OP_NO_TLSv1)\n\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv3(self):\n            \"\"\"Connecting to an SSLv3 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLSv1, False)\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, True,\n                                   client_options=ssl.OP_NO_SSLv2)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_tlsv1(self):\n            \"\"\"Connecting to a TLSv1 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, \"PROTOCOL_TLSv1_1\"),\n                             \"TLS version 1.1 not supported.\")\n        def test_protocol_tlsv1_1(self):\n            \"\"\"Connecting to a TLSv1.1 server with various client options.\n               Testing against older TLS versions.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1_1, True)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1_1)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1_1, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1_1, False)\n\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, \"PROTOCOL_TLSv1_2\"),\n                             \"TLS version 1.2 not supported.\")\n        def test_protocol_tlsv1_2(self):\n            \"\"\"Connecting to a TLSv1.2 server with various client options.\n               Testing against older TLS versions.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1_2, True,\n                               server_options=ssl.OP_NO_SSLv3|ssl.OP_NO_SSLv2,\n                               client_options=ssl.OP_NO_SSLv3|ssl.OP_NO_SSLv2,)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1_2)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1_2, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1_2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1_1, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1_2, False)\n\n        def test_starttls(self):\n            \"\"\"Switching from clear text to encrypted and back again.\"\"\"\n            msgs = (b\"msg 1\", b\"MSG 2\", b\"STARTTLS\", b\"MSG 3\", b\"msg 4\", b\"ENDTLS\", b\"msg 5\", b\"msg 6\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        starttls_server=True,\n                                        chatty=True,\n                                        connectionchatty=True)\n            wrapped = False\n            with server:\n                s = socket.socket()\n                s.setblocking(1)\n                s.connect((HOST, server.port))\n                if support.verbose:\n                    sys.stdout.write(\"\\n\")\n                for indata in msgs:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  sending %r...\\n\" % indata)\n                    if wrapped:\n                        conn.write(indata)\n                        outdata = conn.read()\n                    else:\n                        s.send(indata)\n                        outdata = s.recv(1024)\n                    msg = outdata.strip().lower()\n                    if indata == b\"STARTTLS\" and msg.startswith(b\"ok\"):\n                        # STARTTLS ok, switch to secure mode\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, starting TLS...\\n\"\n                                % msg)\n                        conn = ssl.wrap_socket(s, ssl_version=ssl.PROTOCOL_TLSv1)\n                        wrapped = True\n                    elif indata == b\"ENDTLS\" and msg.startswith(b\"ok\"):\n                        # ENDTLS ok, switch back to clear text\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, ending TLS...\\n\"\n                                % msg)\n                        s = conn.unwrap()\n                        wrapped = False\n                    else:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server\\n\" % msg)\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                if wrapped:\n                    conn.write(b\"over\\n\")\n                else:\n                    s.send(b\"over\\n\")\n                if wrapped:\n                    conn.close()\n                else:\n                    s.close()\n\n        def test_socketserver(self):\n            \"\"\"Using a SocketServer to create and manage SSL connections.\"\"\"\n            server = make_https_server(self, certfile=CERTFILE)\n            # try to connect\n            if support.verbose:\n                sys.stdout.write('\\n')\n            with open(CERTFILE, 'rb') as f:\n                d1 = f.read()\n            d2 = ''\n            # now fetch the same data from the HTTPS server\n            url = 'https://%s:%d/%s' % (\n                HOST, server.port, os.path.split(CERTFILE)[1])\n            f = urllib.request.urlopen(url)\n            try:\n                dlen = f.info().get(\"content-length\")\n                if dlen and (int(dlen) > 0):\n                    d2 = f.read(int(dlen))\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client: read %d bytes from remote server '%s'\\n\"\n                            % (len(d2), server))\n            finally:\n                f.close()\n            self.assertEqual(d1, d2)\n\n        def test_asyncore_server(self):\n            \"\"\"Check the example asyncore integration.\"\"\"\n            indata = \"TEST MESSAGE of mixed case\\n\"\n\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            indata = b\"FOO\\n\"\n            server = AsyncoreEchoServer(CERTFILE)\n            with server:\n                s = ssl.wrap_socket(socket.socket())\n                s.connect(('127.0.0.1', server.port))\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client:  sending %r...\\n\" % indata)\n                s.write(indata)\n                outdata = s.read()\n                if support.verbose:\n                    sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                if outdata != indata.lower():\n                    self.fail(\n                        \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                        % (outdata[:20], len(outdata),\n                           indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                s.close()\n                if support.verbose:\n                    sys.stdout.write(\" client:  connection closed.\\n\")\n\n        def test_recv_send(self):\n            \"\"\"Test recv(), send() and friends.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # helper methods for standardising recv* method signatures\n                def _recv_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count = s.recv_into(b)\n                    return b[:count]\n\n                def _recvfrom_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count, addr = s.recvfrom_into(b)\n                    return b[:count]\n\n                # (name, method, whether to expect success, *args)\n                send_methods = [\n                    ('send', s.send, True, []),\n                    ('sendto', s.sendto, False, [\"some.address\"]),\n                    ('sendall', s.sendall, True, []),\n                ]\n                recv_methods = [\n                    ('recv', s.recv, True, []),\n                    ('recvfrom', s.recvfrom, False, [\"some.address\"]),\n                    ('recv_into', _recv_into, True, []),\n                    ('recvfrom_into', _recvfrom_into, False, []),\n                ]\n                data_prefix = \"PREFIX_\"\n\n                for meth_name, send_meth, expect_success, args in send_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        send_meth(indata, *args)\n                        outdata = s.read()\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While sending with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to send with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n\n                for meth_name, recv_meth, expect_success, args in recv_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        s.send(indata)\n                        outdata = recv_meth(*args)\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While receiving with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to receive with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n                        # consume data\n                        s.read()\n\n                # Make sure sendmsg et al are disallowed to avoid\n                # inadvertent disclosure of data and/or corruption\n                # of the encrypted data stream\n                self.assertRaises(NotImplementedError, s.sendmsg, [b\"data\"])\n                self.assertRaises(NotImplementedError, s.recvmsg, 100)\n                self.assertRaises(NotImplementedError,\n                                  s.recvmsg_into, bytearray(100))\n\n                s.write(b\"over\\n\")\n                s.close()\n\n        def test_handshake_timeout(self):\n            # Issue #5103: SSL handshake must respect the socket timeout\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            started = threading.Event()\n            finish = False\n\n            def serve():\n                server.listen(5)\n                started.set()\n                conns = []\n                while not finish:\n                    r, w, e = select.select([server], [], [], 0.1)\n                    if server in r:\n                        # Let the socket hang around rather than having\n                        # it closed by garbage collection.\n                        conns.append(server.accept()[0])\n                for sock in conns:\n                    sock.close()\n\n            t = threading.Thread(target=serve)\n            t.start()\n            started.wait()\n\n            try:\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c.settimeout(0.2)\n                    c.connect((host, port))\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           ssl.wrap_socket, c)\n                finally:\n                    c.close()\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c = ssl.wrap_socket(c)\n                    c.settimeout(0.2)\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           c.connect, (host, port))\n                finally:\n                    c.close()\n            finally:\n                finish = True\n                t.join()\n                server.close()\n\n        def test_server_accept(self):\n            # Issue #16357: accept() on a SSLSocket created through\n            # SSLContext.wrap_socket().\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            server = context.wrap_socket(server, server_side=True)\n\n            evt = threading.Event()\n            remote = None\n            peer = None\n            def serve():\n                nonlocal remote, peer\n                server.listen(5)\n                # Block on the accept and wait on the connection to close.\n                evt.set()\n                remote, peer = server.accept()\n                remote.recv(1)\n\n            t = threading.Thread(target=serve)\n            t.start()\n            # Client wait until server setup and perform a connect.\n            evt.wait()\n            client = context.wrap_socket(socket.socket())\n            client.connect((host, port))\n            client_addr = client.getsockname()\n            client.close()\n            t.join()\n            remote.close()\n            server.close()\n            # Sanity checks.\n            self.assertIsInstance(remote, ssl.SSLSocket)\n            self.assertEqual(peer, client_addr)\n\n        def test_getpeercert_enotconn(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            with context.wrap_socket(socket.socket()) as sock:\n                with self.assertRaises(OSError) as cm:\n                    sock.getpeercert()\n                self.assertEqual(cm.exception.errno, errno.ENOTCONN)\n\n        def test_do_handshake_enotconn(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            with context.wrap_socket(socket.socket()) as sock:\n                with self.assertRaises(OSError) as cm:\n                    sock.do_handshake()\n                self.assertEqual(cm.exception.errno, errno.ENOTCONN)\n\n        def test_default_ciphers(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            try:\n                # Force a set of weak ciphers on our client context\n                context.set_ciphers(\"DES\")\n            except ssl.SSLError:\n                self.skipTest(\"no DES cipher available\")\n            with ThreadedEchoServer(CERTFILE,\n                                    ssl_version=ssl.PROTOCOL_SSLv23,\n                                    chatty=False) as server:\n                with context.wrap_socket(socket.socket()) as s:\n                    with self.assertRaises(OSError):\n                        s.connect((HOST, server.port))\n            self.assertIn(\"no shared cipher\", str(server.conn_errors[0]))\n\n        @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                             \"'tls-unique' channel binding not available\")\n        def test_tls_unique_channel_binding(self):\n            \"\"\"Test tls-unique channel binding.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # get the data\n                cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\" got channel binding data: {0!r}\\n\"\n                                     .format(cb_data))\n\n                # check if it is sane\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n\n                # and compare with the peers version\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(cb_data).encode(\"us-ascii\"))\n                s.close()\n\n                # now, again\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                new_cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\" got another channel binding data: {0!r}\\n\"\n                                     .format(new_cb_data))\n                # is it really unique\n                self.assertNotEqual(cb_data, new_cb_data)\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(new_cb_data).encode(\"us-ascii\"))\n                s.close()\n\n        def test_compression(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            if support.verbose:\n                sys.stdout.write(\" got compression: {!r}\\n\".format(stats['compression']))\n            self.assertIn(stats['compression'], { None, 'ZLIB', 'RLE' })\n\n        @unittest.skipUnless(hasattr(ssl, 'OP_NO_COMPRESSION'),\n                             \"ssl.OP_NO_COMPRESSION needed for this test\")\n        def test_compression_disabled(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            context.options |= ssl.OP_NO_COMPRESSION\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            self.assertIs(stats['compression'], None)\n\n        def test_dh_params(self):\n            # Check we can get a connection with ephemeral Diffie-Hellman\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            context.load_dh_params(DHFILE)\n            context.set_ciphers(\"kEDH\")\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            cipher = stats[\"cipher\"][0]\n            parts = cipher.split(\"-\")\n            if \"ADH\" not in parts and \"EDH\" not in parts and \"DHE\" not in parts:\n                self.fail(\"Non-DH cipher: \" + cipher[0])\n\n        def test_selected_npn_protocol(self):\n            # selected_npn_protocol() is None unless NPN is used\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            self.assertIs(stats['client_npn_protocol'], None)\n\n        @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")\n        def test_npn_protocols(self):\n            server_protocols = ['http/1.1', 'spdy/2']\n            protocol_tests = [\n                (['http/1.1', 'spdy/2'], 'http/1.1'),\n                (['spdy/2', 'http/1.1'], 'http/1.1'),\n                (['spdy/2', 'test'], 'spdy/2'),\n                (['abc', 'def'], 'abc')\n            ]\n            for client_protocols, expected in protocol_tests:\n                server_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n                server_context.load_cert_chain(CERTFILE)\n                server_context.set_npn_protocols(server_protocols)\n                client_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n                client_context.load_cert_chain(CERTFILE)\n                client_context.set_npn_protocols(client_protocols)\n                stats = server_params_test(client_context, server_context,\n                                           chatty=True, connectionchatty=True)\n\n                msg = \"failed trying %s (s) and %s (c).\\n\" \\\n                      \"was expecting %s, but got %%s from the %%s\" \\\n                          % (str(server_protocols), str(client_protocols),\n                             str(expected))\n                client_result = stats['client_npn_protocol']\n                self.assertEqual(client_result, expected, msg % (client_result, \"client\"))\n                server_result = stats['server_npn_protocols'][-1] \\\n                    if len(stats['server_npn_protocols']) else 'nothing'\n                self.assertEqual(server_result, expected, msg % (server_result, \"server\"))\n\n        def sni_contexts(self):\n            server_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            server_context.load_cert_chain(SIGNED_CERTFILE)\n            other_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            other_context.load_cert_chain(SIGNED_CERTFILE2)\n            client_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            client_context.verify_mode = ssl.CERT_REQUIRED\n            client_context.load_verify_locations(SIGNING_CA)\n            return server_context, other_context, client_context\n\n        def check_common_name(self, stats, name):\n            cert = stats['peercert']\n            self.assertIn((('commonName', name),), cert['subject'])\n\n        @needs_sni\n        def test_sni_callback(self):\n            calls = []\n            server_context, other_context, client_context = self.sni_contexts()\n\n            def servername_cb(ssl_sock, server_name, initial_context):\n                calls.append((server_name, initial_context))\n                if server_name is not None:\n                    ssl_sock.context = other_context\n            server_context.set_servername_callback(servername_cb)\n\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True,\n                                       sni_name='supermessage')\n            # The hostname was fetched properly, and the certificate was\n            # changed for the connection.\n            self.assertEqual(calls, [(\"supermessage\", server_context)])\n            # CERTFILE4 was selected\n            self.check_common_name(stats, 'fakehostname')\n\n            calls = []\n            # The callback is called with server_name=None\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True,\n                                       sni_name=None)\n            self.assertEqual(calls, [(None, server_context)])\n            self.check_common_name(stats, 'localhost')\n\n            # Check disabling the callback\n            calls = []\n            server_context.set_servername_callback(None)\n\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True,\n                                       sni_name='notfunny')\n            # Certificate didn't change\n            self.check_common_name(stats, 'localhost')\n            self.assertEqual(calls, [])\n\n        @needs_sni\n        def test_sni_callback_alert(self):\n            # Returning a TLS alert is reflected to the connecting client\n            server_context, other_context, client_context = self.sni_contexts()\n\n            def cb_returning_alert(ssl_sock, server_name, initial_context):\n                return ssl.ALERT_DESCRIPTION_ACCESS_DENIED\n            server_context.set_servername_callback(cb_returning_alert)\n\n            with self.assertRaises(ssl.SSLError) as cm:\n                stats = server_params_test(client_context, server_context,\n                                           chatty=False,\n                                           sni_name='supermessage')\n            self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_ACCESS_DENIED')\n\n        @needs_sni\n        def test_sni_callback_raising(self):\n            # Raising fails the connection with a TLS handshake failure alert.\n            server_context, other_context, client_context = self.sni_contexts()\n\n            def cb_raising(ssl_sock, server_name, initial_context):\n                1/0\n            server_context.set_servername_callback(cb_raising)\n\n            with self.assertRaises(ssl.SSLError) as cm, \\\n                 support.captured_stderr() as stderr:\n                stats = server_params_test(client_context, server_context,\n                                           chatty=False,\n                                           sni_name='supermessage')\n            self.assertEqual(cm.exception.reason, 'SSLV3_ALERT_HANDSHAKE_FAILURE')\n            self.assertIn(\"ZeroDivisionError\", stderr.getvalue())\n\n        @needs_sni\n        def test_sni_callback_wrong_return_type(self):\n            # Returning the wrong return type terminates the TLS connection\n            # with an internal error alert.\n            server_context, other_context, client_context = self.sni_contexts()\n\n            def cb_wrong_return_type(ssl_sock, server_name, initial_context):\n                return \"foo\"\n            server_context.set_servername_callback(cb_wrong_return_type)\n\n            with self.assertRaises(ssl.SSLError) as cm, \\\n                 support.captured_stderr() as stderr:\n                stats = server_params_test(client_context, server_context,\n                                           chatty=False,\n                                           sni_name='supermessage')\n            self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_INTERNAL_ERROR')\n            self.assertIn(\"TypeError\", stderr.getvalue())\n\n        def test_read_write_after_close_raises_valuerror(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = ThreadedEchoServer(context=context, chatty=False)\n\n            with server:\n                s = context.wrap_socket(socket.socket())\n                s.connect((HOST, server.port))\n                s.close()\n\n                self.assertRaises(ValueError, s.read, 1024)\n                self.assertRaises(ValueError, s.write, b'hello')\n\n\ndef test_main(verbose=False):\n    if support.verbose:\n        plats = {\n            'Linux': platform.linux_distribution,\n            'Mac': platform.mac_ver,\n            'Windows': platform.win32_ver,\n        }\n        for name, func in plats.items():\n            plat = func()\n            if plat and plat[0]:\n                plat = '%s %r' % (name, plat)\n                break\n        else:\n            plat = repr(platform.platform())\n        print(\"test_ssl: testing with %r %r\" %\n            (ssl.OPENSSL_VERSION, ssl.OPENSSL_VERSION_INFO))\n        print(\"          under %s\" % plat)\n        print(\"          HAS_SNI = %r\" % ssl.HAS_SNI)\n        print(\"          OP_ALL = 0x%8x\" % ssl.OP_ALL)\n        try:\n            print(\"          OP_NO_TLSv1_1 = 0x%8x\" % ssl.OP_NO_TLSv1_1)\n        except AttributeError:\n            pass\n\n    for filename in [\n        CERTFILE, SVN_PYTHON_ORG_ROOT_CERT, BYTES_CERTFILE,\n        ONLYCERT, ONLYKEY, BYTES_ONLYCERT, BYTES_ONLYKEY,\n        SIGNED_CERTFILE, SIGNED_CERTFILE2, SIGNING_CA,\n        BADCERT, BADKEY, EMPTYCERT]:\n        if not os.path.exists(filename):\n            raise support.TestFailed(\"Can't read certificate file %r\" % filename)\n\n    tests = [ContextTests, BasicSocketTests, SSLErrorTests]\n\n    if support.is_resource_enabled('network'):\n        tests.append(NetworkedTests)\n\n    if _have_threads:\n        thread_info = support.threading_setup()\n        if thread_info:\n            tests.append(ThreadedTests)\n\n    try:\n        support.run_unittest(*tests)\n    finally:\n        if _have_threads:\n            support.threading_cleanup(*thread_info)\n\nif __name__ == \"__main__\":\n    test_main()\n",
    "code_after": "# Test the support for SSL and sockets\n\nimport sys\nimport unittest\nfrom test import support\nimport socket\nimport select\nimport time\nimport datetime\nimport gc\nimport os\nimport errno\nimport pprint\nimport tempfile\nimport urllib.request\nimport traceback\nimport asyncore\nimport weakref\nimport platform\nimport functools\nfrom unittest import mock\n\nssl = support.import_module(\"ssl\")\n\nPROTOCOLS = sorted(ssl._PROTOCOL_NAMES)\nHOST = support.HOST\n\ndata_file = lambda name: os.path.join(os.path.dirname(__file__), name)\n\n# The custom key and certificate files used in test_ssl are generated\n# using Lib/test/make_ssl_certs.py.\n# Other certificates are simply fetched from the Internet servers they\n# are meant to authenticate.\n\nCERTFILE = data_file(\"keycert.pem\")\nBYTES_CERTFILE = os.fsencode(CERTFILE)\nONLYCERT = data_file(\"ssl_cert.pem\")\nONLYKEY = data_file(\"ssl_key.pem\")\nBYTES_ONLYCERT = os.fsencode(ONLYCERT)\nBYTES_ONLYKEY = os.fsencode(ONLYKEY)\nCERTFILE_PROTECTED = data_file(\"keycert.passwd.pem\")\nONLYKEY_PROTECTED = data_file(\"ssl_key.passwd.pem\")\nKEY_PASSWORD = \"somepass\"\nCAPATH = data_file(\"capath\")\nBYTES_CAPATH = os.fsencode(CAPATH)\n\n# Two keys and certs signed by the same CA (for SNI tests)\nSIGNED_CERTFILE = data_file(\"keycert3.pem\")\nSIGNED_CERTFILE2 = data_file(\"keycert4.pem\")\nSIGNING_CA = data_file(\"pycacert.pem\")\n\nSVN_PYTHON_ORG_ROOT_CERT = data_file(\"https_svn_python_org_root.pem\")\n\nEMPTYCERT = data_file(\"nullcert.pem\")\nBADCERT = data_file(\"badcert.pem\")\nWRONGCERT = data_file(\"XXXnonexisting.pem\")\nBADKEY = data_file(\"badkey.pem\")\nNOKIACERT = data_file(\"nokia.pem\")\nNULLBYTECERT = data_file(\"nullbytecert.pem\")\n\nDHFILE = data_file(\"dh512.pem\")\nBYTES_DHFILE = os.fsencode(DHFILE)\n\n\ndef handle_error(prefix):\n    exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))\n    if support.verbose:\n        sys.stdout.write(prefix + exc_format)\n\ndef can_clear_options():\n    # 0.9.8m or higher\n    return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)\n\ndef no_sslv2_implies_sslv3_hello():\n    # 0.9.7h or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)\n\ndef asn1time(cert_time):\n    # Some versions of OpenSSL ignore seconds, see #18207\n    # 0.9.8.i\n    if ssl._OPENSSL_API_VERSION == (0, 9, 8, 9, 15):\n        fmt = \"%b %d %H:%M:%S %Y GMT\"\n        dt = datetime.datetime.strptime(cert_time, fmt)\n        dt = dt.replace(second=0)\n        cert_time = dt.strftime(fmt)\n        # %d adds leading zero but ASN1_TIME_print() uses leading space\n        if cert_time[4] == \"0\":\n            cert_time = cert_time[:4] + \" \" + cert_time[5:]\n\n    return cert_time\n\n# Issue #9415: Ubuntu hijacks their OpenSSL and forcefully disables SSLv2\ndef skip_if_broken_ubuntu_ssl(func):\n    if hasattr(ssl, 'PROTOCOL_SSLv2'):\n        @functools.wraps(func)\n        def f(*args, **kwargs):\n            try:\n                ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n            except ssl.SSLError:\n                if (ssl.OPENSSL_VERSION_INFO == (0, 9, 8, 15, 15) and\n                    platform.linux_distribution() == ('debian', 'squeeze/sid', '')):\n                    raise unittest.SkipTest(\"Patched Ubuntu OpenSSL breaks behaviour\")\n            return func(*args, **kwargs)\n        return f\n    else:\n        return func\n\nneeds_sni = unittest.skipUnless(ssl.HAS_SNI, \"SNI support needed for this test\")\n\n\nclass BasicSocketTests(unittest.TestCase):\n\n    def test_constants(self):\n        ssl.CERT_NONE\n        ssl.CERT_OPTIONAL\n        ssl.CERT_REQUIRED\n        ssl.OP_CIPHER_SERVER_PREFERENCE\n        ssl.OP_SINGLE_DH_USE\n        if ssl.HAS_ECDH:\n            ssl.OP_SINGLE_ECDH_USE\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0):\n            ssl.OP_NO_COMPRESSION\n        self.assertIn(ssl.HAS_SNI, {True, False})\n        self.assertIn(ssl.HAS_ECDH, {True, False})\n\n    def test_random(self):\n        v = ssl.RAND_status()\n        if support.verbose:\n            sys.stdout.write(\"\\n RAND_status is %d (%s)\\n\"\n                             % (v, (v and \"sufficient randomness\") or\n                                \"insufficient randomness\"))\n\n        data, is_cryptographic = ssl.RAND_pseudo_bytes(16)\n        self.assertEqual(len(data), 16)\n        self.assertEqual(is_cryptographic, v == 1)\n        if v:\n            data = ssl.RAND_bytes(16)\n            self.assertEqual(len(data), 16)\n        else:\n            self.assertRaises(ssl.SSLError, ssl.RAND_bytes, 16)\n\n        self.assertRaises(TypeError, ssl.RAND_egd, 1)\n        self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)\n        ssl.RAND_add(\"this is a random string\", 75.0)\n\n    def test_parse_cert(self):\n        # note that this uses an 'unofficial' function in _ssl.c,\n        # provided solely for this test, to exercise the certificate\n        # parsing code\n        p = ssl._ssl._test_decode_cert(CERTFILE)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['issuer'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        # Note the next three asserts will fail if the keys are regenerated\n        self.assertEqual(p['notAfter'], asn1time('Oct  5 23:01:56 2020 GMT'))\n        self.assertEqual(p['notBefore'], asn1time('Oct  8 23:01:56 2010 GMT'))\n        self.assertEqual(p['serialNumber'], 'D7C7381919AFC24E')\n        self.assertEqual(p['subject'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['subjectAltName'], (('DNS', 'localhost'),))\n        # Issue #13034: the subjectAltName in some certificates\n        # (notably projects.developer.nokia.com:443) wasn't parsed\n        p = ssl._ssl._test_decode_cert(NOKIACERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'projects.developer.nokia.com'),\n                          ('DNS', 'projects.forum.nokia.com'))\n                        )\n\n    def test_parse_cert_CVE_2013_4238(self):\n        p = ssl._ssl._test_decode_cert(NULLBYTECERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        subject = ((('countryName', 'US'),),\n                   (('stateOrProvinceName', 'Oregon'),),\n                   (('localityName', 'Beaverton'),),\n                   (('organizationName', 'Python Software Foundation'),),\n                   (('organizationalUnitName', 'Python Core Development'),),\n                   (('commonName', 'null.python.org\\x00example.org'),),\n                   (('emailAddress', 'python-dev@python.org'),))\n        self.assertEqual(p['subject'], subject)\n        self.assertEqual(p['issuer'], subject)\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'altnull.python.org\\x00example.com'),\n                         ('email', 'null@python.org\\x00user@example.org'),\n                         ('URI', 'http://null.python.org\\x00http://example.org'),\n                         ('IP Address', '192.0.2.1'),\n                         ('IP Address', '2001:DB8:0:0:0:0:0:1\\n'))\n                        )\n\n    def test_DER_to_PEM(self):\n        with open(SVN_PYTHON_ORG_ROOT_CERT, 'r') as f:\n            pem = f.read()\n        d1 = ssl.PEM_cert_to_DER_cert(pem)\n        p2 = ssl.DER_cert_to_PEM_cert(d1)\n        d2 = ssl.PEM_cert_to_DER_cert(p2)\n        self.assertEqual(d1, d2)\n        if not p2.startswith(ssl.PEM_HEADER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct header:\\n%r\\n\" % p2)\n        if not p2.endswith('\\n' + ssl.PEM_FOOTER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct footer:\\n%r\\n\" % p2)\n\n    def test_openssl_version(self):\n        n = ssl.OPENSSL_VERSION_NUMBER\n        t = ssl.OPENSSL_VERSION_INFO\n        s = ssl.OPENSSL_VERSION\n        self.assertIsInstance(n, int)\n        self.assertIsInstance(t, tuple)\n        self.assertIsInstance(s, str)\n        # Some sanity checks follow\n        # >= 0.9\n        self.assertGreaterEqual(n, 0x900000)\n        # < 2.0\n        self.assertLess(n, 0x20000000)\n        major, minor, fix, patch, status = t\n        self.assertGreaterEqual(major, 0)\n        self.assertLess(major, 2)\n        self.assertGreaterEqual(minor, 0)\n        self.assertLess(minor, 256)\n        self.assertGreaterEqual(fix, 0)\n        self.assertLess(fix, 256)\n        self.assertGreaterEqual(patch, 0)\n        self.assertLessEqual(patch, 26)\n        self.assertGreaterEqual(status, 0)\n        self.assertLessEqual(status, 15)\n        # Version string as returned by OpenSSL, the format might change\n        self.assertTrue(s.startswith(\"OpenSSL {:d}.{:d}.{:d}\".format(major, minor, fix)),\n                        (s, t))\n\n    @support.cpython_only\n    def test_refcycle(self):\n        # Issue #7943: an SSL object doesn't create reference cycles with\n        # itself.\n        s = socket.socket(socket.AF_INET)\n        ss = ssl.wrap_socket(s)\n        wr = weakref.ref(ss)\n        with support.check_warnings((\"\", ResourceWarning)):\n            del ss\n            self.assertEqual(wr(), None)\n\n    def test_wrapped_unconnected(self):\n        # Methods on an unconnected SSLSocket propagate the original\n        # OSError raise by the underlying socket object.\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            self.assertRaises(OSError, ss.recv, 1)\n            self.assertRaises(OSError, ss.recv_into, bytearray(b'x'))\n            self.assertRaises(OSError, ss.recvfrom, 1)\n            self.assertRaises(OSError, ss.recvfrom_into, bytearray(b'x'), 1)\n            self.assertRaises(OSError, ss.send, b'x')\n            self.assertRaises(OSError, ss.sendto, b'x', ('0.0.0.0', 0))\n\n    def test_timeout(self):\n        # Issue #8524: when creating an SSL socket, the timeout of the\n        # original socket should be retained.\n        for timeout in (None, 0.0, 5.0):\n            s = socket.socket(socket.AF_INET)\n            s.settimeout(timeout)\n            with ssl.wrap_socket(s) as ss:\n                self.assertEqual(timeout, ss.gettimeout())\n\n    def test_errors(self):\n        sock = socket.socket()\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified\",\n                        ssl.wrap_socket, sock, keyfile=CERTFILE)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True, certfile=\"\")\n        with ssl.wrap_socket(sock, server_side=True, certfile=CERTFILE) as s:\n            self.assertRaisesRegex(ValueError, \"can't connect in server-side mode\",\n                                    s.connect, (HOST, 8080))\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=CERTFILE, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(OSError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n\n    def test_match_hostname(self):\n        def ok(cert, hostname):\n            ssl.match_hostname(cert, hostname)\n        def fail(cert, hostname):\n            self.assertRaises(ssl.CertificateError,\n                              ssl.match_hostname, cert, hostname)\n\n        cert = {'subject': ((('commonName', 'example.com'),),)}\n        ok(cert, 'example.com')\n        ok(cert, 'ExAmple.cOm')\n        fail(cert, 'www.example.com')\n        fail(cert, '.example.com')\n        fail(cert, 'example.org')\n        fail(cert, 'exampleXcom')\n\n        cert = {'subject': ((('commonName', '*.a.com'),),)}\n        ok(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        cert = {'subject': ((('commonName', 'a.*.com'),),)}\n        ok(cert, 'a.foo.com')\n        fail(cert, 'a..com')\n        fail(cert, 'a.com')\n\n        cert = {'subject': ((('commonName', 'f*.com'),),)}\n        ok(cert, 'foo.com')\n        ok(cert, 'f.com')\n        fail(cert, 'bar.com')\n        fail(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.com')\n\n        # NULL bytes are bad, CVE-2013-4073\n        cert = {'subject': ((('commonName',\n                              'null.python.org\\x00example.org'),),)}\n        ok(cert, 'null.python.org\\x00example.org') # or raise an error?\n        fail(cert, 'example.org')\n        fail(cert, 'null.python.org')\n\n        # Slightly fake real-world example\n        cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                'subject': ((('commonName', 'linuxfrz.org'),),),\n                'subjectAltName': (('DNS', 'linuxfr.org'),\n                                   ('DNS', 'linuxfr.com'),\n                                   ('othername', '<unsupported>'))}\n        ok(cert, 'linuxfr.org')\n        ok(cert, 'linuxfr.com')\n        # Not a \"DNS\" entry\n        fail(cert, '<unsupported>')\n        # When there is a subjectAltName, commonName isn't used\n        fail(cert, 'linuxfrz.org')\n\n        # A pristine real-world example\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),),\n                            (('commonName', 'mail.google.com'),))}\n        ok(cert, 'mail.google.com')\n        fail(cert, 'gmail.com')\n        # Only commonName is considered\n        fail(cert, 'California')\n\n        # Neither commonName nor subjectAltName\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),))}\n        fail(cert, 'mail.google.com')\n\n        # No DNS entry in subjectAltName but a commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('commonName', 'mail.google.com'),)),\n                'subjectAltName': (('othername', 'blabla'), )}\n        ok(cert, 'mail.google.com')\n\n        # No DNS entry subjectAltName and no commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),)),\n                'subjectAltName': (('othername', 'blabla'),)}\n        fail(cert, 'google.com')\n\n        # Empty cert / no cert\n        self.assertRaises(ValueError, ssl.match_hostname, None, 'example.com')\n        self.assertRaises(ValueError, ssl.match_hostname, {}, 'example.com')\n\n        # Issue #17980: avoid denials of service by refusing more than one\n        # wildcard per fragment.\n        cert = {'subject': ((('commonName', 'a*b.com'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b.co*'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b*.com'),),)}\n        with self.assertRaises(ssl.CertificateError) as cm:\n            ssl.match_hostname(cert, 'axxbxxc.com')\n        self.assertIn(\"too many wildcards\", str(cm.exception))\n\n    def test_server_side(self):\n        # server_hostname doesn't work for server sockets\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        with socket.socket() as sock:\n            self.assertRaises(ValueError, ctx.wrap_socket, sock, True,\n                              server_hostname=\"some.hostname\")\n\n    def test_unknown_channel_binding(self):\n        # should raise ValueError for unknown type\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            with self.assertRaises(ValueError):\n                ss.get_channel_binding(\"unknown-type\")\n\n    @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                         \"'tls-unique' channel binding not available\")\n    def test_tls_unique_channel_binding(self):\n        # unconnected should return None for known type\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n        # the same for server-side\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s, server_side=True, certfile=CERTFILE) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n\n    def test_dealloc_warn(self):\n        ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n        r = repr(ss)\n        with self.assertWarns(ResourceWarning) as cm:\n            ss = None\n            support.gc_collect()\n        self.assertIn(r, str(cm.warning.args[0]))\n\n    def test_get_default_verify_paths(self):\n        paths = ssl.get_default_verify_paths()\n        self.assertEqual(len(paths), 6)\n        self.assertIsInstance(paths, ssl.DefaultVerifyPaths)\n\n        with support.EnvironmentVarGuard() as env:\n            env[\"SSL_CERT_DIR\"] = CAPATH\n            env[\"SSL_CERT_FILE\"] = CERTFILE\n            paths = ssl.get_default_verify_paths()\n            self.assertEqual(paths.cafile, CERTFILE)\n            self.assertEqual(paths.capath, CAPATH)\n\n\n    @unittest.skipUnless(sys.platform == \"win32\", \"Windows specific\")\n    def test_enum_cert_store(self):\n        self.assertEqual(ssl.X509_ASN_ENCODING, 1)\n        self.assertEqual(ssl.PKCS_7_ASN_ENCODING, 0x00010000)\n\n        self.assertEqual(ssl.enum_cert_store(\"CA\"),\n            ssl.enum_cert_store(\"CA\", \"certificate\"))\n        ssl.enum_cert_store(\"CA\", \"crl\")\n        self.assertEqual(ssl.enum_cert_store(\"ROOT\"),\n            ssl.enum_cert_store(\"ROOT\", \"certificate\"))\n        ssl.enum_cert_store(\"ROOT\", \"crl\")\n\n        self.assertRaises(TypeError, ssl.enum_cert_store)\n        self.assertRaises(WindowsError, ssl.enum_cert_store, \"\")\n        self.assertRaises(ValueError, ssl.enum_cert_store, \"CA\", \"wrong\")\n\n        ca = ssl.enum_cert_store(\"CA\")\n        self.assertIsInstance(ca, list)\n        self.assertIsInstance(ca[0], tuple)\n        self.assertEqual(len(ca[0]), 2)\n        self.assertIsInstance(ca[0][0], bytes)\n        self.assertIsInstance(ca[0][1], int)\n\nclass ContextTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_constructor(self):\n        for protocol in PROTOCOLS:\n            ssl.SSLContext(protocol)\n        self.assertRaises(TypeError, ssl.SSLContext)\n        self.assertRaises(ValueError, ssl.SSLContext, -1)\n        self.assertRaises(ValueError, ssl.SSLContext, 42)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.protocol, proto)\n\n    def test_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ciphers(\"ALL\")\n        ctx.set_ciphers(\"DEFAULT\")\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            ctx.set_ciphers(\"^$:,;?*'dorothyx\")\n\n    @skip_if_broken_ubuntu_ssl\n    def test_options(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # OP_ALL is the default value\n        self.assertEqual(ssl.OP_ALL, ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv2\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2,\n                         ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv3\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3,\n                         ctx.options)\n        if can_clear_options():\n            ctx.options = (ctx.options & ~ssl.OP_NO_SSLv2) | ssl.OP_NO_TLSv1\n            self.assertEqual(ssl.OP_ALL | ssl.OP_NO_TLSv1 | ssl.OP_NO_SSLv3,\n                             ctx.options)\n            ctx.options = 0\n            self.assertEqual(0, ctx.options)\n        else:\n            with self.assertRaises(ValueError):\n                ctx.options = 0\n\n    def test_verify(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Default value\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        with self.assertRaises(TypeError):\n            ctx.verify_mode = None\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = 42\n\n    def test_load_cert_chain(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Combined key and cert in a single file\n        ctx.load_cert_chain(CERTFILE)\n        ctx.load_cert_chain(CERTFILE, keyfile=CERTFILE)\n        self.assertRaises(TypeError, ctx.load_cert_chain, keyfile=CERTFILE)\n        with self.assertRaises(OSError) as cm:\n            ctx.load_cert_chain(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(BADCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(EMPTYCERT)\n        # Separate key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY)\n        ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)\n        ctx.load_cert_chain(certfile=BYTES_ONLYCERT, keyfile=BYTES_ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)\n        # Mismatching key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaisesRegex(ssl.SSLError, \"key values mismatch\"):\n            ctx.load_cert_chain(SVN_PYTHON_ORG_ROOT_CERT, ONLYKEY)\n        # Password protected key and cert\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD.encode())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=bytearray(KEY_PASSWORD.encode()))\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD.encode())\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED,\n                            bytearray(KEY_PASSWORD.encode()))\n        with self.assertRaisesRegex(TypeError, \"should be a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=True)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=\"badpass\")\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            # openssl has a fixed limit on the password buffer.\n            # PEM_BUFSIZE is generally set to 1kb.\n            # Return a string larger than this.\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=b'a' * 102400)\n        # Password callback\n        def getpass_unicode():\n            return KEY_PASSWORD\n        def getpass_bytes():\n            return KEY_PASSWORD.encode()\n        def getpass_bytearray():\n            return bytearray(KEY_PASSWORD.encode())\n        def getpass_badpass():\n            return \"badpass\"\n        def getpass_huge():\n            return b'a' * (1024 * 1024)\n        def getpass_bad_type():\n            return 9\n        def getpass_exception():\n            raise Exception('getpass error')\n        class GetPassCallable:\n            def __call__(self):\n                return KEY_PASSWORD\n            def getpass(self):\n                return KEY_PASSWORD\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_unicode)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytes)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytearray)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=GetPassCallable())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=GetPassCallable().getpass)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_badpass)\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_huge)\n        with self.assertRaisesRegex(TypeError, \"must return a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bad_type)\n        with self.assertRaisesRegex(Exception, \"getpass error\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_exception)\n        # Make sure the password function isn't called if it isn't needed\n        ctx.load_cert_chain(CERTFILE, password=getpass_exception)\n\n    def test_load_verify_locations(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_verify_locations(CERTFILE)\n        ctx.load_verify_locations(cafile=CERTFILE, capath=None)\n        ctx.load_verify_locations(BYTES_CERTFILE)\n        ctx.load_verify_locations(cafile=BYTES_CERTFILE, capath=None)\n        self.assertRaises(TypeError, ctx.load_verify_locations)\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, None)\n        with self.assertRaises(OSError) as cm:\n            ctx.load_verify_locations(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_verify_locations(BADCERT)\n        ctx.load_verify_locations(CERTFILE, CAPATH)\n        ctx.load_verify_locations(CERTFILE, capath=BYTES_CAPATH)\n\n        # Issue #10989: crash if the second argument type is invalid\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, True)\n\n    def test_load_dh_params(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_dh_params(DHFILE)\n        if os.name != 'nt':\n            ctx.load_dh_params(BYTES_DHFILE)\n        self.assertRaises(TypeError, ctx.load_dh_params)\n        self.assertRaises(TypeError, ctx.load_dh_params, None)\n        with self.assertRaises(FileNotFoundError) as cm:\n            ctx.load_dh_params(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_session_stats(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.session_stats(), {\n                'number': 0,\n                'connect': 0,\n                'connect_good': 0,\n                'connect_renegotiate': 0,\n                'accept': 0,\n                'accept_good': 0,\n                'accept_renegotiate': 0,\n                'hits': 0,\n                'misses': 0,\n                'timeouts': 0,\n                'cache_full': 0,\n            })\n\n    def test_set_default_verify_paths(self):\n        # There's not much we can do to test that it acts as expected,\n        # so just check it doesn't crash or raise an exception.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_default_verify_paths()\n\n    @unittest.skipUnless(ssl.HAS_ECDH, \"ECDH disabled on this OpenSSL build\")\n    def test_set_ecdh_curve(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ecdh_curve(\"prime256v1\")\n        ctx.set_ecdh_curve(b\"prime256v1\")\n        self.assertRaises(TypeError, ctx.set_ecdh_curve)\n        self.assertRaises(TypeError, ctx.set_ecdh_curve, None)\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, \"foo\")\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, b\"foo\")\n\n    @needs_sni\n    def test_sni_callback(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n\n        # set_servername_callback expects a callable, or None\n        self.assertRaises(TypeError, ctx.set_servername_callback)\n        self.assertRaises(TypeError, ctx.set_servername_callback, 4)\n        self.assertRaises(TypeError, ctx.set_servername_callback, \"\")\n        self.assertRaises(TypeError, ctx.set_servername_callback, ctx)\n\n        def dummycallback(sock, servername, ctx):\n            pass\n        ctx.set_servername_callback(None)\n        ctx.set_servername_callback(dummycallback)\n\n    @needs_sni\n    def test_sni_callback_refcycle(self):\n        # Reference cycles through the servername callback are detected\n        # and cleared.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        def dummycallback(sock, servername, ctx, cycle=ctx):\n            pass\n        ctx.set_servername_callback(dummycallback)\n        wr = weakref.ref(ctx)\n        del ctx, dummycallback\n        gc.collect()\n        self.assertIs(wr(), None)\n\n    def test_cert_store_stats(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 0})\n        ctx.load_cert_chain(CERTFILE)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 0})\n        ctx.load_verify_locations(CERTFILE)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 0, 'crl': 0, 'x509': 1})\n        ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n        self.assertEqual(ctx.cert_store_stats(),\n            {'x509_ca': 1, 'crl': 0, 'x509': 2})\n\n    def test_get_ca_certs(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        # CERTFILE is not flagged as X509v3 Basic Constraints: CA:TRUE\n        ctx.load_verify_locations(CERTFILE)\n        self.assertEqual(ctx.get_ca_certs(), [])\n        # but SVN_PYTHON_ORG_ROOT_CERT is a CA cert\n        ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n        self.assertEqual(ctx.get_ca_certs(),\n            [{'issuer': ((('organizationName', 'Root CA'),),\n                         (('organizationalUnitName', 'http://www.cacert.org'),),\n                         (('commonName', 'CA Cert Signing Authority'),),\n                         (('emailAddress', 'support@cacert.org'),)),\n              'notAfter': asn1time('Mar 29 12:29:49 2033 GMT'),\n              'notBefore': asn1time('Mar 30 12:29:49 2003 GMT'),\n              'serialNumber': '00',\n              'subject': ((('organizationName', 'Root CA'),),\n                          (('organizationalUnitName', 'http://www.cacert.org'),),\n                          (('commonName', 'CA Cert Signing Authority'),),\n                          (('emailAddress', 'support@cacert.org'),)),\n              'version': 3}])\n\n        with open(SVN_PYTHON_ORG_ROOT_CERT) as f:\n            pem = f.read()\n        der = ssl.PEM_cert_to_DER_cert(pem)\n        self.assertEqual(ctx.get_ca_certs(True), [der])\n\n\nclass SSLErrorTests(unittest.TestCase):\n\n    def test_str(self):\n        # The str() of a SSLError doesn't include the errno\n        e = ssl.SSLError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n        # Same for a subclass\n        e = ssl.SSLZeroReturnError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n\n    def test_lib_reason(self):\n        # Test the library and reason attributes\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n        self.assertEqual(cm.exception.library, 'PEM')\n        self.assertEqual(cm.exception.reason, 'NO_START_LINE')\n        s = str(cm.exception)\n        self.assertTrue(s.startswith(\"[PEM: NO_START_LINE] no start line\"), s)\n\n    def test_subclass(self):\n        # Check that the appropriate SSLError subclass is raised\n        # (this only tests one of them)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with socket.socket() as s:\n            s.bind((\"127.0.0.1\", 0))\n            s.listen(5)\n            c = socket.socket()\n            c.connect(s.getsockname())\n            c.setblocking(False)\n            with ctx.wrap_socket(c, False, do_handshake_on_connect=False) as c:\n                with self.assertRaises(ssl.SSLWantReadError) as cm:\n                    c.do_handshake()\n                s = str(cm.exception)\n                self.assertTrue(s.startswith(\"The operation did not complete (read)\"), s)\n                # For compatibility\n                self.assertEqual(cm.exception.errno, ssl.SSL_ERROR_WANT_READ)\n\n\nclass NetworkedTests(unittest.TestCase):\n\n    def test_connect(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n\n            # this should fail because we have no verification certs\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED)\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                   s.connect, (\"svn.python.org\", 443))\n            s.close()\n\n            # this should succeed because we specify the root cert\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_connect_ex(self):\n        # Issue #11326: check connect_ex() implementation\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(0, s.connect_ex((\"svn.python.org\", 443)))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_non_blocking_connect_ex(self):\n        # Issue #11326: non-blocking connect_ex() should allow handshake\n        # to proceed after the socket gets ready.\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.setblocking(False)\n                rc = s.connect_ex(('svn.python.org', 443))\n                # EWOULDBLOCK under Windows, EINPROGRESS elsewhere\n                self.assertIn(rc, (0, errno.EINPROGRESS, errno.EWOULDBLOCK))\n                # Wait for connect to finish\n                select.select([], [s], [], 5.0)\n                # Non-blocking handshake\n                while True:\n                    try:\n                        s.do_handshake()\n                        break\n                    except ssl.SSLWantReadError:\n                        select.select([s], [], [], 5.0)\n                    except ssl.SSLWantWriteError:\n                        select.select([], [s], [], 5.0)\n                # SSL established\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_timeout_connect_ex(self):\n        # Issue #12065: on a timeout, connect_ex() should return the original\n        # errno (mimicking the behaviour of non-SSL sockets).\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.settimeout(0.0000001)\n                rc = s.connect_ex(('svn.python.org', 443))\n                if rc == 0:\n                    self.skipTest(\"svn.python.org responded too quickly\")\n                self.assertIn(rc, (errno.EAGAIN, errno.EWOULDBLOCK))\n            finally:\n                s.close()\n\n    def test_connect_ex_error(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(errno.ECONNREFUSED,\n                                 s.connect_ex((\"svn.python.org\", 444)))\n            finally:\n                s.close()\n\n    def test_connect_with_context(self):\n        with support.transient_internet(\"svn.python.org\"):\n            # Same as test_connect, but with a separately created context\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n            # Same with a server hostname\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"svn.python.org\")\n            if ssl.HAS_SNI:\n                s.connect((\"svn.python.org\", 443))\n                s.close()\n            else:\n                self.assertRaises(ValueError, s.connect, (\"svn.python.org\", 443))\n            # This should fail because we have no verification certs\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                    s.connect, (\"svn.python.org\", 443))\n            s.close()\n            # This should succeed because we specify the root cert\n            ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    def test_connect_capath(self):\n        # Verify server certificates using the `capath` argument\n        # NOTE: the subject hashing algorithm has been changed between\n        # OpenSSL 0.9.8n and 1.0.0, as a result the capath directory must\n        # contain both versions of each certificate (same content, different\n        # filename) for this test to be portable across OpenSSL releases.\n        with support.transient_internet(\"svn.python.org\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n            # Same with a bytes `capath` argument\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=BYTES_CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    @unittest.skipIf(os.name == \"nt\", \"Can't use a socket as a file under Windows\")\n    def test_makefile_close(self):\n        # Issue #5238: creating a file-like object with makefile() shouldn't\n        # delay closing the underlying \"real socket\" (here tested with its\n        # file descriptor, hence skipping the test under Windows).\n        with support.transient_internet(\"svn.python.org\"):\n            ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n            ss.connect((\"svn.python.org\", 443))\n            fd = ss.fileno()\n            f = ss.makefile()\n            f.close()\n            # The fd is still open\n            os.read(fd, 0)\n            # Closing the SSL socket should close the fd too\n            ss.close()\n            gc.collect()\n            with self.assertRaises(OSError) as e:\n                os.read(fd, 0)\n            self.assertEqual(e.exception.errno, errno.EBADF)\n\n    def test_non_blocking_handshake(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = socket.socket(socket.AF_INET)\n            s.connect((\"svn.python.org\", 443))\n            s.setblocking(False)\n            s = ssl.wrap_socket(s,\n                                cert_reqs=ssl.CERT_NONE,\n                                do_handshake_on_connect=False)\n            count = 0\n            while True:\n                try:\n                    count += 1\n                    s.do_handshake()\n                    break\n                except ssl.SSLWantReadError:\n                    select.select([s], [], [])\n                except ssl.SSLWantWriteError:\n                    select.select([], [s], [])\n            s.close()\n            if support.verbose:\n                sys.stdout.write(\"\\nNeeded %d calls to do_handshake() to establish session.\\n\" % count)\n\n    def test_get_server_certificate(self):\n        def _test_get_server_certificate(host, port, cert=None):\n            with support.transient_internet(host):\n                pem = ssl.get_server_certificate((host, port))\n                if not pem:\n                    self.fail(\"No server certificate on %s:%s!\" % (host, port))\n\n                try:\n                    pem = ssl.get_server_certificate((host, port), ca_certs=CERTFILE)\n                except ssl.SSLError as x:\n                    #should fail\n                    if support.verbose:\n                        sys.stdout.write(\"%s\\n\" % x)\n                else:\n                    self.fail(\"Got server certificate %s for %s:%s!\" % (pem, host, port))\n\n                pem = ssl.get_server_certificate((host, port), ca_certs=cert)\n                if not pem:\n                    self.fail(\"No server certificate on %s:%s!\" % (host, port))\n                if support.verbose:\n                    sys.stdout.write(\"\\nVerified certificate for %s:%s is\\n%s\\n\" % (host, port ,pem))\n\n        _test_get_server_certificate('svn.python.org', 443, SVN_PYTHON_ORG_ROOT_CERT)\n        if support.IPV6_ENABLED:\n            _test_get_server_certificate('ipv6.google.com', 443)\n\n    def test_ciphers(self):\n        remote = (\"svn.python.org\", 443)\n        with support.transient_internet(remote[0]):\n            with ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                 cert_reqs=ssl.CERT_NONE, ciphers=\"ALL\") as s:\n                s.connect(remote)\n            with ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                 cert_reqs=ssl.CERT_NONE, ciphers=\"DEFAULT\") as s:\n                s.connect(remote)\n            # Error checking can happen at instantiation or when connecting\n            with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n                with socket.socket(socket.AF_INET) as sock:\n                    s = ssl.wrap_socket(sock,\n                                        cert_reqs=ssl.CERT_NONE, ciphers=\"^$:,;?*'dorothyx\")\n                    s.connect(remote)\n\n    def test_algorithms(self):\n        # Issue #8484: all algorithms should be available when verifying a\n        # certificate.\n        # SHA256 was added in OpenSSL 0.9.8\n        if ssl.OPENSSL_VERSION_INFO < (0, 9, 8, 0, 15):\n            self.skipTest(\"SHA256 not available on %r\" % ssl.OPENSSL_VERSION)\n        # sha256.tbs-internet.com needs SNI to use the correct certificate\n        if not ssl.HAS_SNI:\n            self.skipTest(\"SNI needed for this test\")\n        # https://sha2.hboeck.de/ was used until 2011-01-08 (no route to host)\n        remote = (\"sha256.tbs-internet.com\", 443)\n        sha256_cert = os.path.join(os.path.dirname(__file__), \"sha256.pem\")\n        with support.transient_internet(\"sha256.tbs-internet.com\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(sha256_cert)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"sha256.tbs-internet.com\")\n            try:\n                s.connect(remote)\n                if support.verbose:\n                    sys.stdout.write(\"\\nCipher with %r is %r\\n\" %\n                                     (remote, s.cipher()))\n                    sys.stdout.write(\"Certificate is:\\n%s\\n\" %\n                                     pprint.pformat(s.getpeercert()))\n            finally:\n                s.close()\n\n    def test_get_ca_certs_capath(self):\n        # capath certs are loaded on request\n        with support.transient_internet(\"svn.python.org\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=CAPATH)\n            self.assertEqual(ctx.get_ca_certs(), [])\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n            self.assertEqual(len(ctx.get_ca_certs()), 1)\n\n\ntry:\n    import threading\nexcept ImportError:\n    _have_threads = False\nelse:\n    _have_threads = True\n\n    from test.ssl_servers import make_https_server\n\n    class ThreadedEchoServer(threading.Thread):\n\n        class ConnectionHandler(threading.Thread):\n\n            \"\"\"A mildly complicated class, because we want it to work both\n            with and without the SSL wrapper around the socket connection, so\n            that we can test the STARTTLS functionality.\"\"\"\n\n            def __init__(self, server, connsock, addr):\n                self.server = server\n                self.running = False\n                self.sock = connsock\n                self.addr = addr\n                self.sock.setblocking(1)\n                self.sslconn = None\n                threading.Thread.__init__(self)\n                self.daemon = True\n\n            def wrap_conn(self):\n                try:\n                    self.sslconn = self.server.context.wrap_socket(\n                        self.sock, server_side=True)\n                    self.server.selected_protocols.append(self.sslconn.selected_npn_protocol())\n                except (ssl.SSLError, ConnectionResetError) as e:\n                    # We treat ConnectionResetError as though it were an\n                    # SSLError - OpenSSL on Ubuntu abruptly closes the\n                    # connection when asked to use an unsupported protocol.\n                    #\n                    # XXX Various errors can have happened here, for example\n                    # a mismatching protocol version, an invalid certificate,\n                    # or a low-level bug. This should be made more discriminating.\n                    self.server.conn_errors.append(e)\n                    if self.server.chatty:\n                        handle_error(\"\\n server:  bad connection attempt from \" + repr(self.addr) + \":\\n\")\n                    self.running = False\n                    self.server.stop()\n                    self.close()\n                    return False\n                else:\n                    if self.server.context.verify_mode == ssl.CERT_REQUIRED:\n                        cert = self.sslconn.getpeercert()\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" client cert is \" + pprint.pformat(cert) + \"\\n\")\n                        cert_binary = self.sslconn.getpeercert(True)\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" cert binary is \" + str(len(cert_binary)) + \" bytes\\n\")\n                    cipher = self.sslconn.cipher()\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" server: connection cipher is now \" + str(cipher) + \"\\n\")\n                        sys.stdout.write(\" server: selected protocol is now \"\n                                + str(self.sslconn.selected_npn_protocol()) + \"\\n\")\n                    return True\n\n            def read(self):\n                if self.sslconn:\n                    return self.sslconn.read()\n                else:\n                    return self.sock.recv(1024)\n\n            def write(self, bytes):\n                if self.sslconn:\n                    return self.sslconn.write(bytes)\n                else:\n                    return self.sock.send(bytes)\n\n            def close(self):\n                if self.sslconn:\n                    self.sslconn.close()\n                else:\n                    self.sock.close()\n\n            def run(self):\n                self.running = True\n                if not self.server.starttls_server:\n                    if not self.wrap_conn():\n                        return\n                while self.running:\n                    try:\n                        msg = self.read()\n                        stripped = msg.strip()\n                        if not stripped:\n                            # eof, so quit this handler\n                            self.running = False\n                            self.close()\n                        elif stripped == b'over':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: client closed connection\\n\")\n                            self.close()\n                            return\n                        elif (self.server.starttls_server and\n                              stripped == b'STARTTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read STARTTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            if not self.wrap_conn():\n                                return\n                        elif (self.server.starttls_server and self.sslconn\n                              and stripped == b'ENDTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read ENDTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            self.sock = self.sslconn.unwrap()\n                            self.sslconn = None\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: connection is now unencrypted...\\n\")\n                        elif stripped == b'CB tls-unique':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read CB tls-unique from client, sending our CB data...\\n\")\n                            data = self.sslconn.get_channel_binding(\"tls-unique\")\n                            self.write(repr(data).encode(\"us-ascii\") + b\"\\n\")\n                        else:\n                            if (support.verbose and\n                                self.server.connectionchatty):\n                                ctype = (self.sslconn and \"encrypted\") or \"unencrypted\"\n                                sys.stdout.write(\" server: read %r (%s), sending back %r (%s)...\\n\"\n                                                 % (msg, ctype, msg.lower(), ctype))\n                            self.write(msg.lower())\n                    except OSError:\n                        if self.server.chatty:\n                            handle_error(\"Test server failure:\\n\")\n                        self.close()\n                        self.running = False\n                        # normally, we'd just stop here, but for the test\n                        # harness, we want to stop the server\n                        self.server.stop()\n\n        def __init__(self, certificate=None, ssl_version=None,\n                     certreqs=None, cacerts=None,\n                     chatty=True, connectionchatty=False, starttls_server=False,\n                     npn_protocols=None, ciphers=None, context=None):\n            if context:\n                self.context = context\n            else:\n                self.context = ssl.SSLContext(ssl_version\n                                              if ssl_version is not None\n                                              else ssl.PROTOCOL_TLSv1)\n                self.context.verify_mode = (certreqs if certreqs is not None\n                                            else ssl.CERT_NONE)\n                if cacerts:\n                    self.context.load_verify_locations(cacerts)\n                if certificate:\n                    self.context.load_cert_chain(certificate)\n                if npn_protocols:\n                    self.context.set_npn_protocols(npn_protocols)\n                if ciphers:\n                    self.context.set_ciphers(ciphers)\n            self.chatty = chatty\n            self.connectionchatty = connectionchatty\n            self.starttls_server = starttls_server\n            self.sock = socket.socket()\n            self.port = support.bind_port(self.sock)\n            self.flag = None\n            self.active = False\n            self.selected_protocols = []\n            self.conn_errors = []\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            self.stop()\n            self.join()\n\n        def start(self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.sock.settimeout(0.05)\n            self.sock.listen(5)\n            self.active = True\n            if self.flag:\n                # signal an event\n                self.flag.set()\n            while self.active:\n                try:\n                    newconn, connaddr = self.sock.accept()\n                    if support.verbose and self.chatty:\n                        sys.stdout.write(' server:  new connection from '\n                                         + repr(connaddr) + '\\n')\n                    handler = self.ConnectionHandler(self, newconn, connaddr)\n                    handler.start()\n                    handler.join()\n                except socket.timeout:\n                    pass\n                except KeyboardInterrupt:\n                    self.stop()\n            self.sock.close()\n\n        def stop(self):\n            self.active = False\n\n    class AsyncoreEchoServer(threading.Thread):\n\n        # this one's based on asyncore.dispatcher\n\n        class EchoServer (asyncore.dispatcher):\n\n            class ConnectionHandler (asyncore.dispatcher_with_send):\n\n                def __init__(self, conn, certfile):\n                    self.socket = ssl.wrap_socket(conn, server_side=True,\n                                                  certfile=certfile,\n                                                  do_handshake_on_connect=False)\n                    asyncore.dispatcher_with_send.__init__(self, self.socket)\n                    self._ssl_accepting = True\n                    self._do_ssl_handshake()\n\n                def readable(self):\n                    if isinstance(self.socket, ssl.SSLSocket):\n                        while self.socket.pending() > 0:\n                            self.handle_read_event()\n                    return True\n\n                def _do_ssl_handshake(self):\n                    try:\n                        self.socket.do_handshake()\n                    except (ssl.SSLWantReadError, ssl.SSLWantWriteError):\n                        return\n                    except ssl.SSLEOFError:\n                        return self.handle_close()\n                    except ssl.SSLError:\n                        raise\n                    except OSError as err:\n                        if err.args[0] == errno.ECONNABORTED:\n                            return self.handle_close()\n                    else:\n                        self._ssl_accepting = False\n\n                def handle_read(self):\n                    if self._ssl_accepting:\n                        self._do_ssl_handshake()\n                    else:\n                        data = self.recv(1024)\n                        if support.verbose:\n                            sys.stdout.write(\" server:  read %s from client\\n\" % repr(data))\n                        if not data:\n                            self.close()\n                        else:\n                            self.send(data.lower())\n\n                def handle_close(self):\n                    self.close()\n                    if support.verbose:\n                        sys.stdout.write(\" server:  closed connection %s\\n\" % self.socket)\n\n                def handle_error(self):\n                    raise\n\n            def __init__(self, certfile):\n                self.certfile = certfile\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.port = support.bind_port(sock, '')\n                asyncore.dispatcher.__init__(self, sock)\n                self.listen(5)\n\n            def handle_accepted(self, sock_obj, addr):\n                if support.verbose:\n                    sys.stdout.write(\" server:  new connection from %s:%s\\n\" %addr)\n                self.ConnectionHandler(sock_obj, self.certfile)\n\n            def handle_error(self):\n                raise\n\n        def __init__(self, certfile):\n            self.flag = None\n            self.active = False\n            self.server = self.EchoServer(certfile)\n            self.port = self.server.port\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __str__(self):\n            return \"<%s %s>\" % (self.__class__.__name__, self.server)\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            if support.verbose:\n                sys.stdout.write(\" cleanup: stopping server.\\n\")\n            self.stop()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: joining server thread.\\n\")\n            self.join()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: successfully joined.\\n\")\n\n        def start (self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.active = True\n            if self.flag:\n                self.flag.set()\n            while self.active:\n                try:\n                    asyncore.loop(1)\n                except:\n                    pass\n\n        def stop(self):\n            self.active = False\n            self.server.close()\n\n    def bad_cert_test(certfile):\n        \"\"\"\n        Launch a server with CERT_REQUIRED, and check that trying to\n        connect to it with the given client certificate fails.\n        \"\"\"\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_REQUIRED,\n                                    cacerts=CERTFILE, chatty=False,\n                                    connectionchatty=False)\n        with server:\n            try:\n                with socket.socket() as sock:\n                    s = ssl.wrap_socket(sock,\n                                        certfile=certfile,\n                                        ssl_version=ssl.PROTOCOL_TLSv1)\n                    s.connect((HOST, server.port))\n            except ssl.SSLError as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nSSLError is %s\\n\" % x.args[1])\n            except OSError as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nOSError is %s\\n\" % x.args[1])\n            except OSError as x:\n                if x.errno != errno.ENOENT:\n                    raise\n                if support.verbose:\n                    sys.stdout.write(\"\\OSError is %s\\n\" % str(x))\n            else:\n                raise AssertionError(\"Use of invalid cert should have failed!\")\n\n    def server_params_test(client_context, server_context, indata=b\"FOO\\n\",\n                           chatty=True, connectionchatty=False, sni_name=None):\n        \"\"\"\n        Launch a server, connect a client to it and try various reads\n        and writes.\n        \"\"\"\n        stats = {}\n        server = ThreadedEchoServer(context=server_context,\n                                    chatty=chatty,\n                                    connectionchatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket(),\n                    server_hostname=sni_name) as s:\n                s.connect((HOST, server.port))\n                for arg in [indata, bytearray(indata), memoryview(indata)]:\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  sending %r...\\n\" % indata)\n                    s.write(arg)\n                    outdata = s.read()\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                    if outdata != indata.lower():\n                        raise AssertionError(\n                            \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                            % (outdata[:20], len(outdata),\n                               indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\" client:  closing connection.\\n\")\n                stats.update({\n                    'compression': s.compression(),\n                    'cipher': s.cipher(),\n                    'peercert': s.getpeercert(),\n                    'client_npn_protocol': s.selected_npn_protocol()\n                })\n                s.close()\n            stats['server_npn_protocols'] = server.selected_protocols\n        return stats\n\n    def try_protocol_combo(server_protocol, client_protocol, expect_success,\n                           certsreqs=None, server_options=0, client_options=0):\n        if certsreqs is None:\n            certsreqs = ssl.CERT_NONE\n        certtype = {\n            ssl.CERT_NONE: \"CERT_NONE\",\n            ssl.CERT_OPTIONAL: \"CERT_OPTIONAL\",\n            ssl.CERT_REQUIRED: \"CERT_REQUIRED\",\n        }[certsreqs]\n        if support.verbose:\n            formatstr = (expect_success and \" %s->%s %s\\n\") or \" {%s->%s} %s\\n\"\n            sys.stdout.write(formatstr %\n                             (ssl.get_protocol_name(client_protocol),\n                              ssl.get_protocol_name(server_protocol),\n                              certtype))\n        client_context = ssl.SSLContext(client_protocol)\n        client_context.options = ssl.OP_ALL | client_options\n        server_context = ssl.SSLContext(server_protocol)\n        server_context.options = ssl.OP_ALL | server_options\n\n        # NOTE: we must enable \"ALL\" ciphers on the client, otherwise an\n        # SSLv23 client will send an SSLv3 hello (rather than SSLv2)\n        # starting from OpenSSL 1.0.0 (see issue #8322).\n        if client_context.protocol == ssl.PROTOCOL_SSLv23:\n            client_context.set_ciphers(\"ALL\")\n\n        for ctx in (client_context, server_context):\n            ctx.verify_mode = certsreqs\n            ctx.load_cert_chain(CERTFILE)\n            ctx.load_verify_locations(CERTFILE)\n        try:\n            server_params_test(client_context, server_context,\n                               chatty=False, connectionchatty=False)\n        # Protocol mismatch can result in either an SSLError, or a\n        # \"Connection reset by peer\" error.\n        except ssl.SSLError:\n            if expect_success:\n                raise\n        except OSError as e:\n            if expect_success or e.errno != errno.ECONNRESET:\n                raise\n        else:\n            if not expect_success:\n                raise AssertionError(\n                    \"Client protocol %s succeeded with server protocol %s!\"\n                    % (ssl.get_protocol_name(client_protocol),\n                       ssl.get_protocol_name(server_protocol)))\n\n\n    class ThreadedTests(unittest.TestCase):\n\n        @skip_if_broken_ubuntu_ssl\n        def test_echo(self):\n            \"\"\"Basic test of an SSL client connecting to a server\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            for protocol in PROTOCOLS:\n                with self.subTest(protocol=ssl._PROTOCOL_NAMES[protocol]):\n                    context = ssl.SSLContext(protocol)\n                    context.load_cert_chain(CERTFILE)\n                    server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n\n        def test_getpeercert(self):\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = ThreadedEchoServer(context=context, chatty=False)\n            with server:\n                s = context.wrap_socket(socket.socket())\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()\n                if support.verbose:\n                    sys.stdout.write(pprint.pformat(cert) + '\\n')\n                    sys.stdout.write(\"Connection cipher is \" + str(cipher) + '.\\n')\n                if 'subject' not in cert:\n                    self.fail(\"No subject field in certificate: %s.\" %\n                              pprint.pformat(cert))\n                if ((('organizationName', 'Python Software Foundation'),)\n                    not in cert['subject']):\n                    self.fail(\n                        \"Missing or invalid 'organizationName' field in certificate subject; \"\n                        \"should be 'Python Software Foundation'.\")\n                self.assertIn('notBefore', cert)\n                self.assertIn('notAfter', cert)\n                before = ssl.cert_time_to_seconds(cert['notBefore'])\n                after = ssl.cert_time_to_seconds(cert['notAfter'])\n                self.assertLess(before, after)\n                s.close()\n\n        def test_empty_cert(self):\n            \"\"\"Connecting with an empty cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                      \"nullcert.pem\"))\n        def test_malformed_cert(self):\n            \"\"\"Connecting with a badly formatted certificate (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badcert.pem\"))\n        def test_nonexisting_cert(self):\n            \"\"\"Connecting with a non-existing cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"wrongcert.pem\"))\n        def test_malformed_key(self):\n            \"\"\"Connecting with a badly formatted key (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badkey.pem\"))\n\n        def test_rude_shutdown(self):\n            \"\"\"A brutal shutdown of an SSL server should raise an OSError\n            in the client when attempting handshake.\n            \"\"\"\n            listener_ready = threading.Event()\n            listener_gone = threading.Event()\n\n            s = socket.socket()\n            port = support.bind_port(s, HOST)\n\n            # `listener` runs in a thread.  It sits in an accept() until\n            # the main thread connects.  Then it rudely closes the socket,\n            # and sets Event `listener_gone` to let the main thread know\n            # the socket is gone.\n            def listener():\n                s.listen(5)\n                listener_ready.set()\n                newsock, addr = s.accept()\n                newsock.close()\n                s.close()\n                listener_gone.set()\n\n            def connector():\n                listener_ready.wait()\n                with socket.socket() as c:\n                    c.connect((HOST, port))\n                    listener_gone.wait()\n                    try:\n                        ssl_sock = ssl.wrap_socket(c)\n                    except OSError:\n                        pass\n                    else:\n                        self.fail('connecting to closed SSL socket should have failed')\n\n            t = threading.Thread(target=listener)\n            t.start()\n            try:\n                connector()\n            finally:\n                t.join()\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv2'),\n                             \"OpenSSL is compiled without SSLv2 support\")\n        def test_protocol_sslv2(self):\n            \"\"\"Connecting to an SSLv2 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLSv1, False)\n            # SSLv23 client with specific SSL options\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, False,\n                                   client_options=ssl.OP_NO_SSLv2)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv23(self):\n            \"\"\"Connecting to an SSLv23 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try:\n                    try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv2, True)\n                except OSError as x:\n                    # this fails on some older versions of OpenSSL (0.9.7l, for instance)\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" SSL2 client to SSL23 server test unexpectedly failed:\\n %s\\n\"\n                            % str(x))\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n\n            # Server with specific SSL options\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, False,\n                               server_options=ssl.OP_NO_SSLv3)\n            # Will choose TLSv1\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True,\n                               server_options=ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, False,\n                               server_options=ssl.OP_NO_TLSv1)\n\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv3(self):\n            \"\"\"Connecting to an SSLv3 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLSv1, False)\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, True,\n                                   client_options=ssl.OP_NO_SSLv2)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_tlsv1(self):\n            \"\"\"Connecting to a TLSv1 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, \"PROTOCOL_TLSv1_1\"),\n                             \"TLS version 1.1 not supported.\")\n        def test_protocol_tlsv1_1(self):\n            \"\"\"Connecting to a TLSv1.1 server with various client options.\n               Testing against older TLS versions.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1_1, True)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1_1)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1_1, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1_1, False)\n\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, \"PROTOCOL_TLSv1_2\"),\n                             \"TLS version 1.2 not supported.\")\n        def test_protocol_tlsv1_2(self):\n            \"\"\"Connecting to a TLSv1.2 server with various client options.\n               Testing against older TLS versions.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1_2, True,\n                               server_options=ssl.OP_NO_SSLv3|ssl.OP_NO_SSLv2,\n                               client_options=ssl.OP_NO_SSLv3|ssl.OP_NO_SSLv2,)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1_2)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1_2, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1_2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1_1, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1_1, ssl.PROTOCOL_TLSv1_2, False)\n\n        def test_starttls(self):\n            \"\"\"Switching from clear text to encrypted and back again.\"\"\"\n            msgs = (b\"msg 1\", b\"MSG 2\", b\"STARTTLS\", b\"MSG 3\", b\"msg 4\", b\"ENDTLS\", b\"msg 5\", b\"msg 6\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        starttls_server=True,\n                                        chatty=True,\n                                        connectionchatty=True)\n            wrapped = False\n            with server:\n                s = socket.socket()\n                s.setblocking(1)\n                s.connect((HOST, server.port))\n                if support.verbose:\n                    sys.stdout.write(\"\\n\")\n                for indata in msgs:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  sending %r...\\n\" % indata)\n                    if wrapped:\n                        conn.write(indata)\n                        outdata = conn.read()\n                    else:\n                        s.send(indata)\n                        outdata = s.recv(1024)\n                    msg = outdata.strip().lower()\n                    if indata == b\"STARTTLS\" and msg.startswith(b\"ok\"):\n                        # STARTTLS ok, switch to secure mode\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, starting TLS...\\n\"\n                                % msg)\n                        conn = ssl.wrap_socket(s, ssl_version=ssl.PROTOCOL_TLSv1)\n                        wrapped = True\n                    elif indata == b\"ENDTLS\" and msg.startswith(b\"ok\"):\n                        # ENDTLS ok, switch back to clear text\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, ending TLS...\\n\"\n                                % msg)\n                        s = conn.unwrap()\n                        wrapped = False\n                    else:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server\\n\" % msg)\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                if wrapped:\n                    conn.write(b\"over\\n\")\n                else:\n                    s.send(b\"over\\n\")\n                if wrapped:\n                    conn.close()\n                else:\n                    s.close()\n\n        def test_socketserver(self):\n            \"\"\"Using a SocketServer to create and manage SSL connections.\"\"\"\n            server = make_https_server(self, certfile=CERTFILE)\n            # try to connect\n            if support.verbose:\n                sys.stdout.write('\\n')\n            with open(CERTFILE, 'rb') as f:\n                d1 = f.read()\n            d2 = ''\n            # now fetch the same data from the HTTPS server\n            url = 'https://%s:%d/%s' % (\n                HOST, server.port, os.path.split(CERTFILE)[1])\n            f = urllib.request.urlopen(url)\n            try:\n                dlen = f.info().get(\"content-length\")\n                if dlen and (int(dlen) > 0):\n                    d2 = f.read(int(dlen))\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client: read %d bytes from remote server '%s'\\n\"\n                            % (len(d2), server))\n            finally:\n                f.close()\n            self.assertEqual(d1, d2)\n\n        def test_asyncore_server(self):\n            \"\"\"Check the example asyncore integration.\"\"\"\n            indata = \"TEST MESSAGE of mixed case\\n\"\n\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            indata = b\"FOO\\n\"\n            server = AsyncoreEchoServer(CERTFILE)\n            with server:\n                s = ssl.wrap_socket(socket.socket())\n                s.connect(('127.0.0.1', server.port))\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client:  sending %r...\\n\" % indata)\n                s.write(indata)\n                outdata = s.read()\n                if support.verbose:\n                    sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                if outdata != indata.lower():\n                    self.fail(\n                        \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                        % (outdata[:20], len(outdata),\n                           indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                s.close()\n                if support.verbose:\n                    sys.stdout.write(\" client:  connection closed.\\n\")\n\n        def test_recv_send(self):\n            \"\"\"Test recv(), send() and friends.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # helper methods for standardising recv* method signatures\n                def _recv_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count = s.recv_into(b)\n                    return b[:count]\n\n                def _recvfrom_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count, addr = s.recvfrom_into(b)\n                    return b[:count]\n\n                # (name, method, whether to expect success, *args)\n                send_methods = [\n                    ('send', s.send, True, []),\n                    ('sendto', s.sendto, False, [\"some.address\"]),\n                    ('sendall', s.sendall, True, []),\n                ]\n                recv_methods = [\n                    ('recv', s.recv, True, []),\n                    ('recvfrom', s.recvfrom, False, [\"some.address\"]),\n                    ('recv_into', _recv_into, True, []),\n                    ('recvfrom_into', _recvfrom_into, False, []),\n                ]\n                data_prefix = \"PREFIX_\"\n\n                for meth_name, send_meth, expect_success, args in send_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        send_meth(indata, *args)\n                        outdata = s.read()\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While sending with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to send with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n\n                for meth_name, recv_meth, expect_success, args in recv_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        s.send(indata)\n                        outdata = recv_meth(*args)\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While receiving with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to receive with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n                        # consume data\n                        s.read()\n\n                # Make sure sendmsg et al are disallowed to avoid\n                # inadvertent disclosure of data and/or corruption\n                # of the encrypted data stream\n                self.assertRaises(NotImplementedError, s.sendmsg, [b\"data\"])\n                self.assertRaises(NotImplementedError, s.recvmsg, 100)\n                self.assertRaises(NotImplementedError,\n                                  s.recvmsg_into, bytearray(100))\n\n                s.write(b\"over\\n\")\n                s.close()\n\n        def test_handshake_timeout(self):\n            # Issue #5103: SSL handshake must respect the socket timeout\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            started = threading.Event()\n            finish = False\n\n            def serve():\n                server.listen(5)\n                started.set()\n                conns = []\n                while not finish:\n                    r, w, e = select.select([server], [], [], 0.1)\n                    if server in r:\n                        # Let the socket hang around rather than having\n                        # it closed by garbage collection.\n                        conns.append(server.accept()[0])\n                for sock in conns:\n                    sock.close()\n\n            t = threading.Thread(target=serve)\n            t.start()\n            started.wait()\n\n            try:\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c.settimeout(0.2)\n                    c.connect((host, port))\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           ssl.wrap_socket, c)\n                finally:\n                    c.close()\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c = ssl.wrap_socket(c)\n                    c.settimeout(0.2)\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           c.connect, (host, port))\n                finally:\n                    c.close()\n            finally:\n                finish = True\n                t.join()\n                server.close()\n\n        def test_server_accept(self):\n            # Issue #16357: accept() on a SSLSocket created through\n            # SSLContext.wrap_socket().\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            server = context.wrap_socket(server, server_side=True)\n\n            evt = threading.Event()\n            remote = None\n            peer = None\n            def serve():\n                nonlocal remote, peer\n                server.listen(5)\n                # Block on the accept and wait on the connection to close.\n                evt.set()\n                remote, peer = server.accept()\n                remote.recv(1)\n\n            t = threading.Thread(target=serve)\n            t.start()\n            # Client wait until server setup and perform a connect.\n            evt.wait()\n            client = context.wrap_socket(socket.socket())\n            client.connect((host, port))\n            client_addr = client.getsockname()\n            client.close()\n            t.join()\n            remote.close()\n            server.close()\n            # Sanity checks.\n            self.assertIsInstance(remote, ssl.SSLSocket)\n            self.assertEqual(peer, client_addr)\n\n        def test_getpeercert_enotconn(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            with context.wrap_socket(socket.socket()) as sock:\n                with self.assertRaises(OSError) as cm:\n                    sock.getpeercert()\n                self.assertEqual(cm.exception.errno, errno.ENOTCONN)\n\n        def test_do_handshake_enotconn(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            with context.wrap_socket(socket.socket()) as sock:\n                with self.assertRaises(OSError) as cm:\n                    sock.do_handshake()\n                self.assertEqual(cm.exception.errno, errno.ENOTCONN)\n\n        def test_default_ciphers(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            try:\n                # Force a set of weak ciphers on our client context\n                context.set_ciphers(\"DES\")\n            except ssl.SSLError:\n                self.skipTest(\"no DES cipher available\")\n            with ThreadedEchoServer(CERTFILE,\n                                    ssl_version=ssl.PROTOCOL_SSLv23,\n                                    chatty=False) as server:\n                with context.wrap_socket(socket.socket()) as s:\n                    with self.assertRaises(OSError):\n                        s.connect((HOST, server.port))\n            self.assertIn(\"no shared cipher\", str(server.conn_errors[0]))\n\n        @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                             \"'tls-unique' channel binding not available\")\n        def test_tls_unique_channel_binding(self):\n            \"\"\"Test tls-unique channel binding.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # get the data\n                cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\" got channel binding data: {0!r}\\n\"\n                                     .format(cb_data))\n\n                # check if it is sane\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n\n                # and compare with the peers version\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(cb_data).encode(\"us-ascii\"))\n                s.close()\n\n                # now, again\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                new_cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\" got another channel binding data: {0!r}\\n\"\n                                     .format(new_cb_data))\n                # is it really unique\n                self.assertNotEqual(cb_data, new_cb_data)\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(new_cb_data).encode(\"us-ascii\"))\n                s.close()\n\n        def test_compression(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            if support.verbose:\n                sys.stdout.write(\" got compression: {!r}\\n\".format(stats['compression']))\n            self.assertIn(stats['compression'], { None, 'ZLIB', 'RLE' })\n\n        @unittest.skipUnless(hasattr(ssl, 'OP_NO_COMPRESSION'),\n                             \"ssl.OP_NO_COMPRESSION needed for this test\")\n        def test_compression_disabled(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            context.options |= ssl.OP_NO_COMPRESSION\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            self.assertIs(stats['compression'], None)\n\n        def test_dh_params(self):\n            # Check we can get a connection with ephemeral Diffie-Hellman\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            context.load_dh_params(DHFILE)\n            context.set_ciphers(\"kEDH\")\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            cipher = stats[\"cipher\"][0]\n            parts = cipher.split(\"-\")\n            if \"ADH\" not in parts and \"EDH\" not in parts and \"DHE\" not in parts:\n                self.fail(\"Non-DH cipher: \" + cipher[0])\n\n        def test_selected_npn_protocol(self):\n            # selected_npn_protocol() is None unless NPN is used\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            self.assertIs(stats['client_npn_protocol'], None)\n\n        @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")\n        def test_npn_protocols(self):\n            server_protocols = ['http/1.1', 'spdy/2']\n            protocol_tests = [\n                (['http/1.1', 'spdy/2'], 'http/1.1'),\n                (['spdy/2', 'http/1.1'], 'http/1.1'),\n                (['spdy/2', 'test'], 'spdy/2'),\n                (['abc', 'def'], 'abc')\n            ]\n            for client_protocols, expected in protocol_tests:\n                server_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n                server_context.load_cert_chain(CERTFILE)\n                server_context.set_npn_protocols(server_protocols)\n                client_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n                client_context.load_cert_chain(CERTFILE)\n                client_context.set_npn_protocols(client_protocols)\n                stats = server_params_test(client_context, server_context,\n                                           chatty=True, connectionchatty=True)\n\n                msg = \"failed trying %s (s) and %s (c).\\n\" \\\n                      \"was expecting %s, but got %%s from the %%s\" \\\n                          % (str(server_protocols), str(client_protocols),\n                             str(expected))\n                client_result = stats['client_npn_protocol']\n                self.assertEqual(client_result, expected, msg % (client_result, \"client\"))\n                server_result = stats['server_npn_protocols'][-1] \\\n                    if len(stats['server_npn_protocols']) else 'nothing'\n                self.assertEqual(server_result, expected, msg % (server_result, \"server\"))\n\n        def sni_contexts(self):\n            server_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            server_context.load_cert_chain(SIGNED_CERTFILE)\n            other_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            other_context.load_cert_chain(SIGNED_CERTFILE2)\n            client_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            client_context.verify_mode = ssl.CERT_REQUIRED\n            client_context.load_verify_locations(SIGNING_CA)\n            return server_context, other_context, client_context\n\n        def check_common_name(self, stats, name):\n            cert = stats['peercert']\n            self.assertIn((('commonName', name),), cert['subject'])\n\n        @needs_sni\n        def test_sni_callback(self):\n            calls = []\n            server_context, other_context, client_context = self.sni_contexts()\n\n            def servername_cb(ssl_sock, server_name, initial_context):\n                calls.append((server_name, initial_context))\n                if server_name is not None:\n                    ssl_sock.context = other_context\n            server_context.set_servername_callback(servername_cb)\n\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True,\n                                       sni_name='supermessage')\n            # The hostname was fetched properly, and the certificate was\n            # changed for the connection.\n            self.assertEqual(calls, [(\"supermessage\", server_context)])\n            # CERTFILE4 was selected\n            self.check_common_name(stats, 'fakehostname')\n\n            calls = []\n            # The callback is called with server_name=None\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True,\n                                       sni_name=None)\n            self.assertEqual(calls, [(None, server_context)])\n            self.check_common_name(stats, 'localhost')\n\n            # Check disabling the callback\n            calls = []\n            server_context.set_servername_callback(None)\n\n            stats = server_params_test(client_context, server_context,\n                                       chatty=True,\n                                       sni_name='notfunny')\n            # Certificate didn't change\n            self.check_common_name(stats, 'localhost')\n            self.assertEqual(calls, [])\n\n        @needs_sni\n        def test_sni_callback_alert(self):\n            # Returning a TLS alert is reflected to the connecting client\n            server_context, other_context, client_context = self.sni_contexts()\n\n            def cb_returning_alert(ssl_sock, server_name, initial_context):\n                return ssl.ALERT_DESCRIPTION_ACCESS_DENIED\n            server_context.set_servername_callback(cb_returning_alert)\n\n            with self.assertRaises(ssl.SSLError) as cm:\n                stats = server_params_test(client_context, server_context,\n                                           chatty=False,\n                                           sni_name='supermessage')\n            self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_ACCESS_DENIED')\n\n        @needs_sni\n        def test_sni_callback_raising(self):\n            # Raising fails the connection with a TLS handshake failure alert.\n            server_context, other_context, client_context = self.sni_contexts()\n\n            def cb_raising(ssl_sock, server_name, initial_context):\n                1/0\n            server_context.set_servername_callback(cb_raising)\n\n            with self.assertRaises(ssl.SSLError) as cm, \\\n                 support.captured_stderr() as stderr:\n                stats = server_params_test(client_context, server_context,\n                                           chatty=False,\n                                           sni_name='supermessage')\n            self.assertEqual(cm.exception.reason, 'SSLV3_ALERT_HANDSHAKE_FAILURE')\n            self.assertIn(\"ZeroDivisionError\", stderr.getvalue())\n\n        @needs_sni\n        def test_sni_callback_wrong_return_type(self):\n            # Returning the wrong return type terminates the TLS connection\n            # with an internal error alert.\n            server_context, other_context, client_context = self.sni_contexts()\n\n            def cb_wrong_return_type(ssl_sock, server_name, initial_context):\n                return \"foo\"\n            server_context.set_servername_callback(cb_wrong_return_type)\n\n            with self.assertRaises(ssl.SSLError) as cm, \\\n                 support.captured_stderr() as stderr:\n                stats = server_params_test(client_context, server_context,\n                                           chatty=False,\n                                           sni_name='supermessage')\n            self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_INTERNAL_ERROR')\n            self.assertIn(\"TypeError\", stderr.getvalue())\n\n        def test_read_write_after_close_raises_valuerror(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = ThreadedEchoServer(context=context, chatty=False)\n\n            with server:\n                s = context.wrap_socket(socket.socket())\n                s.connect((HOST, server.port))\n                s.close()\n\n                self.assertRaises(ValueError, s.read, 1024)\n                self.assertRaises(ValueError, s.write, b'hello')\n\n\ndef test_main(verbose=False):\n    if support.verbose:\n        plats = {\n            'Linux': platform.linux_distribution,\n            'Mac': platform.mac_ver,\n            'Windows': platform.win32_ver,\n        }\n        for name, func in plats.items():\n            plat = func()\n            if plat and plat[0]:\n                plat = '%s %r' % (name, plat)\n                break\n        else:\n            plat = repr(platform.platform())\n        print(\"test_ssl: testing with %r %r\" %\n            (ssl.OPENSSL_VERSION, ssl.OPENSSL_VERSION_INFO))\n        print(\"          under %s\" % plat)\n        print(\"          HAS_SNI = %r\" % ssl.HAS_SNI)\n        print(\"          OP_ALL = 0x%8x\" % ssl.OP_ALL)\n        try:\n            print(\"          OP_NO_TLSv1_1 = 0x%8x\" % ssl.OP_NO_TLSv1_1)\n        except AttributeError:\n            pass\n\n    for filename in [\n        CERTFILE, SVN_PYTHON_ORG_ROOT_CERT, BYTES_CERTFILE,\n        ONLYCERT, ONLYKEY, BYTES_ONLYCERT, BYTES_ONLYKEY,\n        SIGNED_CERTFILE, SIGNED_CERTFILE2, SIGNING_CA,\n        BADCERT, BADKEY, EMPTYCERT]:\n        if not os.path.exists(filename):\n            raise support.TestFailed(\"Can't read certificate file %r\" % filename)\n\n    tests = [ContextTests, BasicSocketTests, SSLErrorTests]\n\n    if support.is_resource_enabled('network'):\n        tests.append(NetworkedTests)\n\n    if _have_threads:\n        thread_info = support.threading_setup()\n        if thread_info:\n            tests.append(ThreadedTests)\n\n    try:\n        support.run_unittest(*tests)\n    finally:\n        if _have_threads:\n            support.threading_cleanup(*thread_info)\n\nif __name__ == \"__main__\":\n    test_main()\n"
  },
  {
    "patch": "diff --git a/Lib/test/test_ssl.py b/Lib/test/test_ssl.py\nindex 1c4aa7ca1e0..0ecf4a1226f 100644\n--- a/Lib/test/test_ssl.py\n+++ b/Lib/test/test_ssl.py\n@@ -55,6 +55,7 @@\n WRONGCERT = data_file(\"XXXnonexisting.pem\")\n BADKEY = data_file(\"badkey.pem\")\n NOKIACERT = data_file(\"nokia.pem\")\n+NULLBYTECERT = data_file(\"nullbytecert.pem\")\n \n DHFILE = data_file(\"dh512.pem\")\n BYTES_DHFILE = os.fsencode(DHFILE)\n@@ -162,6 +163,27 @@ def test_parse_cert(self):\n                           ('DNS', 'projects.forum.nokia.com'))\n                         )\n \n+    def test_parse_cert_CVE_2013_4238(self):\n+        p = ssl._ssl._test_decode_cert(NULLBYTECERT)\n+        if support.verbose:\n+            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n+        subject = ((('countryName', 'US'),),\n+                   (('stateOrProvinceName', 'Oregon'),),\n+                   (('localityName', 'Beaverton'),),\n+                   (('organizationName', 'Python Software Foundation'),),\n+                   (('organizationalUnitName', 'Python Core Development'),),\n+                   (('commonName', 'null.python.org\\x00example.org'),),\n+                   (('emailAddress', 'python-dev@python.org'),))\n+        self.assertEqual(p['subject'], subject)\n+        self.assertEqual(p['issuer'], subject)\n+        self.assertEqual(p['subjectAltName'],\n+                         (('DNS', 'altnull.python.org\\x00example.com'),\n+                         ('email', 'null@python.org\\x00user@example.org'),\n+                         ('URI', 'http://null.python.org\\x00http://example.org'),\n+                         ('IP Address', '192.0.2.1'),\n+                         ('IP Address', '2001:DB8:0:0:0:0:0:1\\n'))\n+                        )\n+\n     def test_DER_to_PEM(self):\n         with open(SVN_PYTHON_ORG_ROOT_CERT, 'r') as f:\n             pem = f.read()\n@@ -294,6 +316,13 @@ def fail(cert, hostname):\n         fail(cert, 'foo.a.com')\n         fail(cert, 'bar.foo.com')\n \n+        # NULL bytes are bad, CVE-2013-4073\n+        cert = {'subject': ((('commonName',\n+                              'null.python.org\\x00example.org'),),)}\n+        ok(cert, 'null.python.org\\x00example.org') # or raise an error?\n+        fail(cert, 'example.org')\n+        fail(cert, 'null.python.org')\n+\n         # Slightly fake real-world example\n         cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                 'subject': ((('commonName', 'linuxfrz.org'),),),\n",
    "commit_message": "Issue #18709: Fix CVE-2013-4238. The SSL module now handles NULL bytes\ninside subjectAltName correctly. Formerly the module has used OpenSSL's\nGENERAL_NAME_print() function to get the string represention of ASN.1\nstrings for rfc822Name (email), dNSName (DNS) and\nuniformResourceIdentifier (URI).\n\n",
    "code_before": "# Test the support for SSL and sockets\n\nimport sys\nimport unittest\nfrom test import support\nimport socket\nimport select\nimport time\nimport gc\nimport os\nimport errno\nimport pprint\nimport tempfile\nimport urllib.request\nimport traceback\nimport asyncore\nimport weakref\nimport platform\nimport functools\n\nssl = support.import_module(\"ssl\")\n\nPROTOCOLS = [\n    ssl.PROTOCOL_SSLv3,\n    ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1\n]\nif hasattr(ssl, 'PROTOCOL_SSLv2'):\n    PROTOCOLS.append(ssl.PROTOCOL_SSLv2)\n\nHOST = support.HOST\n\ndata_file = lambda name: os.path.join(os.path.dirname(__file__), name)\n\n# The custom key and certificate files used in test_ssl are generated\n# using Lib/test/make_ssl_certs.py.\n# Other certificates are simply fetched from the Internet servers they\n# are meant to authenticate.\n\nCERTFILE = data_file(\"keycert.pem\")\nBYTES_CERTFILE = os.fsencode(CERTFILE)\nONLYCERT = data_file(\"ssl_cert.pem\")\nONLYKEY = data_file(\"ssl_key.pem\")\nBYTES_ONLYCERT = os.fsencode(ONLYCERT)\nBYTES_ONLYKEY = os.fsencode(ONLYKEY)\nCERTFILE_PROTECTED = data_file(\"keycert.passwd.pem\")\nONLYKEY_PROTECTED = data_file(\"ssl_key.passwd.pem\")\nKEY_PASSWORD = \"somepass\"\nCAPATH = data_file(\"capath\")\nBYTES_CAPATH = os.fsencode(CAPATH)\n\nSVN_PYTHON_ORG_ROOT_CERT = data_file(\"https_svn_python_org_root.pem\")\n\nEMPTYCERT = data_file(\"nullcert.pem\")\nBADCERT = data_file(\"badcert.pem\")\nWRONGCERT = data_file(\"XXXnonexisting.pem\")\nBADKEY = data_file(\"badkey.pem\")\nNOKIACERT = data_file(\"nokia.pem\")\n\nDHFILE = data_file(\"dh512.pem\")\nBYTES_DHFILE = os.fsencode(DHFILE)\n\ndef handle_error(prefix):\n    exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))\n    if support.verbose:\n        sys.stdout.write(prefix + exc_format)\n\ndef can_clear_options():\n    # 0.9.8m or higher\n    return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)\n\ndef no_sslv2_implies_sslv3_hello():\n    # 0.9.7h or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)\n\n\n# Issue #9415: Ubuntu hijacks their OpenSSL and forcefully disables SSLv2\ndef skip_if_broken_ubuntu_ssl(func):\n    if hasattr(ssl, 'PROTOCOL_SSLv2'):\n        @functools.wraps(func)\n        def f(*args, **kwargs):\n            try:\n                ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n            except ssl.SSLError:\n                if (ssl.OPENSSL_VERSION_INFO == (0, 9, 8, 15, 15) and\n                    platform.linux_distribution() == ('debian', 'squeeze/sid', '')):\n                    raise unittest.SkipTest(\"Patched Ubuntu OpenSSL breaks behaviour\")\n            return func(*args, **kwargs)\n        return f\n    else:\n        return func\n\n\nclass BasicSocketTests(unittest.TestCase):\n\n    def test_constants(self):\n        #ssl.PROTOCOL_SSLv2\n        ssl.PROTOCOL_SSLv23\n        ssl.PROTOCOL_SSLv3\n        ssl.PROTOCOL_TLSv1\n        ssl.CERT_NONE\n        ssl.CERT_OPTIONAL\n        ssl.CERT_REQUIRED\n        ssl.OP_CIPHER_SERVER_PREFERENCE\n        ssl.OP_SINGLE_DH_USE\n        if ssl.HAS_ECDH:\n            ssl.OP_SINGLE_ECDH_USE\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0):\n            ssl.OP_NO_COMPRESSION\n        self.assertIn(ssl.HAS_SNI, {True, False})\n        self.assertIn(ssl.HAS_ECDH, {True, False})\n\n    def test_random(self):\n        v = ssl.RAND_status()\n        if support.verbose:\n            sys.stdout.write(\"\\n RAND_status is %d (%s)\\n\"\n                             % (v, (v and \"sufficient randomness\") or\n                                \"insufficient randomness\"))\n\n        data, is_cryptographic = ssl.RAND_pseudo_bytes(16)\n        self.assertEqual(len(data), 16)\n        self.assertEqual(is_cryptographic, v == 1)\n        if v:\n            data = ssl.RAND_bytes(16)\n            self.assertEqual(len(data), 16)\n        else:\n            self.assertRaises(ssl.SSLError, ssl.RAND_bytes, 16)\n\n        self.assertRaises(TypeError, ssl.RAND_egd, 1)\n        self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)\n        ssl.RAND_add(\"this is a random string\", 75.0)\n\n    def test_parse_cert(self):\n        # note that this uses an 'unofficial' function in _ssl.c,\n        # provided solely for this test, to exercise the certificate\n        # parsing code\n        p = ssl._ssl._test_decode_cert(CERTFILE)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['issuer'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['notAfter'], 'Oct  5 23:01:56 2020 GMT')\n        self.assertEqual(p['notBefore'], 'Oct  8 23:01:56 2010 GMT')\n        self.assertEqual(p['serialNumber'], 'D7C7381919AFC24E')\n        self.assertEqual(p['subject'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['subjectAltName'], (('DNS', 'localhost'),))\n        # Issue #13034: the subjectAltName in some certificates\n        # (notably projects.developer.nokia.com:443) wasn't parsed\n        p = ssl._ssl._test_decode_cert(NOKIACERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'projects.developer.nokia.com'),\n                          ('DNS', 'projects.forum.nokia.com'))\n                        )\n\n    def test_DER_to_PEM(self):\n        with open(SVN_PYTHON_ORG_ROOT_CERT, 'r') as f:\n            pem = f.read()\n        d1 = ssl.PEM_cert_to_DER_cert(pem)\n        p2 = ssl.DER_cert_to_PEM_cert(d1)\n        d2 = ssl.PEM_cert_to_DER_cert(p2)\n        self.assertEqual(d1, d2)\n        if not p2.startswith(ssl.PEM_HEADER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct header:\\n%r\\n\" % p2)\n        if not p2.endswith('\\n' + ssl.PEM_FOOTER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct footer:\\n%r\\n\" % p2)\n\n    def test_openssl_version(self):\n        n = ssl.OPENSSL_VERSION_NUMBER\n        t = ssl.OPENSSL_VERSION_INFO\n        s = ssl.OPENSSL_VERSION\n        self.assertIsInstance(n, int)\n        self.assertIsInstance(t, tuple)\n        self.assertIsInstance(s, str)\n        # Some sanity checks follow\n        # >= 0.9\n        self.assertGreaterEqual(n, 0x900000)\n        # < 2.0\n        self.assertLess(n, 0x20000000)\n        major, minor, fix, patch, status = t\n        self.assertGreaterEqual(major, 0)\n        self.assertLess(major, 2)\n        self.assertGreaterEqual(minor, 0)\n        self.assertLess(minor, 256)\n        self.assertGreaterEqual(fix, 0)\n        self.assertLess(fix, 256)\n        self.assertGreaterEqual(patch, 0)\n        self.assertLessEqual(patch, 26)\n        self.assertGreaterEqual(status, 0)\n        self.assertLessEqual(status, 15)\n        # Version string as returned by OpenSSL, the format might change\n        self.assertTrue(s.startswith(\"OpenSSL {:d}.{:d}.{:d}\".format(major, minor, fix)),\n                        (s, t))\n\n    @support.cpython_only\n    def test_refcycle(self):\n        # Issue #7943: an SSL object doesn't create reference cycles with\n        # itself.\n        s = socket.socket(socket.AF_INET)\n        ss = ssl.wrap_socket(s)\n        wr = weakref.ref(ss)\n        with support.check_warnings((\"\", ResourceWarning)):\n            del ss\n            self.assertEqual(wr(), None)\n\n    def test_wrapped_unconnected(self):\n        # Methods on an unconnected SSLSocket propagate the original\n        # socket.error raise by the underlying socket object.\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            self.assertRaises(socket.error, ss.recv, 1)\n            self.assertRaises(socket.error, ss.recv_into, bytearray(b'x'))\n            self.assertRaises(socket.error, ss.recvfrom, 1)\n            self.assertRaises(socket.error, ss.recvfrom_into, bytearray(b'x'), 1)\n            self.assertRaises(socket.error, ss.send, b'x')\n            self.assertRaises(socket.error, ss.sendto, b'x', ('0.0.0.0', 0))\n\n    def test_timeout(self):\n        # Issue #8524: when creating an SSL socket, the timeout of the\n        # original socket should be retained.\n        for timeout in (None, 0.0, 5.0):\n            s = socket.socket(socket.AF_INET)\n            s.settimeout(timeout)\n            with ssl.wrap_socket(s) as ss:\n                self.assertEqual(timeout, ss.gettimeout())\n\n    def test_errors(self):\n        sock = socket.socket()\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified\",\n                        ssl.wrap_socket, sock, keyfile=CERTFILE)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True, certfile=\"\")\n        with ssl.wrap_socket(sock, server_side=True, certfile=CERTFILE) as s:\n            self.assertRaisesRegex(ValueError, \"can't connect in server-side mode\",\n                                    s.connect, (HOST, 8080))\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=CERTFILE, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n\n    def test_match_hostname(self):\n        def ok(cert, hostname):\n            ssl.match_hostname(cert, hostname)\n        def fail(cert, hostname):\n            self.assertRaises(ssl.CertificateError,\n                              ssl.match_hostname, cert, hostname)\n\n        cert = {'subject': ((('commonName', 'example.com'),),)}\n        ok(cert, 'example.com')\n        ok(cert, 'ExAmple.cOm')\n        fail(cert, 'www.example.com')\n        fail(cert, '.example.com')\n        fail(cert, 'example.org')\n        fail(cert, 'exampleXcom')\n\n        cert = {'subject': ((('commonName', '*.a.com'),),)}\n        ok(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        cert = {'subject': ((('commonName', 'a.*.com'),),)}\n        ok(cert, 'a.foo.com')\n        fail(cert, 'a..com')\n        fail(cert, 'a.com')\n\n        cert = {'subject': ((('commonName', 'f*.com'),),)}\n        ok(cert, 'foo.com')\n        ok(cert, 'f.com')\n        fail(cert, 'bar.com')\n        fail(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.com')\n\n        # Slightly fake real-world example\n        cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                'subject': ((('commonName', 'linuxfrz.org'),),),\n                'subjectAltName': (('DNS', 'linuxfr.org'),\n                                   ('DNS', 'linuxfr.com'),\n                                   ('othername', '<unsupported>'))}\n        ok(cert, 'linuxfr.org')\n        ok(cert, 'linuxfr.com')\n        # Not a \"DNS\" entry\n        fail(cert, '<unsupported>')\n        # When there is a subjectAltName, commonName isn't used\n        fail(cert, 'linuxfrz.org')\n\n        # A pristine real-world example\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),),\n                            (('commonName', 'mail.google.com'),))}\n        ok(cert, 'mail.google.com')\n        fail(cert, 'gmail.com')\n        # Only commonName is considered\n        fail(cert, 'California')\n\n        # Neither commonName nor subjectAltName\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),))}\n        fail(cert, 'mail.google.com')\n\n        # No DNS entry in subjectAltName but a commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('commonName', 'mail.google.com'),)),\n                'subjectAltName': (('othername', 'blabla'), )}\n        ok(cert, 'mail.google.com')\n\n        # No DNS entry subjectAltName and no commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),)),\n                'subjectAltName': (('othername', 'blabla'),)}\n        fail(cert, 'google.com')\n\n        # Empty cert / no cert\n        self.assertRaises(ValueError, ssl.match_hostname, None, 'example.com')\n        self.assertRaises(ValueError, ssl.match_hostname, {}, 'example.com')\n\n        # Issue #17980: avoid denials of service by refusing more than one\n        # wildcard per fragment.\n        cert = {'subject': ((('commonName', 'a*b.com'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b.co*'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b*.com'),),)}\n        with self.assertRaises(ssl.CertificateError) as cm:\n            ssl.match_hostname(cert, 'axxbxxc.com')\n        self.assertIn(\"too many wildcards\", str(cm.exception))\n\n    def test_server_side(self):\n        # server_hostname doesn't work for server sockets\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        with socket.socket() as sock:\n            self.assertRaises(ValueError, ctx.wrap_socket, sock, True,\n                              server_hostname=\"some.hostname\")\n\n    def test_unknown_channel_binding(self):\n        # should raise ValueError for unknown type\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            with self.assertRaises(ValueError):\n                ss.get_channel_binding(\"unknown-type\")\n\n    @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                         \"'tls-unique' channel binding not available\")\n    def test_tls_unique_channel_binding(self):\n        # unconnected should return None for known type\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n        # the same for server-side\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s, server_side=True, certfile=CERTFILE) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n\n    def test_dealloc_warn(self):\n        ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n        r = repr(ss)\n        with self.assertWarns(ResourceWarning) as cm:\n            ss = None\n            support.gc_collect()\n        self.assertIn(r, str(cm.warning.args[0]))\n\nclass ContextTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_constructor(self):\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        self.assertRaises(TypeError, ssl.SSLContext)\n        self.assertRaises(ValueError, ssl.SSLContext, -1)\n        self.assertRaises(ValueError, ssl.SSLContext, 42)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.protocol, proto)\n\n    def test_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ciphers(\"ALL\")\n        ctx.set_ciphers(\"DEFAULT\")\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            ctx.set_ciphers(\"^$:,;?*'dorothyx\")\n\n    @skip_if_broken_ubuntu_ssl\n    def test_options(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # OP_ALL is the default value\n        self.assertEqual(ssl.OP_ALL, ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv2\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2,\n                         ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv3\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3,\n                         ctx.options)\n        if can_clear_options():\n            ctx.options = (ctx.options & ~ssl.OP_NO_SSLv2) | ssl.OP_NO_TLSv1\n            self.assertEqual(ssl.OP_ALL | ssl.OP_NO_TLSv1 | ssl.OP_NO_SSLv3,\n                             ctx.options)\n            ctx.options = 0\n            self.assertEqual(0, ctx.options)\n        else:\n            with self.assertRaises(ValueError):\n                ctx.options = 0\n\n    def test_verify(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Default value\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        with self.assertRaises(TypeError):\n            ctx.verify_mode = None\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = 42\n\n    def test_load_cert_chain(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Combined key and cert in a single file\n        ctx.load_cert_chain(CERTFILE)\n        ctx.load_cert_chain(CERTFILE, keyfile=CERTFILE)\n        self.assertRaises(TypeError, ctx.load_cert_chain, keyfile=CERTFILE)\n        with self.assertRaises(IOError) as cm:\n            ctx.load_cert_chain(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(BADCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(EMPTYCERT)\n        # Separate key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY)\n        ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)\n        ctx.load_cert_chain(certfile=BYTES_ONLYCERT, keyfile=BYTES_ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)\n        # Mismatching key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaisesRegex(ssl.SSLError, \"key values mismatch\"):\n            ctx.load_cert_chain(SVN_PYTHON_ORG_ROOT_CERT, ONLYKEY)\n        # Password protected key and cert\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD.encode())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=bytearray(KEY_PASSWORD.encode()))\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD.encode())\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED,\n                            bytearray(KEY_PASSWORD.encode()))\n        with self.assertRaisesRegex(TypeError, \"should be a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=True)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=\"badpass\")\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            # openssl has a fixed limit on the password buffer.\n            # PEM_BUFSIZE is generally set to 1kb.\n            # Return a string larger than this.\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=b'a' * 102400)\n        # Password callback\n        def getpass_unicode():\n            return KEY_PASSWORD\n        def getpass_bytes():\n            return KEY_PASSWORD.encode()\n        def getpass_bytearray():\n            return bytearray(KEY_PASSWORD.encode())\n        def getpass_badpass():\n            return \"badpass\"\n        def getpass_huge():\n            return b'a' * (1024 * 1024)\n        def getpass_bad_type():\n            return 9\n        def getpass_exception():\n            raise Exception('getpass error')\n        class GetPassCallable:\n            def __call__(self):\n                return KEY_PASSWORD\n            def getpass(self):\n                return KEY_PASSWORD\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_unicode)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytes)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytearray)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=GetPassCallable())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=GetPassCallable().getpass)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_badpass)\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_huge)\n        with self.assertRaisesRegex(TypeError, \"must return a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bad_type)\n        with self.assertRaisesRegex(Exception, \"getpass error\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_exception)\n        # Make sure the password function isn't called if it isn't needed\n        ctx.load_cert_chain(CERTFILE, password=getpass_exception)\n\n    def test_load_verify_locations(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_verify_locations(CERTFILE)\n        ctx.load_verify_locations(cafile=CERTFILE, capath=None)\n        ctx.load_verify_locations(BYTES_CERTFILE)\n        ctx.load_verify_locations(cafile=BYTES_CERTFILE, capath=None)\n        self.assertRaises(TypeError, ctx.load_verify_locations)\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, None)\n        with self.assertRaises(IOError) as cm:\n            ctx.load_verify_locations(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_verify_locations(BADCERT)\n        ctx.load_verify_locations(CERTFILE, CAPATH)\n        ctx.load_verify_locations(CERTFILE, capath=BYTES_CAPATH)\n\n        # Issue #10989: crash if the second argument type is invalid\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, True)\n\n    def test_load_dh_params(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_dh_params(DHFILE)\n        if os.name != 'nt':\n            ctx.load_dh_params(BYTES_DHFILE)\n        self.assertRaises(TypeError, ctx.load_dh_params)\n        self.assertRaises(TypeError, ctx.load_dh_params, None)\n        with self.assertRaises(FileNotFoundError) as cm:\n            ctx.load_dh_params(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_session_stats(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.session_stats(), {\n                'number': 0,\n                'connect': 0,\n                'connect_good': 0,\n                'connect_renegotiate': 0,\n                'accept': 0,\n                'accept_good': 0,\n                'accept_renegotiate': 0,\n                'hits': 0,\n                'misses': 0,\n                'timeouts': 0,\n                'cache_full': 0,\n            })\n\n    def test_set_default_verify_paths(self):\n        # There's not much we can do to test that it acts as expected,\n        # so just check it doesn't crash or raise an exception.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_default_verify_paths()\n\n    @unittest.skipUnless(ssl.HAS_ECDH, \"ECDH disabled on this OpenSSL build\")\n    def test_set_ecdh_curve(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ecdh_curve(\"prime256v1\")\n        ctx.set_ecdh_curve(b\"prime256v1\")\n        self.assertRaises(TypeError, ctx.set_ecdh_curve)\n        self.assertRaises(TypeError, ctx.set_ecdh_curve, None)\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, \"foo\")\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, b\"foo\")\n\n\nclass SSLErrorTests(unittest.TestCase):\n\n    def test_str(self):\n        # The str() of a SSLError doesn't include the errno\n        e = ssl.SSLError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n        # Same for a subclass\n        e = ssl.SSLZeroReturnError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n\n    def test_lib_reason(self):\n        # Test the library and reason attributes\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n        self.assertEqual(cm.exception.library, 'PEM')\n        self.assertEqual(cm.exception.reason, 'NO_START_LINE')\n        s = str(cm.exception)\n        self.assertTrue(s.startswith(\"[PEM: NO_START_LINE] no start line\"), s)\n\n    def test_subclass(self):\n        # Check that the appropriate SSLError subclass is raised\n        # (this only tests one of them)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with socket.socket() as s:\n            s.bind((\"127.0.0.1\", 0))\n            s.listen(5)\n            c = socket.socket()\n            c.connect(s.getsockname())\n            c.setblocking(False)\n            with ctx.wrap_socket(c, False, do_handshake_on_connect=False) as c:\n                with self.assertRaises(ssl.SSLWantReadError) as cm:\n                    c.do_handshake()\n                s = str(cm.exception)\n                self.assertTrue(s.startswith(\"The operation did not complete (read)\"), s)\n                # For compatibility\n                self.assertEqual(cm.exception.errno, ssl.SSL_ERROR_WANT_READ)\n\n\nclass NetworkedTests(unittest.TestCase):\n\n    def test_connect(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n\n            # this should fail because we have no verification certs\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED)\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                   s.connect, (\"svn.python.org\", 443))\n            s.close()\n\n            # this should succeed because we specify the root cert\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_connect_ex(self):\n        # Issue #11326: check connect_ex() implementation\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(0, s.connect_ex((\"svn.python.org\", 443)))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_non_blocking_connect_ex(self):\n        # Issue #11326: non-blocking connect_ex() should allow handshake\n        # to proceed after the socket gets ready.\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.setblocking(False)\n                rc = s.connect_ex(('svn.python.org', 443))\n                # EWOULDBLOCK under Windows, EINPROGRESS elsewhere\n                self.assertIn(rc, (0, errno.EINPROGRESS, errno.EWOULDBLOCK))\n                # Wait for connect to finish\n                select.select([], [s], [], 5.0)\n                # Non-blocking handshake\n                while True:\n                    try:\n                        s.do_handshake()\n                        break\n                    except ssl.SSLWantReadError:\n                        select.select([s], [], [], 5.0)\n                    except ssl.SSLWantWriteError:\n                        select.select([], [s], [], 5.0)\n                # SSL established\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_timeout_connect_ex(self):\n        # Issue #12065: on a timeout, connect_ex() should return the original\n        # errno (mimicking the behaviour of non-SSL sockets).\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.settimeout(0.0000001)\n                rc = s.connect_ex(('svn.python.org', 443))\n                if rc == 0:\n                    self.skipTest(\"svn.python.org responded too quickly\")\n                self.assertIn(rc, (errno.EAGAIN, errno.EWOULDBLOCK))\n            finally:\n                s.close()\n\n    def test_connect_ex_error(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(errno.ECONNREFUSED,\n                                 s.connect_ex((\"svn.python.org\", 444)))\n            finally:\n                s.close()\n\n    def test_connect_with_context(self):\n        with support.transient_internet(\"svn.python.org\"):\n            # Same as test_connect, but with a separately created context\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n            # Same with a server hostname\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"svn.python.org\")\n            if ssl.HAS_SNI:\n                s.connect((\"svn.python.org\", 443))\n                s.close()\n            else:\n                self.assertRaises(ValueError, s.connect, (\"svn.python.org\", 443))\n            # This should fail because we have no verification certs\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                    s.connect, (\"svn.python.org\", 443))\n            s.close()\n            # This should succeed because we specify the root cert\n            ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    def test_connect_capath(self):\n        # Verify server certificates using the `capath` argument\n        # NOTE: the subject hashing algorithm has been changed between\n        # OpenSSL 0.9.8n and 1.0.0, as a result the capath directory must\n        # contain both versions of each certificate (same content, different\n        # filename) for this test to be portable across OpenSSL releases.\n        with support.transient_internet(\"svn.python.org\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n            # Same with a bytes `capath` argument\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=BYTES_CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    @unittest.skipIf(os.name == \"nt\", \"Can't use a socket as a file under Windows\")\n    def test_makefile_close(self):\n        # Issue #5238: creating a file-like object with makefile() shouldn't\n        # delay closing the underlying \"real socket\" (here tested with its\n        # file descriptor, hence skipping the test under Windows).\n        with support.transient_internet(\"svn.python.org\"):\n            ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n            ss.connect((\"svn.python.org\", 443))\n            fd = ss.fileno()\n            f = ss.makefile()\n            f.close()\n            # The fd is still open\n            os.read(fd, 0)\n            # Closing the SSL socket should close the fd too\n            ss.close()\n            gc.collect()\n            with self.assertRaises(OSError) as e:\n                os.read(fd, 0)\n            self.assertEqual(e.exception.errno, errno.EBADF)\n\n    def test_non_blocking_handshake(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = socket.socket(socket.AF_INET)\n            s.connect((\"svn.python.org\", 443))\n            s.setblocking(False)\n            s = ssl.wrap_socket(s,\n                                cert_reqs=ssl.CERT_NONE,\n                                do_handshake_on_connect=False)\n            count = 0\n            while True:\n                try:\n                    count += 1\n                    s.do_handshake()\n                    break\n                except ssl.SSLWantReadError:\n                    select.select([s], [], [])\n                except ssl.SSLWantWriteError:\n                    select.select([], [s], [])\n            s.close()\n            if support.verbose:\n                sys.stdout.write(\"\\nNeeded %d calls to do_handshake() to establish session.\\n\" % count)\n\n    def test_get_server_certificate(self):\n        def _test_get_server_certificate(host, port, cert=None):\n            with support.transient_internet(host):\n                pem = ssl.get_server_certificate((host, port))\n                if not pem:\n                    self.fail(\"No server certificate on %s:%s!\" % (host, port))\n\n                try:\n                    pem = ssl.get_server_certificate((host, port), ca_certs=CERTFILE)\n                except ssl.SSLError as x:\n                    #should fail\n                    if support.verbose:\n                        sys.stdout.write(\"%s\\n\" % x)\n                else:\n                    self.fail(\"Got server certificate %s for %s:%s!\" % (pem, host, port))\n\n                pem = ssl.get_server_certificate((host, port), ca_certs=cert)\n                if not pem:\n                    self.fail(\"No server certificate on %s:%s!\" % (host, port))\n                if support.verbose:\n                    sys.stdout.write(\"\\nVerified certificate for %s:%s is\\n%s\\n\" % (host, port ,pem))\n\n        _test_get_server_certificate('svn.python.org', 443, SVN_PYTHON_ORG_ROOT_CERT)\n        if support.IPV6_ENABLED:\n            _test_get_server_certificate('ipv6.google.com', 443)\n\n    def test_ciphers(self):\n        remote = (\"svn.python.org\", 443)\n        with support.transient_internet(remote[0]):\n            with ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                 cert_reqs=ssl.CERT_NONE, ciphers=\"ALL\") as s:\n                s.connect(remote)\n            with ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                 cert_reqs=ssl.CERT_NONE, ciphers=\"DEFAULT\") as s:\n                s.connect(remote)\n            # Error checking can happen at instantiation or when connecting\n            with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n                with socket.socket(socket.AF_INET) as sock:\n                    s = ssl.wrap_socket(sock,\n                                        cert_reqs=ssl.CERT_NONE, ciphers=\"^$:,;?*'dorothyx\")\n                    s.connect(remote)\n\n    def test_algorithms(self):\n        # Issue #8484: all algorithms should be available when verifying a\n        # certificate.\n        # SHA256 was added in OpenSSL 0.9.8\n        if ssl.OPENSSL_VERSION_INFO < (0, 9, 8, 0, 15):\n            self.skipTest(\"SHA256 not available on %r\" % ssl.OPENSSL_VERSION)\n        # sha256.tbs-internet.com needs SNI to use the correct certificate\n        if not ssl.HAS_SNI:\n            self.skipTest(\"SNI needed for this test\")\n        # https://sha2.hboeck.de/ was used until 2011-01-08 (no route to host)\n        remote = (\"sha256.tbs-internet.com\", 443)\n        sha256_cert = os.path.join(os.path.dirname(__file__), \"sha256.pem\")\n        with support.transient_internet(\"sha256.tbs-internet.com\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(sha256_cert)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"sha256.tbs-internet.com\")\n            try:\n                s.connect(remote)\n                if support.verbose:\n                    sys.stdout.write(\"\\nCipher with %r is %r\\n\" %\n                                     (remote, s.cipher()))\n                    sys.stdout.write(\"Certificate is:\\n%s\\n\" %\n                                     pprint.pformat(s.getpeercert()))\n            finally:\n                s.close()\n\n\ntry:\n    import threading\nexcept ImportError:\n    _have_threads = False\nelse:\n    _have_threads = True\n\n    from test.ssl_servers import make_https_server\n\n    class ThreadedEchoServer(threading.Thread):\n\n        class ConnectionHandler(threading.Thread):\n\n            \"\"\"A mildly complicated class, because we want it to work both\n            with and without the SSL wrapper around the socket connection, so\n            that we can test the STARTTLS functionality.\"\"\"\n\n            def __init__(self, server, connsock, addr):\n                self.server = server\n                self.running = False\n                self.sock = connsock\n                self.addr = addr\n                self.sock.setblocking(1)\n                self.sslconn = None\n                threading.Thread.__init__(self)\n                self.daemon = True\n\n            def wrap_conn(self):\n                try:\n                    self.sslconn = self.server.context.wrap_socket(\n                        self.sock, server_side=True)\n                    self.server.selected_protocols.append(self.sslconn.selected_npn_protocol())\n                except (ssl.SSLError, ConnectionResetError) as e:\n                    # We treat ConnectionResetError as though it were an\n                    # SSLError - OpenSSL on Ubuntu abruptly closes the\n                    # connection when asked to use an unsupported protocol.\n                    #\n                    # XXX Various errors can have happened here, for example\n                    # a mismatching protocol version, an invalid certificate,\n                    # or a low-level bug. This should be made more discriminating.\n                    self.server.conn_errors.append(e)\n                    if self.server.chatty:\n                        handle_error(\"\\n server:  bad connection attempt from \" + repr(self.addr) + \":\\n\")\n                    self.running = False\n                    self.server.stop()\n                    self.close()\n                    return False\n                else:\n                    if self.server.context.verify_mode == ssl.CERT_REQUIRED:\n                        cert = self.sslconn.getpeercert()\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" client cert is \" + pprint.pformat(cert) + \"\\n\")\n                        cert_binary = self.sslconn.getpeercert(True)\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" cert binary is \" + str(len(cert_binary)) + \" bytes\\n\")\n                    cipher = self.sslconn.cipher()\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" server: connection cipher is now \" + str(cipher) + \"\\n\")\n                        sys.stdout.write(\" server: selected protocol is now \"\n                                + str(self.sslconn.selected_npn_protocol()) + \"\\n\")\n                    return True\n\n            def read(self):\n                if self.sslconn:\n                    return self.sslconn.read()\n                else:\n                    return self.sock.recv(1024)\n\n            def write(self, bytes):\n                if self.sslconn:\n                    return self.sslconn.write(bytes)\n                else:\n                    return self.sock.send(bytes)\n\n            def close(self):\n                if self.sslconn:\n                    self.sslconn.close()\n                else:\n                    self.sock.close()\n\n            def run(self):\n                self.running = True\n                if not self.server.starttls_server:\n                    if not self.wrap_conn():\n                        return\n                while self.running:\n                    try:\n                        msg = self.read()\n                        stripped = msg.strip()\n                        if not stripped:\n                            # eof, so quit this handler\n                            self.running = False\n                            self.close()\n                        elif stripped == b'over':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: client closed connection\\n\")\n                            self.close()\n                            return\n                        elif (self.server.starttls_server and\n                              stripped == b'STARTTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read STARTTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            if not self.wrap_conn():\n                                return\n                        elif (self.server.starttls_server and self.sslconn\n                              and stripped == b'ENDTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read ENDTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            self.sock = self.sslconn.unwrap()\n                            self.sslconn = None\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: connection is now unencrypted...\\n\")\n                        elif stripped == b'CB tls-unique':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read CB tls-unique from client, sending our CB data...\\n\")\n                            data = self.sslconn.get_channel_binding(\"tls-unique\")\n                            self.write(repr(data).encode(\"us-ascii\") + b\"\\n\")\n                        else:\n                            if (support.verbose and\n                                self.server.connectionchatty):\n                                ctype = (self.sslconn and \"encrypted\") or \"unencrypted\"\n                                sys.stdout.write(\" server: read %r (%s), sending back %r (%s)...\\n\"\n                                                 % (msg, ctype, msg.lower(), ctype))\n                            self.write(msg.lower())\n                    except socket.error:\n                        if self.server.chatty:\n                            handle_error(\"Test server failure:\\n\")\n                        self.close()\n                        self.running = False\n                        # normally, we'd just stop here, but for the test\n                        # harness, we want to stop the server\n                        self.server.stop()\n\n        def __init__(self, certificate=None, ssl_version=None,\n                     certreqs=None, cacerts=None,\n                     chatty=True, connectionchatty=False, starttls_server=False,\n                     npn_protocols=None, ciphers=None, context=None):\n            if context:\n                self.context = context\n            else:\n                self.context = ssl.SSLContext(ssl_version\n                                              if ssl_version is not None\n                                              else ssl.PROTOCOL_TLSv1)\n                self.context.verify_mode = (certreqs if certreqs is not None\n                                            else ssl.CERT_NONE)\n                if cacerts:\n                    self.context.load_verify_locations(cacerts)\n                if certificate:\n                    self.context.load_cert_chain(certificate)\n                if npn_protocols:\n                    self.context.set_npn_protocols(npn_protocols)\n                if ciphers:\n                    self.context.set_ciphers(ciphers)\n            self.chatty = chatty\n            self.connectionchatty = connectionchatty\n            self.starttls_server = starttls_server\n            self.sock = socket.socket()\n            self.port = support.bind_port(self.sock)\n            self.flag = None\n            self.active = False\n            self.selected_protocols = []\n            self.conn_errors = []\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            self.stop()\n            self.join()\n\n        def start(self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.sock.settimeout(0.05)\n            self.sock.listen(5)\n            self.active = True\n            if self.flag:\n                # signal an event\n                self.flag.set()\n            while self.active:\n                try:\n                    newconn, connaddr = self.sock.accept()\n                    if support.verbose and self.chatty:\n                        sys.stdout.write(' server:  new connection from '\n                                         + repr(connaddr) + '\\n')\n                    handler = self.ConnectionHandler(self, newconn, connaddr)\n                    handler.start()\n                    handler.join()\n                except socket.timeout:\n                    pass\n                except KeyboardInterrupt:\n                    self.stop()\n            self.sock.close()\n\n        def stop(self):\n            self.active = False\n\n    class AsyncoreEchoServer(threading.Thread):\n\n        # this one's based on asyncore.dispatcher\n\n        class EchoServer (asyncore.dispatcher):\n\n            class ConnectionHandler (asyncore.dispatcher_with_send):\n\n                def __init__(self, conn, certfile):\n                    self.socket = ssl.wrap_socket(conn, server_side=True,\n                                                  certfile=certfile,\n                                                  do_handshake_on_connect=False)\n                    asyncore.dispatcher_with_send.__init__(self, self.socket)\n                    self._ssl_accepting = True\n                    self._do_ssl_handshake()\n\n                def readable(self):\n                    if isinstance(self.socket, ssl.SSLSocket):\n                        while self.socket.pending() > 0:\n                            self.handle_read_event()\n                    return True\n\n                def _do_ssl_handshake(self):\n                    try:\n                        self.socket.do_handshake()\n                    except (ssl.SSLWantReadError, ssl.SSLWantWriteError):\n                        return\n                    except ssl.SSLEOFError:\n                        return self.handle_close()\n                    except ssl.SSLError:\n                        raise\n                    except socket.error as err:\n                        if err.args[0] == errno.ECONNABORTED:\n                            return self.handle_close()\n                    else:\n                        self._ssl_accepting = False\n\n                def handle_read(self):\n                    if self._ssl_accepting:\n                        self._do_ssl_handshake()\n                    else:\n                        data = self.recv(1024)\n                        if support.verbose:\n                            sys.stdout.write(\" server:  read %s from client\\n\" % repr(data))\n                        if not data:\n                            self.close()\n                        else:\n                            self.send(data.lower())\n\n                def handle_close(self):\n                    self.close()\n                    if support.verbose:\n                        sys.stdout.write(\" server:  closed connection %s\\n\" % self.socket)\n\n                def handle_error(self):\n                    raise\n\n            def __init__(self, certfile):\n                self.certfile = certfile\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.port = support.bind_port(sock, '')\n                asyncore.dispatcher.__init__(self, sock)\n                self.listen(5)\n\n            def handle_accepted(self, sock_obj, addr):\n                if support.verbose:\n                    sys.stdout.write(\" server:  new connection from %s:%s\\n\" %addr)\n                self.ConnectionHandler(sock_obj, self.certfile)\n\n            def handle_error(self):\n                raise\n\n        def __init__(self, certfile):\n            self.flag = None\n            self.active = False\n            self.server = self.EchoServer(certfile)\n            self.port = self.server.port\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __str__(self):\n            return \"<%s %s>\" % (self.__class__.__name__, self.server)\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            if support.verbose:\n                sys.stdout.write(\" cleanup: stopping server.\\n\")\n            self.stop()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: joining server thread.\\n\")\n            self.join()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: successfully joined.\\n\")\n\n        def start (self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.active = True\n            if self.flag:\n                self.flag.set()\n            while self.active:\n                try:\n                    asyncore.loop(1)\n                except:\n                    pass\n\n        def stop(self):\n            self.active = False\n            self.server.close()\n\n    def bad_cert_test(certfile):\n        \"\"\"\n        Launch a server with CERT_REQUIRED, and check that trying to\n        connect to it with the given client certificate fails.\n        \"\"\"\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_REQUIRED,\n                                    cacerts=CERTFILE, chatty=False,\n                                    connectionchatty=False)\n        with server:\n            try:\n                with socket.socket() as sock:\n                    s = ssl.wrap_socket(sock,\n                                        certfile=certfile,\n                                        ssl_version=ssl.PROTOCOL_TLSv1)\n                    s.connect((HOST, server.port))\n            except ssl.SSLError as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nSSLError is %s\\n\" % x.args[1])\n            except socket.error as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nsocket.error is %s\\n\" % x.args[1])\n            except IOError as x:\n                if x.errno != errno.ENOENT:\n                    raise\n                if support.verbose:\n                    sys.stdout.write(\"\\IOError is %s\\n\" % str(x))\n            else:\n                raise AssertionError(\"Use of invalid cert should have failed!\")\n\n    def server_params_test(client_context, server_context, indata=b\"FOO\\n\",\n                           chatty=True, connectionchatty=False):\n        \"\"\"\n        Launch a server, connect a client to it and try various reads\n        and writes.\n        \"\"\"\n        stats = {}\n        server = ThreadedEchoServer(context=server_context,\n                                    chatty=chatty,\n                                    connectionchatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                for arg in [indata, bytearray(indata), memoryview(indata)]:\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  sending %r...\\n\" % indata)\n                    s.write(arg)\n                    outdata = s.read()\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                    if outdata != indata.lower():\n                        raise AssertionError(\n                            \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                            % (outdata[:20], len(outdata),\n                               indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\" client:  closing connection.\\n\")\n                stats.update({\n                    'compression': s.compression(),\n                    'cipher': s.cipher(),\n                    'client_npn_protocol': s.selected_npn_protocol()\n                })\n                s.close()\n            stats['server_npn_protocols'] = server.selected_protocols\n        return stats\n\n    def try_protocol_combo(server_protocol, client_protocol, expect_success,\n                           certsreqs=None, server_options=0, client_options=0):\n        if certsreqs is None:\n            certsreqs = ssl.CERT_NONE\n        certtype = {\n            ssl.CERT_NONE: \"CERT_NONE\",\n            ssl.CERT_OPTIONAL: \"CERT_OPTIONAL\",\n            ssl.CERT_REQUIRED: \"CERT_REQUIRED\",\n        }[certsreqs]\n        if support.verbose:\n            formatstr = (expect_success and \" %s->%s %s\\n\") or \" {%s->%s} %s\\n\"\n            sys.stdout.write(formatstr %\n                             (ssl.get_protocol_name(client_protocol),\n                              ssl.get_protocol_name(server_protocol),\n                              certtype))\n        client_context = ssl.SSLContext(client_protocol)\n        client_context.options = ssl.OP_ALL | client_options\n        server_context = ssl.SSLContext(server_protocol)\n        server_context.options = ssl.OP_ALL | server_options\n        for ctx in (client_context, server_context):\n            ctx.verify_mode = certsreqs\n            # NOTE: we must enable \"ALL\" ciphers, otherwise an SSLv23 client\n            # will send an SSLv3 hello (rather than SSLv2) starting from\n            # OpenSSL 1.0.0 (see issue #8322).\n            ctx.set_ciphers(\"ALL\")\n            ctx.load_cert_chain(CERTFILE)\n            ctx.load_verify_locations(CERTFILE)\n        try:\n            server_params_test(client_context, server_context,\n                               chatty=False, connectionchatty=False)\n        # Protocol mismatch can result in either an SSLError, or a\n        # \"Connection reset by peer\" error.\n        except ssl.SSLError:\n            if expect_success:\n                raise\n        except socket.error as e:\n            if expect_success or e.errno != errno.ECONNRESET:\n                raise\n        else:\n            if not expect_success:\n                raise AssertionError(\n                    \"Client protocol %s succeeded with server protocol %s!\"\n                    % (ssl.get_protocol_name(client_protocol),\n                       ssl.get_protocol_name(server_protocol)))\n\n\n    class ThreadedTests(unittest.TestCase):\n\n        @skip_if_broken_ubuntu_ssl\n        def test_echo(self):\n            \"\"\"Basic test of an SSL client connecting to a server\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            for protocol in PROTOCOLS:\n                context = ssl.SSLContext(protocol)\n                context.load_cert_chain(CERTFILE)\n                server_params_test(context, context,\n                                   chatty=True, connectionchatty=True)\n\n        def test_getpeercert(self):\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = ThreadedEchoServer(context=context, chatty=False)\n            with server:\n                s = context.wrap_socket(socket.socket())\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()\n                if support.verbose:\n                    sys.stdout.write(pprint.pformat(cert) + '\\n')\n                    sys.stdout.write(\"Connection cipher is \" + str(cipher) + '.\\n')\n                if 'subject' not in cert:\n                    self.fail(\"No subject field in certificate: %s.\" %\n                              pprint.pformat(cert))\n                if ((('organizationName', 'Python Software Foundation'),)\n                    not in cert['subject']):\n                    self.fail(\n                        \"Missing or invalid 'organizationName' field in certificate subject; \"\n                        \"should be 'Python Software Foundation'.\")\n                self.assertIn('notBefore', cert)\n                self.assertIn('notAfter', cert)\n                before = ssl.cert_time_to_seconds(cert['notBefore'])\n                after = ssl.cert_time_to_seconds(cert['notAfter'])\n                self.assertLess(before, after)\n                s.close()\n\n        def test_empty_cert(self):\n            \"\"\"Connecting with an empty cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                      \"nullcert.pem\"))\n        def test_malformed_cert(self):\n            \"\"\"Connecting with a badly formatted certificate (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badcert.pem\"))\n        def test_nonexisting_cert(self):\n            \"\"\"Connecting with a non-existing cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"wrongcert.pem\"))\n        def test_malformed_key(self):\n            \"\"\"Connecting with a badly formatted key (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badkey.pem\"))\n\n        def test_rude_shutdown(self):\n            \"\"\"A brutal shutdown of an SSL server should raise an IOError\n            in the client when attempting handshake.\n            \"\"\"\n            listener_ready = threading.Event()\n            listener_gone = threading.Event()\n\n            s = socket.socket()\n            port = support.bind_port(s, HOST)\n\n            # `listener` runs in a thread.  It sits in an accept() until\n            # the main thread connects.  Then it rudely closes the socket,\n            # and sets Event `listener_gone` to let the main thread know\n            # the socket is gone.\n            def listener():\n                s.listen(5)\n                listener_ready.set()\n                newsock, addr = s.accept()\n                newsock.close()\n                s.close()\n                listener_gone.set()\n\n            def connector():\n                listener_ready.wait()\n                with socket.socket() as c:\n                    c.connect((HOST, port))\n                    listener_gone.wait()\n                    try:\n                        ssl_sock = ssl.wrap_socket(c)\n                    except IOError:\n                        pass\n                    else:\n                        self.fail('connecting to closed SSL socket should have failed')\n\n            t = threading.Thread(target=listener)\n            t.start()\n            try:\n                connector()\n            finally:\n                t.join()\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv2'),\n                             \"OpenSSL is compiled without SSLv2 support\")\n        def test_protocol_sslv2(self):\n            \"\"\"Connecting to an SSLv2 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLSv1, False)\n            # SSLv23 client with specific SSL options\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, False,\n                                   client_options=ssl.OP_NO_SSLv2)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv23(self):\n            \"\"\"Connecting to an SSLv23 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try:\n                    try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv2, True)\n                except (ssl.SSLError, socket.error) as x:\n                    # this fails on some older versions of OpenSSL (0.9.7l, for instance)\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" SSL2 client to SSL23 server test unexpectedly failed:\\n %s\\n\"\n                            % str(x))\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n\n            # Server with specific SSL options\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, False,\n                               server_options=ssl.OP_NO_SSLv3)\n            # Will choose TLSv1\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True,\n                               server_options=ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, False,\n                               server_options=ssl.OP_NO_TLSv1)\n\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv3(self):\n            \"\"\"Connecting to an SSLv3 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLSv1, False)\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, True,\n                                   client_options=ssl.OP_NO_SSLv2)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_tlsv1(self):\n            \"\"\"Connecting to a TLSv1 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        def test_starttls(self):\n            \"\"\"Switching from clear text to encrypted and back again.\"\"\"\n            msgs = (b\"msg 1\", b\"MSG 2\", b\"STARTTLS\", b\"MSG 3\", b\"msg 4\", b\"ENDTLS\", b\"msg 5\", b\"msg 6\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        starttls_server=True,\n                                        chatty=True,\n                                        connectionchatty=True)\n            wrapped = False\n            with server:\n                s = socket.socket()\n                s.setblocking(1)\n                s.connect((HOST, server.port))\n                if support.verbose:\n                    sys.stdout.write(\"\\n\")\n                for indata in msgs:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  sending %r...\\n\" % indata)\n                    if wrapped:\n                        conn.write(indata)\n                        outdata = conn.read()\n                    else:\n                        s.send(indata)\n                        outdata = s.recv(1024)\n                    msg = outdata.strip().lower()\n                    if indata == b\"STARTTLS\" and msg.startswith(b\"ok\"):\n                        # STARTTLS ok, switch to secure mode\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, starting TLS...\\n\"\n                                % msg)\n                        conn = ssl.wrap_socket(s, ssl_version=ssl.PROTOCOL_TLSv1)\n                        wrapped = True\n                    elif indata == b\"ENDTLS\" and msg.startswith(b\"ok\"):\n                        # ENDTLS ok, switch back to clear text\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, ending TLS...\\n\"\n                                % msg)\n                        s = conn.unwrap()\n                        wrapped = False\n                    else:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server\\n\" % msg)\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                if wrapped:\n                    conn.write(b\"over\\n\")\n                else:\n                    s.send(b\"over\\n\")\n                if wrapped:\n                    conn.close()\n                else:\n                    s.close()\n\n        def test_socketserver(self):\n            \"\"\"Using a SocketServer to create and manage SSL connections.\"\"\"\n            server = make_https_server(self, CERTFILE)\n            # try to connect\n            if support.verbose:\n                sys.stdout.write('\\n')\n            with open(CERTFILE, 'rb') as f:\n                d1 = f.read()\n            d2 = ''\n            # now fetch the same data from the HTTPS server\n            url = 'https://%s:%d/%s' % (\n                HOST, server.port, os.path.split(CERTFILE)[1])\n            f = urllib.request.urlopen(url)\n            try:\n                dlen = f.info().get(\"content-length\")\n                if dlen and (int(dlen) > 0):\n                    d2 = f.read(int(dlen))\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client: read %d bytes from remote server '%s'\\n\"\n                            % (len(d2), server))\n            finally:\n                f.close()\n            self.assertEqual(d1, d2)\n\n        def test_asyncore_server(self):\n            \"\"\"Check the example asyncore integration.\"\"\"\n            indata = \"TEST MESSAGE of mixed case\\n\"\n\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            indata = b\"FOO\\n\"\n            server = AsyncoreEchoServer(CERTFILE)\n            with server:\n                s = ssl.wrap_socket(socket.socket())\n                s.connect(('127.0.0.1', server.port))\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client:  sending %r...\\n\" % indata)\n                s.write(indata)\n                outdata = s.read()\n                if support.verbose:\n                    sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                if outdata != indata.lower():\n                    self.fail(\n                        \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                        % (outdata[:20], len(outdata),\n                           indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                s.close()\n                if support.verbose:\n                    sys.stdout.write(\" client:  connection closed.\\n\")\n\n        def test_recv_send(self):\n            \"\"\"Test recv(), send() and friends.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # helper methods for standardising recv* method signatures\n                def _recv_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count = s.recv_into(b)\n                    return b[:count]\n\n                def _recvfrom_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count, addr = s.recvfrom_into(b)\n                    return b[:count]\n\n                # (name, method, whether to expect success, *args)\n                send_methods = [\n                    ('send', s.send, True, []),\n                    ('sendto', s.sendto, False, [\"some.address\"]),\n                    ('sendall', s.sendall, True, []),\n                ]\n                recv_methods = [\n                    ('recv', s.recv, True, []),\n                    ('recvfrom', s.recvfrom, False, [\"some.address\"]),\n                    ('recv_into', _recv_into, True, []),\n                    ('recvfrom_into', _recvfrom_into, False, []),\n                ]\n                data_prefix = \"PREFIX_\"\n\n                for meth_name, send_meth, expect_success, args in send_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        send_meth(indata, *args)\n                        outdata = s.read()\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While sending with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to send with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n\n                for meth_name, recv_meth, expect_success, args in recv_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        s.send(indata)\n                        outdata = recv_meth(*args)\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While receiving with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to receive with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n                        # consume data\n                        s.read()\n\n                # Make sure sendmsg et al are disallowed to avoid\n                # inadvertent disclosure of data and/or corruption\n                # of the encrypted data stream\n                self.assertRaises(NotImplementedError, s.sendmsg, [b\"data\"])\n                self.assertRaises(NotImplementedError, s.recvmsg, 100)\n                self.assertRaises(NotImplementedError,\n                                  s.recvmsg_into, bytearray(100))\n\n                s.write(b\"over\\n\")\n                s.close()\n\n        def test_handshake_timeout(self):\n            # Issue #5103: SSL handshake must respect the socket timeout\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            started = threading.Event()\n            finish = False\n\n            def serve():\n                server.listen(5)\n                started.set()\n                conns = []\n                while not finish:\n                    r, w, e = select.select([server], [], [], 0.1)\n                    if server in r:\n                        # Let the socket hang around rather than having\n                        # it closed by garbage collection.\n                        conns.append(server.accept()[0])\n                for sock in conns:\n                    sock.close()\n\n            t = threading.Thread(target=serve)\n            t.start()\n            started.wait()\n\n            try:\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c.settimeout(0.2)\n                    c.connect((host, port))\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           ssl.wrap_socket, c)\n                finally:\n                    c.close()\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c = ssl.wrap_socket(c)\n                    c.settimeout(0.2)\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           c.connect, (host, port))\n                finally:\n                    c.close()\n            finally:\n                finish = True\n                t.join()\n                server.close()\n\n        def test_server_accept(self):\n            # Issue #16357: accept() on a SSLSocket created through\n            # SSLContext.wrap_socket().\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            server = context.wrap_socket(server, server_side=True)\n\n            evt = threading.Event()\n            remote = None\n            peer = None\n            def serve():\n                nonlocal remote, peer\n                server.listen(5)\n                # Block on the accept and wait on the connection to close.\n                evt.set()\n                remote, peer = server.accept()\n                remote.recv(1)\n\n            t = threading.Thread(target=serve)\n            t.start()\n            # Client wait until server setup and perform a connect.\n            evt.wait()\n            client = context.wrap_socket(socket.socket())\n            client.connect((host, port))\n            client_addr = client.getsockname()\n            client.close()\n            t.join()\n            remote.close()\n            server.close()\n            # Sanity checks.\n            self.assertIsInstance(remote, ssl.SSLSocket)\n            self.assertEqual(peer, client_addr)\n\n        def test_default_ciphers(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            try:\n                # Force a set of weak ciphers on our client context\n                context.set_ciphers(\"DES\")\n            except ssl.SSLError:\n                self.skipTest(\"no DES cipher available\")\n            with ThreadedEchoServer(CERTFILE,\n                                    ssl_version=ssl.PROTOCOL_SSLv23,\n                                    chatty=False) as server:\n                with context.wrap_socket(socket.socket()) as s:\n                    with self.assertRaises((OSError, ssl.SSLError)):\n                        s.connect((HOST, server.port))\n            self.assertIn(\"no shared cipher\", str(server.conn_errors[0]))\n\n        @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                             \"'tls-unique' channel binding not available\")\n        def test_tls_unique_channel_binding(self):\n            \"\"\"Test tls-unique channel binding.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # get the data\n                cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\" got channel binding data: {0!r}\\n\"\n                                     .format(cb_data))\n\n                # check if it is sane\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n\n                # and compare with the peers version\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(cb_data).encode(\"us-ascii\"))\n                s.close()\n\n                # now, again\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                new_cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\" got another channel binding data: {0!r}\\n\"\n                                     .format(new_cb_data))\n                # is it really unique\n                self.assertNotEqual(cb_data, new_cb_data)\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(new_cb_data).encode(\"us-ascii\"))\n                s.close()\n\n        def test_compression(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            if support.verbose:\n                sys.stdout.write(\" got compression: {!r}\\n\".format(stats['compression']))\n            self.assertIn(stats['compression'], { None, 'ZLIB', 'RLE' })\n\n        @unittest.skipUnless(hasattr(ssl, 'OP_NO_COMPRESSION'),\n                             \"ssl.OP_NO_COMPRESSION needed for this test\")\n        def test_compression_disabled(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            context.options |= ssl.OP_NO_COMPRESSION\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            self.assertIs(stats['compression'], None)\n\n        def test_dh_params(self):\n            # Check we can get a connection with ephemeral Diffie-Hellman\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            context.load_dh_params(DHFILE)\n            context.set_ciphers(\"kEDH\")\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            cipher = stats[\"cipher\"][0]\n            parts = cipher.split(\"-\")\n            if \"ADH\" not in parts and \"EDH\" not in parts and \"DHE\" not in parts:\n                self.fail(\"Non-DH cipher: \" + cipher[0])\n\n        def test_selected_npn_protocol(self):\n            # selected_npn_protocol() is None unless NPN is used\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            self.assertIs(stats['client_npn_protocol'], None)\n\n        @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")\n        def test_npn_protocols(self):\n            server_protocols = ['http/1.1', 'spdy/2']\n            protocol_tests = [\n                (['http/1.1', 'spdy/2'], 'http/1.1'),\n                (['spdy/2', 'http/1.1'], 'http/1.1'),\n                (['spdy/2', 'test'], 'spdy/2'),\n                (['abc', 'def'], 'abc')\n            ]\n            for client_protocols, expected in protocol_tests:\n                server_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n                server_context.load_cert_chain(CERTFILE)\n                server_context.set_npn_protocols(server_protocols)\n                client_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n                client_context.load_cert_chain(CERTFILE)\n                client_context.set_npn_protocols(client_protocols)\n                stats = server_params_test(client_context, server_context,\n                                           chatty=True, connectionchatty=True)\n\n                msg = \"failed trying %s (s) and %s (c).\\n\" \\\n                      \"was expecting %s, but got %%s from the %%s\" \\\n                          % (str(server_protocols), str(client_protocols),\n                             str(expected))\n                client_result = stats['client_npn_protocol']\n                self.assertEqual(client_result, expected, msg % (client_result, \"client\"))\n                server_result = stats['server_npn_protocols'][-1] \\\n                    if len(stats['server_npn_protocols']) else 'nothing'\n                self.assertEqual(server_result, expected, msg % (server_result, \"server\"))\n\n\ndef test_main(verbose=False):\n    if support.verbose:\n        plats = {\n            'Linux': platform.linux_distribution,\n            'Mac': platform.mac_ver,\n            'Windows': platform.win32_ver,\n        }\n        for name, func in plats.items():\n            plat = func()\n            if plat and plat[0]:\n                plat = '%s %r' % (name, plat)\n                break\n        else:\n            plat = repr(platform.platform())\n        print(\"test_ssl: testing with %r %r\" %\n            (ssl.OPENSSL_VERSION, ssl.OPENSSL_VERSION_INFO))\n        print(\"          under %s\" % plat)\n        print(\"          HAS_SNI = %r\" % ssl.HAS_SNI)\n\n    for filename in [\n        CERTFILE, SVN_PYTHON_ORG_ROOT_CERT, BYTES_CERTFILE,\n        ONLYCERT, ONLYKEY, BYTES_ONLYCERT, BYTES_ONLYKEY,\n        BADCERT, BADKEY, EMPTYCERT]:\n        if not os.path.exists(filename):\n            raise support.TestFailed(\"Can't read certificate file %r\" % filename)\n\n    tests = [ContextTests, BasicSocketTests, SSLErrorTests]\n\n    if support.is_resource_enabled('network'):\n        tests.append(NetworkedTests)\n\n    if _have_threads:\n        thread_info = support.threading_setup()\n        if thread_info:\n            tests.append(ThreadedTests)\n\n    try:\n        support.run_unittest(*tests)\n    finally:\n        if _have_threads:\n            support.threading_cleanup(*thread_info)\n\nif __name__ == \"__main__\":\n    test_main()\n",
    "code_after": "# Test the support for SSL and sockets\n\nimport sys\nimport unittest\nfrom test import support\nimport socket\nimport select\nimport time\nimport gc\nimport os\nimport errno\nimport pprint\nimport tempfile\nimport urllib.request\nimport traceback\nimport asyncore\nimport weakref\nimport platform\nimport functools\n\nssl = support.import_module(\"ssl\")\n\nPROTOCOLS = [\n    ssl.PROTOCOL_SSLv3,\n    ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1\n]\nif hasattr(ssl, 'PROTOCOL_SSLv2'):\n    PROTOCOLS.append(ssl.PROTOCOL_SSLv2)\n\nHOST = support.HOST\n\ndata_file = lambda name: os.path.join(os.path.dirname(__file__), name)\n\n# The custom key and certificate files used in test_ssl are generated\n# using Lib/test/make_ssl_certs.py.\n# Other certificates are simply fetched from the Internet servers they\n# are meant to authenticate.\n\nCERTFILE = data_file(\"keycert.pem\")\nBYTES_CERTFILE = os.fsencode(CERTFILE)\nONLYCERT = data_file(\"ssl_cert.pem\")\nONLYKEY = data_file(\"ssl_key.pem\")\nBYTES_ONLYCERT = os.fsencode(ONLYCERT)\nBYTES_ONLYKEY = os.fsencode(ONLYKEY)\nCERTFILE_PROTECTED = data_file(\"keycert.passwd.pem\")\nONLYKEY_PROTECTED = data_file(\"ssl_key.passwd.pem\")\nKEY_PASSWORD = \"somepass\"\nCAPATH = data_file(\"capath\")\nBYTES_CAPATH = os.fsencode(CAPATH)\n\nSVN_PYTHON_ORG_ROOT_CERT = data_file(\"https_svn_python_org_root.pem\")\n\nEMPTYCERT = data_file(\"nullcert.pem\")\nBADCERT = data_file(\"badcert.pem\")\nWRONGCERT = data_file(\"XXXnonexisting.pem\")\nBADKEY = data_file(\"badkey.pem\")\nNOKIACERT = data_file(\"nokia.pem\")\nNULLBYTECERT = data_file(\"nullbytecert.pem\")\n\nDHFILE = data_file(\"dh512.pem\")\nBYTES_DHFILE = os.fsencode(DHFILE)\n\ndef handle_error(prefix):\n    exc_format = ' '.join(traceback.format_exception(*sys.exc_info()))\n    if support.verbose:\n        sys.stdout.write(prefix + exc_format)\n\ndef can_clear_options():\n    # 0.9.8m or higher\n    return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)\n\ndef no_sslv2_implies_sslv3_hello():\n    # 0.9.7h or higher\n    return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)\n\n\n# Issue #9415: Ubuntu hijacks their OpenSSL and forcefully disables SSLv2\ndef skip_if_broken_ubuntu_ssl(func):\n    if hasattr(ssl, 'PROTOCOL_SSLv2'):\n        @functools.wraps(func)\n        def f(*args, **kwargs):\n            try:\n                ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n            except ssl.SSLError:\n                if (ssl.OPENSSL_VERSION_INFO == (0, 9, 8, 15, 15) and\n                    platform.linux_distribution() == ('debian', 'squeeze/sid', '')):\n                    raise unittest.SkipTest(\"Patched Ubuntu OpenSSL breaks behaviour\")\n            return func(*args, **kwargs)\n        return f\n    else:\n        return func\n\n\nclass BasicSocketTests(unittest.TestCase):\n\n    def test_constants(self):\n        #ssl.PROTOCOL_SSLv2\n        ssl.PROTOCOL_SSLv23\n        ssl.PROTOCOL_SSLv3\n        ssl.PROTOCOL_TLSv1\n        ssl.CERT_NONE\n        ssl.CERT_OPTIONAL\n        ssl.CERT_REQUIRED\n        ssl.OP_CIPHER_SERVER_PREFERENCE\n        ssl.OP_SINGLE_DH_USE\n        if ssl.HAS_ECDH:\n            ssl.OP_SINGLE_ECDH_USE\n        if ssl.OPENSSL_VERSION_INFO >= (1, 0):\n            ssl.OP_NO_COMPRESSION\n        self.assertIn(ssl.HAS_SNI, {True, False})\n        self.assertIn(ssl.HAS_ECDH, {True, False})\n\n    def test_random(self):\n        v = ssl.RAND_status()\n        if support.verbose:\n            sys.stdout.write(\"\\n RAND_status is %d (%s)\\n\"\n                             % (v, (v and \"sufficient randomness\") or\n                                \"insufficient randomness\"))\n\n        data, is_cryptographic = ssl.RAND_pseudo_bytes(16)\n        self.assertEqual(len(data), 16)\n        self.assertEqual(is_cryptographic, v == 1)\n        if v:\n            data = ssl.RAND_bytes(16)\n            self.assertEqual(len(data), 16)\n        else:\n            self.assertRaises(ssl.SSLError, ssl.RAND_bytes, 16)\n\n        self.assertRaises(TypeError, ssl.RAND_egd, 1)\n        self.assertRaises(TypeError, ssl.RAND_egd, 'foo', 1)\n        ssl.RAND_add(\"this is a random string\", 75.0)\n\n    def test_parse_cert(self):\n        # note that this uses an 'unofficial' function in _ssl.c,\n        # provided solely for this test, to exercise the certificate\n        # parsing code\n        p = ssl._ssl._test_decode_cert(CERTFILE)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['issuer'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['notAfter'], 'Oct  5 23:01:56 2020 GMT')\n        self.assertEqual(p['notBefore'], 'Oct  8 23:01:56 2010 GMT')\n        self.assertEqual(p['serialNumber'], 'D7C7381919AFC24E')\n        self.assertEqual(p['subject'],\n                         ((('countryName', 'XY'),),\n                          (('localityName', 'Castle Anthrax'),),\n                          (('organizationName', 'Python Software Foundation'),),\n                          (('commonName', 'localhost'),))\n                        )\n        self.assertEqual(p['subjectAltName'], (('DNS', 'localhost'),))\n        # Issue #13034: the subjectAltName in some certificates\n        # (notably projects.developer.nokia.com:443) wasn't parsed\n        p = ssl._ssl._test_decode_cert(NOKIACERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'projects.developer.nokia.com'),\n                          ('DNS', 'projects.forum.nokia.com'))\n                        )\n\n    def test_parse_cert_CVE_2013_4238(self):\n        p = ssl._ssl._test_decode_cert(NULLBYTECERT)\n        if support.verbose:\n            sys.stdout.write(\"\\n\" + pprint.pformat(p) + \"\\n\")\n        subject = ((('countryName', 'US'),),\n                   (('stateOrProvinceName', 'Oregon'),),\n                   (('localityName', 'Beaverton'),),\n                   (('organizationName', 'Python Software Foundation'),),\n                   (('organizationalUnitName', 'Python Core Development'),),\n                   (('commonName', 'null.python.org\\x00example.org'),),\n                   (('emailAddress', 'python-dev@python.org'),))\n        self.assertEqual(p['subject'], subject)\n        self.assertEqual(p['issuer'], subject)\n        self.assertEqual(p['subjectAltName'],\n                         (('DNS', 'altnull.python.org\\x00example.com'),\n                         ('email', 'null@python.org\\x00user@example.org'),\n                         ('URI', 'http://null.python.org\\x00http://example.org'),\n                         ('IP Address', '192.0.2.1'),\n                         ('IP Address', '2001:DB8:0:0:0:0:0:1\\n'))\n                        )\n\n    def test_DER_to_PEM(self):\n        with open(SVN_PYTHON_ORG_ROOT_CERT, 'r') as f:\n            pem = f.read()\n        d1 = ssl.PEM_cert_to_DER_cert(pem)\n        p2 = ssl.DER_cert_to_PEM_cert(d1)\n        d2 = ssl.PEM_cert_to_DER_cert(p2)\n        self.assertEqual(d1, d2)\n        if not p2.startswith(ssl.PEM_HEADER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct header:\\n%r\\n\" % p2)\n        if not p2.endswith('\\n' + ssl.PEM_FOOTER + '\\n'):\n            self.fail(\"DER-to-PEM didn't include correct footer:\\n%r\\n\" % p2)\n\n    def test_openssl_version(self):\n        n = ssl.OPENSSL_VERSION_NUMBER\n        t = ssl.OPENSSL_VERSION_INFO\n        s = ssl.OPENSSL_VERSION\n        self.assertIsInstance(n, int)\n        self.assertIsInstance(t, tuple)\n        self.assertIsInstance(s, str)\n        # Some sanity checks follow\n        # >= 0.9\n        self.assertGreaterEqual(n, 0x900000)\n        # < 2.0\n        self.assertLess(n, 0x20000000)\n        major, minor, fix, patch, status = t\n        self.assertGreaterEqual(major, 0)\n        self.assertLess(major, 2)\n        self.assertGreaterEqual(minor, 0)\n        self.assertLess(minor, 256)\n        self.assertGreaterEqual(fix, 0)\n        self.assertLess(fix, 256)\n        self.assertGreaterEqual(patch, 0)\n        self.assertLessEqual(patch, 26)\n        self.assertGreaterEqual(status, 0)\n        self.assertLessEqual(status, 15)\n        # Version string as returned by OpenSSL, the format might change\n        self.assertTrue(s.startswith(\"OpenSSL {:d}.{:d}.{:d}\".format(major, minor, fix)),\n                        (s, t))\n\n    @support.cpython_only\n    def test_refcycle(self):\n        # Issue #7943: an SSL object doesn't create reference cycles with\n        # itself.\n        s = socket.socket(socket.AF_INET)\n        ss = ssl.wrap_socket(s)\n        wr = weakref.ref(ss)\n        with support.check_warnings((\"\", ResourceWarning)):\n            del ss\n            self.assertEqual(wr(), None)\n\n    def test_wrapped_unconnected(self):\n        # Methods on an unconnected SSLSocket propagate the original\n        # socket.error raise by the underlying socket object.\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            self.assertRaises(socket.error, ss.recv, 1)\n            self.assertRaises(socket.error, ss.recv_into, bytearray(b'x'))\n            self.assertRaises(socket.error, ss.recvfrom, 1)\n            self.assertRaises(socket.error, ss.recvfrom_into, bytearray(b'x'), 1)\n            self.assertRaises(socket.error, ss.send, b'x')\n            self.assertRaises(socket.error, ss.sendto, b'x', ('0.0.0.0', 0))\n\n    def test_timeout(self):\n        # Issue #8524: when creating an SSL socket, the timeout of the\n        # original socket should be retained.\n        for timeout in (None, 0.0, 5.0):\n            s = socket.socket(socket.AF_INET)\n            s.settimeout(timeout)\n            with ssl.wrap_socket(s) as ss:\n                self.assertEqual(timeout, ss.gettimeout())\n\n    def test_errors(self):\n        sock = socket.socket()\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified\",\n                        ssl.wrap_socket, sock, keyfile=CERTFILE)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True)\n        self.assertRaisesRegex(ValueError,\n                        \"certfile must be specified for server-side operations\",\n                        ssl.wrap_socket, sock, server_side=True, certfile=\"\")\n        with ssl.wrap_socket(sock, server_side=True, certfile=CERTFILE) as s:\n            self.assertRaisesRegex(ValueError, \"can't connect in server-side mode\",\n                                    s.connect, (HOST, 8080))\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=CERTFILE, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(IOError) as cm:\n            with socket.socket() as sock:\n                ssl.wrap_socket(sock, certfile=WRONGCERT, keyfile=WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n\n    def test_match_hostname(self):\n        def ok(cert, hostname):\n            ssl.match_hostname(cert, hostname)\n        def fail(cert, hostname):\n            self.assertRaises(ssl.CertificateError,\n                              ssl.match_hostname, cert, hostname)\n\n        cert = {'subject': ((('commonName', 'example.com'),),)}\n        ok(cert, 'example.com')\n        ok(cert, 'ExAmple.cOm')\n        fail(cert, 'www.example.com')\n        fail(cert, '.example.com')\n        fail(cert, 'example.org')\n        fail(cert, 'exampleXcom')\n\n        cert = {'subject': ((('commonName', '*.a.com'),),)}\n        ok(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.a.com')\n        fail(cert, 'a.com')\n        fail(cert, 'Xa.com')\n        fail(cert, '.a.com')\n\n        cert = {'subject': ((('commonName', 'a.*.com'),),)}\n        ok(cert, 'a.foo.com')\n        fail(cert, 'a..com')\n        fail(cert, 'a.com')\n\n        cert = {'subject': ((('commonName', 'f*.com'),),)}\n        ok(cert, 'foo.com')\n        ok(cert, 'f.com')\n        fail(cert, 'bar.com')\n        fail(cert, 'foo.a.com')\n        fail(cert, 'bar.foo.com')\n\n        # NULL bytes are bad, CVE-2013-4073\n        cert = {'subject': ((('commonName',\n                              'null.python.org\\x00example.org'),),)}\n        ok(cert, 'null.python.org\\x00example.org') # or raise an error?\n        fail(cert, 'example.org')\n        fail(cert, 'null.python.org')\n\n        # Slightly fake real-world example\n        cert = {'notAfter': 'Jun 26 21:41:46 2011 GMT',\n                'subject': ((('commonName', 'linuxfrz.org'),),),\n                'subjectAltName': (('DNS', 'linuxfr.org'),\n                                   ('DNS', 'linuxfr.com'),\n                                   ('othername', '<unsupported>'))}\n        ok(cert, 'linuxfr.org')\n        ok(cert, 'linuxfr.com')\n        # Not a \"DNS\" entry\n        fail(cert, '<unsupported>')\n        # When there is a subjectAltName, commonName isn't used\n        fail(cert, 'linuxfrz.org')\n\n        # A pristine real-world example\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),),\n                            (('commonName', 'mail.google.com'),))}\n        ok(cert, 'mail.google.com')\n        fail(cert, 'gmail.com')\n        # Only commonName is considered\n        fail(cert, 'California')\n\n        # Neither commonName nor subjectAltName\n        cert = {'notAfter': 'Dec 18 23:59:59 2011 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),))}\n        fail(cert, 'mail.google.com')\n\n        # No DNS entry in subjectAltName but a commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('commonName', 'mail.google.com'),)),\n                'subjectAltName': (('othername', 'blabla'), )}\n        ok(cert, 'mail.google.com')\n\n        # No DNS entry subjectAltName and no commonName\n        cert = {'notAfter': 'Dec 18 23:59:59 2099 GMT',\n                'subject': ((('countryName', 'US'),),\n                            (('stateOrProvinceName', 'California'),),\n                            (('localityName', 'Mountain View'),),\n                            (('organizationName', 'Google Inc'),)),\n                'subjectAltName': (('othername', 'blabla'),)}\n        fail(cert, 'google.com')\n\n        # Empty cert / no cert\n        self.assertRaises(ValueError, ssl.match_hostname, None, 'example.com')\n        self.assertRaises(ValueError, ssl.match_hostname, {}, 'example.com')\n\n        # Issue #17980: avoid denials of service by refusing more than one\n        # wildcard per fragment.\n        cert = {'subject': ((('commonName', 'a*b.com'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b.co*'),),)}\n        ok(cert, 'axxb.com')\n        cert = {'subject': ((('commonName', 'a*b*.com'),),)}\n        with self.assertRaises(ssl.CertificateError) as cm:\n            ssl.match_hostname(cert, 'axxbxxc.com')\n        self.assertIn(\"too many wildcards\", str(cm.exception))\n\n    def test_server_side(self):\n        # server_hostname doesn't work for server sockets\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        with socket.socket() as sock:\n            self.assertRaises(ValueError, ctx.wrap_socket, sock, True,\n                              server_hostname=\"some.hostname\")\n\n    def test_unknown_channel_binding(self):\n        # should raise ValueError for unknown type\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            with self.assertRaises(ValueError):\n                ss.get_channel_binding(\"unknown-type\")\n\n    @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                         \"'tls-unique' channel binding not available\")\n    def test_tls_unique_channel_binding(self):\n        # unconnected should return None for known type\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n        # the same for server-side\n        s = socket.socket(socket.AF_INET)\n        with ssl.wrap_socket(s, server_side=True, certfile=CERTFILE) as ss:\n            self.assertIsNone(ss.get_channel_binding(\"tls-unique\"))\n\n    def test_dealloc_warn(self):\n        ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n        r = repr(ss)\n        with self.assertWarns(ResourceWarning) as cm:\n            ss = None\n            support.gc_collect()\n        self.assertIn(r, str(cm.warning.args[0]))\n\nclass ContextTests(unittest.TestCase):\n\n    @skip_if_broken_ubuntu_ssl\n    def test_constructor(self):\n        if hasattr(ssl, 'PROTOCOL_SSLv2'):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv2)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv3)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        self.assertRaises(TypeError, ssl.SSLContext)\n        self.assertRaises(ValueError, ssl.SSLContext, -1)\n        self.assertRaises(ValueError, ssl.SSLContext, 42)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_protocol(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.protocol, proto)\n\n    def test_ciphers(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ciphers(\"ALL\")\n        ctx.set_ciphers(\"DEFAULT\")\n        with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n            ctx.set_ciphers(\"^$:,;?*'dorothyx\")\n\n    @skip_if_broken_ubuntu_ssl\n    def test_options(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # OP_ALL is the default value\n        self.assertEqual(ssl.OP_ALL, ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv2\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2,\n                         ctx.options)\n        ctx.options |= ssl.OP_NO_SSLv3\n        self.assertEqual(ssl.OP_ALL | ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3,\n                         ctx.options)\n        if can_clear_options():\n            ctx.options = (ctx.options & ~ssl.OP_NO_SSLv2) | ssl.OP_NO_TLSv1\n            self.assertEqual(ssl.OP_ALL | ssl.OP_NO_TLSv1 | ssl.OP_NO_SSLv3,\n                             ctx.options)\n            ctx.options = 0\n            self.assertEqual(0, ctx.options)\n        else:\n            with self.assertRaises(ValueError):\n                ctx.options = 0\n\n    def test_verify(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Default value\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        ctx.verify_mode = ssl.CERT_OPTIONAL\n        self.assertEqual(ctx.verify_mode, ssl.CERT_OPTIONAL)\n        ctx.verify_mode = ssl.CERT_REQUIRED\n        self.assertEqual(ctx.verify_mode, ssl.CERT_REQUIRED)\n        ctx.verify_mode = ssl.CERT_NONE\n        self.assertEqual(ctx.verify_mode, ssl.CERT_NONE)\n        with self.assertRaises(TypeError):\n            ctx.verify_mode = None\n        with self.assertRaises(ValueError):\n            ctx.verify_mode = 42\n\n    def test_load_cert_chain(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        # Combined key and cert in a single file\n        ctx.load_cert_chain(CERTFILE)\n        ctx.load_cert_chain(CERTFILE, keyfile=CERTFILE)\n        self.assertRaises(TypeError, ctx.load_cert_chain, keyfile=CERTFILE)\n        with self.assertRaises(IOError) as cm:\n            ctx.load_cert_chain(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(BADCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(EMPTYCERT)\n        # Separate key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY)\n        ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)\n        ctx.load_cert_chain(certfile=BYTES_ONLYCERT, keyfile=BYTES_ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYCERT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(ONLYKEY)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)\n        # Mismatching key and cert\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaisesRegex(ssl.SSLError, \"key values mismatch\"):\n            ctx.load_cert_chain(SVN_PYTHON_ORG_ROOT_CERT, ONLYKEY)\n        # Password protected key and cert\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD.encode())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=bytearray(KEY_PASSWORD.encode()))\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD)\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED, KEY_PASSWORD.encode())\n        ctx.load_cert_chain(ONLYCERT, ONLYKEY_PROTECTED,\n                            bytearray(KEY_PASSWORD.encode()))\n        with self.assertRaisesRegex(TypeError, \"should be a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=True)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=\"badpass\")\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            # openssl has a fixed limit on the password buffer.\n            # PEM_BUFSIZE is generally set to 1kb.\n            # Return a string larger than this.\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=b'a' * 102400)\n        # Password callback\n        def getpass_unicode():\n            return KEY_PASSWORD\n        def getpass_bytes():\n            return KEY_PASSWORD.encode()\n        def getpass_bytearray():\n            return bytearray(KEY_PASSWORD.encode())\n        def getpass_badpass():\n            return \"badpass\"\n        def getpass_huge():\n            return b'a' * (1024 * 1024)\n        def getpass_bad_type():\n            return 9\n        def getpass_exception():\n            raise Exception('getpass error')\n        class GetPassCallable:\n            def __call__(self):\n                return KEY_PASSWORD\n            def getpass(self):\n                return KEY_PASSWORD\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_unicode)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytes)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bytearray)\n        ctx.load_cert_chain(CERTFILE_PROTECTED, password=GetPassCallable())\n        ctx.load_cert_chain(CERTFILE_PROTECTED,\n                            password=GetPassCallable().getpass)\n        with self.assertRaises(ssl.SSLError):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_badpass)\n        with self.assertRaisesRegex(ValueError, \"cannot be longer\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_huge)\n        with self.assertRaisesRegex(TypeError, \"must return a string\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_bad_type)\n        with self.assertRaisesRegex(Exception, \"getpass error\"):\n            ctx.load_cert_chain(CERTFILE_PROTECTED, password=getpass_exception)\n        # Make sure the password function isn't called if it isn't needed\n        ctx.load_cert_chain(CERTFILE, password=getpass_exception)\n\n    def test_load_verify_locations(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_verify_locations(CERTFILE)\n        ctx.load_verify_locations(cafile=CERTFILE, capath=None)\n        ctx.load_verify_locations(BYTES_CERTFILE)\n        ctx.load_verify_locations(cafile=BYTES_CERTFILE, capath=None)\n        self.assertRaises(TypeError, ctx.load_verify_locations)\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, None)\n        with self.assertRaises(IOError) as cm:\n            ctx.load_verify_locations(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaisesRegex(ssl.SSLError, \"PEM lib\"):\n            ctx.load_verify_locations(BADCERT)\n        ctx.load_verify_locations(CERTFILE, CAPATH)\n        ctx.load_verify_locations(CERTFILE, capath=BYTES_CAPATH)\n\n        # Issue #10989: crash if the second argument type is invalid\n        self.assertRaises(TypeError, ctx.load_verify_locations, None, True)\n\n    def test_load_dh_params(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.load_dh_params(DHFILE)\n        if os.name != 'nt':\n            ctx.load_dh_params(BYTES_DHFILE)\n        self.assertRaises(TypeError, ctx.load_dh_params)\n        self.assertRaises(TypeError, ctx.load_dh_params, None)\n        with self.assertRaises(FileNotFoundError) as cm:\n            ctx.load_dh_params(WRONGCERT)\n        self.assertEqual(cm.exception.errno, errno.ENOENT)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n\n    @skip_if_broken_ubuntu_ssl\n    def test_session_stats(self):\n        for proto in PROTOCOLS:\n            ctx = ssl.SSLContext(proto)\n            self.assertEqual(ctx.session_stats(), {\n                'number': 0,\n                'connect': 0,\n                'connect_good': 0,\n                'connect_renegotiate': 0,\n                'accept': 0,\n                'accept_good': 0,\n                'accept_renegotiate': 0,\n                'hits': 0,\n                'misses': 0,\n                'timeouts': 0,\n                'cache_full': 0,\n            })\n\n    def test_set_default_verify_paths(self):\n        # There's not much we can do to test that it acts as expected,\n        # so just check it doesn't crash or raise an exception.\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_default_verify_paths()\n\n    @unittest.skipUnless(ssl.HAS_ECDH, \"ECDH disabled on this OpenSSL build\")\n    def test_set_ecdh_curve(self):\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        ctx.set_ecdh_curve(\"prime256v1\")\n        ctx.set_ecdh_curve(b\"prime256v1\")\n        self.assertRaises(TypeError, ctx.set_ecdh_curve)\n        self.assertRaises(TypeError, ctx.set_ecdh_curve, None)\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, \"foo\")\n        self.assertRaises(ValueError, ctx.set_ecdh_curve, b\"foo\")\n\n\nclass SSLErrorTests(unittest.TestCase):\n\n    def test_str(self):\n        # The str() of a SSLError doesn't include the errno\n        e = ssl.SSLError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n        # Same for a subclass\n        e = ssl.SSLZeroReturnError(1, \"foo\")\n        self.assertEqual(str(e), \"foo\")\n        self.assertEqual(e.errno, 1)\n\n    def test_lib_reason(self):\n        # Test the library and reason attributes\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with self.assertRaises(ssl.SSLError) as cm:\n            ctx.load_dh_params(CERTFILE)\n        self.assertEqual(cm.exception.library, 'PEM')\n        self.assertEqual(cm.exception.reason, 'NO_START_LINE')\n        s = str(cm.exception)\n        self.assertTrue(s.startswith(\"[PEM: NO_START_LINE] no start line\"), s)\n\n    def test_subclass(self):\n        # Check that the appropriate SSLError subclass is raised\n        # (this only tests one of them)\n        ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n        with socket.socket() as s:\n            s.bind((\"127.0.0.1\", 0))\n            s.listen(5)\n            c = socket.socket()\n            c.connect(s.getsockname())\n            c.setblocking(False)\n            with ctx.wrap_socket(c, False, do_handshake_on_connect=False) as c:\n                with self.assertRaises(ssl.SSLWantReadError) as cm:\n                    c.do_handshake()\n                s = str(cm.exception)\n                self.assertTrue(s.startswith(\"The operation did not complete (read)\"), s)\n                # For compatibility\n                self.assertEqual(cm.exception.errno, ssl.SSL_ERROR_WANT_READ)\n\n\nclass NetworkedTests(unittest.TestCase):\n\n    def test_connect(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_NONE)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n\n            # this should fail because we have no verification certs\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED)\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                   s.connect, (\"svn.python.org\", 443))\n            s.close()\n\n            # this should succeed because we specify the root cert\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                s.connect((\"svn.python.org\", 443))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_connect_ex(self):\n        # Issue #11326: check connect_ex() implementation\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(0, s.connect_ex((\"svn.python.org\", 443)))\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_non_blocking_connect_ex(self):\n        # Issue #11326: non-blocking connect_ex() should allow handshake\n        # to proceed after the socket gets ready.\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.setblocking(False)\n                rc = s.connect_ex(('svn.python.org', 443))\n                # EWOULDBLOCK under Windows, EINPROGRESS elsewhere\n                self.assertIn(rc, (0, errno.EINPROGRESS, errno.EWOULDBLOCK))\n                # Wait for connect to finish\n                select.select([], [s], [], 5.0)\n                # Non-blocking handshake\n                while True:\n                    try:\n                        s.do_handshake()\n                        break\n                    except ssl.SSLWantReadError:\n                        select.select([s], [], [], 5.0)\n                    except ssl.SSLWantWriteError:\n                        select.select([], [s], [], 5.0)\n                # SSL established\n                self.assertTrue(s.getpeercert())\n            finally:\n                s.close()\n\n    def test_timeout_connect_ex(self):\n        # Issue #12065: on a timeout, connect_ex() should return the original\n        # errno (mimicking the behaviour of non-SSL sockets).\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT,\n                                do_handshake_on_connect=False)\n            try:\n                s.settimeout(0.0000001)\n                rc = s.connect_ex(('svn.python.org', 443))\n                if rc == 0:\n                    self.skipTest(\"svn.python.org responded too quickly\")\n                self.assertIn(rc, (errno.EAGAIN, errno.EWOULDBLOCK))\n            finally:\n                s.close()\n\n    def test_connect_ex_error(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                cert_reqs=ssl.CERT_REQUIRED,\n                                ca_certs=SVN_PYTHON_ORG_ROOT_CERT)\n            try:\n                self.assertEqual(errno.ECONNREFUSED,\n                                 s.connect_ex((\"svn.python.org\", 444)))\n            finally:\n                s.close()\n\n    def test_connect_with_context(self):\n        with support.transient_internet(\"svn.python.org\"):\n            # Same as test_connect, but with a separately created context\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                self.assertEqual({}, s.getpeercert())\n            finally:\n                s.close()\n            # Same with a server hostname\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"svn.python.org\")\n            if ssl.HAS_SNI:\n                s.connect((\"svn.python.org\", 443))\n                s.close()\n            else:\n                self.assertRaises(ValueError, s.connect, (\"svn.python.org\", 443))\n            # This should fail because we have no verification certs\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            self.assertRaisesRegex(ssl.SSLError, \"certificate verify failed\",\n                                    s.connect, (\"svn.python.org\", 443))\n            s.close()\n            # This should succeed because we specify the root cert\n            ctx.load_verify_locations(SVN_PYTHON_ORG_ROOT_CERT)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    def test_connect_capath(self):\n        # Verify server certificates using the `capath` argument\n        # NOTE: the subject hashing algorithm has been changed between\n        # OpenSSL 0.9.8n and 1.0.0, as a result the capath directory must\n        # contain both versions of each certificate (same content, different\n        # filename) for this test to be portable across OpenSSL releases.\n        with support.transient_internet(\"svn.python.org\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n            # Same with a bytes `capath` argument\n            ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(capath=BYTES_CAPATH)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET))\n            s.connect((\"svn.python.org\", 443))\n            try:\n                cert = s.getpeercert()\n                self.assertTrue(cert)\n            finally:\n                s.close()\n\n    @unittest.skipIf(os.name == \"nt\", \"Can't use a socket as a file under Windows\")\n    def test_makefile_close(self):\n        # Issue #5238: creating a file-like object with makefile() shouldn't\n        # delay closing the underlying \"real socket\" (here tested with its\n        # file descriptor, hence skipping the test under Windows).\n        with support.transient_internet(\"svn.python.org\"):\n            ss = ssl.wrap_socket(socket.socket(socket.AF_INET))\n            ss.connect((\"svn.python.org\", 443))\n            fd = ss.fileno()\n            f = ss.makefile()\n            f.close()\n            # The fd is still open\n            os.read(fd, 0)\n            # Closing the SSL socket should close the fd too\n            ss.close()\n            gc.collect()\n            with self.assertRaises(OSError) as e:\n                os.read(fd, 0)\n            self.assertEqual(e.exception.errno, errno.EBADF)\n\n    def test_non_blocking_handshake(self):\n        with support.transient_internet(\"svn.python.org\"):\n            s = socket.socket(socket.AF_INET)\n            s.connect((\"svn.python.org\", 443))\n            s.setblocking(False)\n            s = ssl.wrap_socket(s,\n                                cert_reqs=ssl.CERT_NONE,\n                                do_handshake_on_connect=False)\n            count = 0\n            while True:\n                try:\n                    count += 1\n                    s.do_handshake()\n                    break\n                except ssl.SSLWantReadError:\n                    select.select([s], [], [])\n                except ssl.SSLWantWriteError:\n                    select.select([], [s], [])\n            s.close()\n            if support.verbose:\n                sys.stdout.write(\"\\nNeeded %d calls to do_handshake() to establish session.\\n\" % count)\n\n    def test_get_server_certificate(self):\n        def _test_get_server_certificate(host, port, cert=None):\n            with support.transient_internet(host):\n                pem = ssl.get_server_certificate((host, port))\n                if not pem:\n                    self.fail(\"No server certificate on %s:%s!\" % (host, port))\n\n                try:\n                    pem = ssl.get_server_certificate((host, port), ca_certs=CERTFILE)\n                except ssl.SSLError as x:\n                    #should fail\n                    if support.verbose:\n                        sys.stdout.write(\"%s\\n\" % x)\n                else:\n                    self.fail(\"Got server certificate %s for %s:%s!\" % (pem, host, port))\n\n                pem = ssl.get_server_certificate((host, port), ca_certs=cert)\n                if not pem:\n                    self.fail(\"No server certificate on %s:%s!\" % (host, port))\n                if support.verbose:\n                    sys.stdout.write(\"\\nVerified certificate for %s:%s is\\n%s\\n\" % (host, port ,pem))\n\n        _test_get_server_certificate('svn.python.org', 443, SVN_PYTHON_ORG_ROOT_CERT)\n        if support.IPV6_ENABLED:\n            _test_get_server_certificate('ipv6.google.com', 443)\n\n    def test_ciphers(self):\n        remote = (\"svn.python.org\", 443)\n        with support.transient_internet(remote[0]):\n            with ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                 cert_reqs=ssl.CERT_NONE, ciphers=\"ALL\") as s:\n                s.connect(remote)\n            with ssl.wrap_socket(socket.socket(socket.AF_INET),\n                                 cert_reqs=ssl.CERT_NONE, ciphers=\"DEFAULT\") as s:\n                s.connect(remote)\n            # Error checking can happen at instantiation or when connecting\n            with self.assertRaisesRegex(ssl.SSLError, \"No cipher can be selected\"):\n                with socket.socket(socket.AF_INET) as sock:\n                    s = ssl.wrap_socket(sock,\n                                        cert_reqs=ssl.CERT_NONE, ciphers=\"^$:,;?*'dorothyx\")\n                    s.connect(remote)\n\n    def test_algorithms(self):\n        # Issue #8484: all algorithms should be available when verifying a\n        # certificate.\n        # SHA256 was added in OpenSSL 0.9.8\n        if ssl.OPENSSL_VERSION_INFO < (0, 9, 8, 0, 15):\n            self.skipTest(\"SHA256 not available on %r\" % ssl.OPENSSL_VERSION)\n        # sha256.tbs-internet.com needs SNI to use the correct certificate\n        if not ssl.HAS_SNI:\n            self.skipTest(\"SNI needed for this test\")\n        # https://sha2.hboeck.de/ was used until 2011-01-08 (no route to host)\n        remote = (\"sha256.tbs-internet.com\", 443)\n        sha256_cert = os.path.join(os.path.dirname(__file__), \"sha256.pem\")\n        with support.transient_internet(\"sha256.tbs-internet.com\"):\n            ctx = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            ctx.verify_mode = ssl.CERT_REQUIRED\n            ctx.load_verify_locations(sha256_cert)\n            s = ctx.wrap_socket(socket.socket(socket.AF_INET),\n                                server_hostname=\"sha256.tbs-internet.com\")\n            try:\n                s.connect(remote)\n                if support.verbose:\n                    sys.stdout.write(\"\\nCipher with %r is %r\\n\" %\n                                     (remote, s.cipher()))\n                    sys.stdout.write(\"Certificate is:\\n%s\\n\" %\n                                     pprint.pformat(s.getpeercert()))\n            finally:\n                s.close()\n\n\ntry:\n    import threading\nexcept ImportError:\n    _have_threads = False\nelse:\n    _have_threads = True\n\n    from test.ssl_servers import make_https_server\n\n    class ThreadedEchoServer(threading.Thread):\n\n        class ConnectionHandler(threading.Thread):\n\n            \"\"\"A mildly complicated class, because we want it to work both\n            with and without the SSL wrapper around the socket connection, so\n            that we can test the STARTTLS functionality.\"\"\"\n\n            def __init__(self, server, connsock, addr):\n                self.server = server\n                self.running = False\n                self.sock = connsock\n                self.addr = addr\n                self.sock.setblocking(1)\n                self.sslconn = None\n                threading.Thread.__init__(self)\n                self.daemon = True\n\n            def wrap_conn(self):\n                try:\n                    self.sslconn = self.server.context.wrap_socket(\n                        self.sock, server_side=True)\n                    self.server.selected_protocols.append(self.sslconn.selected_npn_protocol())\n                except (ssl.SSLError, ConnectionResetError) as e:\n                    # We treat ConnectionResetError as though it were an\n                    # SSLError - OpenSSL on Ubuntu abruptly closes the\n                    # connection when asked to use an unsupported protocol.\n                    #\n                    # XXX Various errors can have happened here, for example\n                    # a mismatching protocol version, an invalid certificate,\n                    # or a low-level bug. This should be made more discriminating.\n                    self.server.conn_errors.append(e)\n                    if self.server.chatty:\n                        handle_error(\"\\n server:  bad connection attempt from \" + repr(self.addr) + \":\\n\")\n                    self.running = False\n                    self.server.stop()\n                    self.close()\n                    return False\n                else:\n                    if self.server.context.verify_mode == ssl.CERT_REQUIRED:\n                        cert = self.sslconn.getpeercert()\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" client cert is \" + pprint.pformat(cert) + \"\\n\")\n                        cert_binary = self.sslconn.getpeercert(True)\n                        if support.verbose and self.server.chatty:\n                            sys.stdout.write(\" cert binary is \" + str(len(cert_binary)) + \" bytes\\n\")\n                    cipher = self.sslconn.cipher()\n                    if support.verbose and self.server.chatty:\n                        sys.stdout.write(\" server: connection cipher is now \" + str(cipher) + \"\\n\")\n                        sys.stdout.write(\" server: selected protocol is now \"\n                                + str(self.sslconn.selected_npn_protocol()) + \"\\n\")\n                    return True\n\n            def read(self):\n                if self.sslconn:\n                    return self.sslconn.read()\n                else:\n                    return self.sock.recv(1024)\n\n            def write(self, bytes):\n                if self.sslconn:\n                    return self.sslconn.write(bytes)\n                else:\n                    return self.sock.send(bytes)\n\n            def close(self):\n                if self.sslconn:\n                    self.sslconn.close()\n                else:\n                    self.sock.close()\n\n            def run(self):\n                self.running = True\n                if not self.server.starttls_server:\n                    if not self.wrap_conn():\n                        return\n                while self.running:\n                    try:\n                        msg = self.read()\n                        stripped = msg.strip()\n                        if not stripped:\n                            # eof, so quit this handler\n                            self.running = False\n                            self.close()\n                        elif stripped == b'over':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: client closed connection\\n\")\n                            self.close()\n                            return\n                        elif (self.server.starttls_server and\n                              stripped == b'STARTTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read STARTTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            if not self.wrap_conn():\n                                return\n                        elif (self.server.starttls_server and self.sslconn\n                              and stripped == b'ENDTLS'):\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read ENDTLS from client, sending OK...\\n\")\n                            self.write(b\"OK\\n\")\n                            self.sock = self.sslconn.unwrap()\n                            self.sslconn = None\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: connection is now unencrypted...\\n\")\n                        elif stripped == b'CB tls-unique':\n                            if support.verbose and self.server.connectionchatty:\n                                sys.stdout.write(\" server: read CB tls-unique from client, sending our CB data...\\n\")\n                            data = self.sslconn.get_channel_binding(\"tls-unique\")\n                            self.write(repr(data).encode(\"us-ascii\") + b\"\\n\")\n                        else:\n                            if (support.verbose and\n                                self.server.connectionchatty):\n                                ctype = (self.sslconn and \"encrypted\") or \"unencrypted\"\n                                sys.stdout.write(\" server: read %r (%s), sending back %r (%s)...\\n\"\n                                                 % (msg, ctype, msg.lower(), ctype))\n                            self.write(msg.lower())\n                    except socket.error:\n                        if self.server.chatty:\n                            handle_error(\"Test server failure:\\n\")\n                        self.close()\n                        self.running = False\n                        # normally, we'd just stop here, but for the test\n                        # harness, we want to stop the server\n                        self.server.stop()\n\n        def __init__(self, certificate=None, ssl_version=None,\n                     certreqs=None, cacerts=None,\n                     chatty=True, connectionchatty=False, starttls_server=False,\n                     npn_protocols=None, ciphers=None, context=None):\n            if context:\n                self.context = context\n            else:\n                self.context = ssl.SSLContext(ssl_version\n                                              if ssl_version is not None\n                                              else ssl.PROTOCOL_TLSv1)\n                self.context.verify_mode = (certreqs if certreqs is not None\n                                            else ssl.CERT_NONE)\n                if cacerts:\n                    self.context.load_verify_locations(cacerts)\n                if certificate:\n                    self.context.load_cert_chain(certificate)\n                if npn_protocols:\n                    self.context.set_npn_protocols(npn_protocols)\n                if ciphers:\n                    self.context.set_ciphers(ciphers)\n            self.chatty = chatty\n            self.connectionchatty = connectionchatty\n            self.starttls_server = starttls_server\n            self.sock = socket.socket()\n            self.port = support.bind_port(self.sock)\n            self.flag = None\n            self.active = False\n            self.selected_protocols = []\n            self.conn_errors = []\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            self.stop()\n            self.join()\n\n        def start(self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.sock.settimeout(0.05)\n            self.sock.listen(5)\n            self.active = True\n            if self.flag:\n                # signal an event\n                self.flag.set()\n            while self.active:\n                try:\n                    newconn, connaddr = self.sock.accept()\n                    if support.verbose and self.chatty:\n                        sys.stdout.write(' server:  new connection from '\n                                         + repr(connaddr) + '\\n')\n                    handler = self.ConnectionHandler(self, newconn, connaddr)\n                    handler.start()\n                    handler.join()\n                except socket.timeout:\n                    pass\n                except KeyboardInterrupt:\n                    self.stop()\n            self.sock.close()\n\n        def stop(self):\n            self.active = False\n\n    class AsyncoreEchoServer(threading.Thread):\n\n        # this one's based on asyncore.dispatcher\n\n        class EchoServer (asyncore.dispatcher):\n\n            class ConnectionHandler (asyncore.dispatcher_with_send):\n\n                def __init__(self, conn, certfile):\n                    self.socket = ssl.wrap_socket(conn, server_side=True,\n                                                  certfile=certfile,\n                                                  do_handshake_on_connect=False)\n                    asyncore.dispatcher_with_send.__init__(self, self.socket)\n                    self._ssl_accepting = True\n                    self._do_ssl_handshake()\n\n                def readable(self):\n                    if isinstance(self.socket, ssl.SSLSocket):\n                        while self.socket.pending() > 0:\n                            self.handle_read_event()\n                    return True\n\n                def _do_ssl_handshake(self):\n                    try:\n                        self.socket.do_handshake()\n                    except (ssl.SSLWantReadError, ssl.SSLWantWriteError):\n                        return\n                    except ssl.SSLEOFError:\n                        return self.handle_close()\n                    except ssl.SSLError:\n                        raise\n                    except socket.error as err:\n                        if err.args[0] == errno.ECONNABORTED:\n                            return self.handle_close()\n                    else:\n                        self._ssl_accepting = False\n\n                def handle_read(self):\n                    if self._ssl_accepting:\n                        self._do_ssl_handshake()\n                    else:\n                        data = self.recv(1024)\n                        if support.verbose:\n                            sys.stdout.write(\" server:  read %s from client\\n\" % repr(data))\n                        if not data:\n                            self.close()\n                        else:\n                            self.send(data.lower())\n\n                def handle_close(self):\n                    self.close()\n                    if support.verbose:\n                        sys.stdout.write(\" server:  closed connection %s\\n\" % self.socket)\n\n                def handle_error(self):\n                    raise\n\n            def __init__(self, certfile):\n                self.certfile = certfile\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.port = support.bind_port(sock, '')\n                asyncore.dispatcher.__init__(self, sock)\n                self.listen(5)\n\n            def handle_accepted(self, sock_obj, addr):\n                if support.verbose:\n                    sys.stdout.write(\" server:  new connection from %s:%s\\n\" %addr)\n                self.ConnectionHandler(sock_obj, self.certfile)\n\n            def handle_error(self):\n                raise\n\n        def __init__(self, certfile):\n            self.flag = None\n            self.active = False\n            self.server = self.EchoServer(certfile)\n            self.port = self.server.port\n            threading.Thread.__init__(self)\n            self.daemon = True\n\n        def __str__(self):\n            return \"<%s %s>\" % (self.__class__.__name__, self.server)\n\n        def __enter__(self):\n            self.start(threading.Event())\n            self.flag.wait()\n            return self\n\n        def __exit__(self, *args):\n            if support.verbose:\n                sys.stdout.write(\" cleanup: stopping server.\\n\")\n            self.stop()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: joining server thread.\\n\")\n            self.join()\n            if support.verbose:\n                sys.stdout.write(\" cleanup: successfully joined.\\n\")\n\n        def start (self, flag=None):\n            self.flag = flag\n            threading.Thread.start(self)\n\n        def run(self):\n            self.active = True\n            if self.flag:\n                self.flag.set()\n            while self.active:\n                try:\n                    asyncore.loop(1)\n                except:\n                    pass\n\n        def stop(self):\n            self.active = False\n            self.server.close()\n\n    def bad_cert_test(certfile):\n        \"\"\"\n        Launch a server with CERT_REQUIRED, and check that trying to\n        connect to it with the given client certificate fails.\n        \"\"\"\n        server = ThreadedEchoServer(CERTFILE,\n                                    certreqs=ssl.CERT_REQUIRED,\n                                    cacerts=CERTFILE, chatty=False,\n                                    connectionchatty=False)\n        with server:\n            try:\n                with socket.socket() as sock:\n                    s = ssl.wrap_socket(sock,\n                                        certfile=certfile,\n                                        ssl_version=ssl.PROTOCOL_TLSv1)\n                    s.connect((HOST, server.port))\n            except ssl.SSLError as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nSSLError is %s\\n\" % x.args[1])\n            except socket.error as x:\n                if support.verbose:\n                    sys.stdout.write(\"\\nsocket.error is %s\\n\" % x.args[1])\n            except IOError as x:\n                if x.errno != errno.ENOENT:\n                    raise\n                if support.verbose:\n                    sys.stdout.write(\"\\IOError is %s\\n\" % str(x))\n            else:\n                raise AssertionError(\"Use of invalid cert should have failed!\")\n\n    def server_params_test(client_context, server_context, indata=b\"FOO\\n\",\n                           chatty=True, connectionchatty=False):\n        \"\"\"\n        Launch a server, connect a client to it and try various reads\n        and writes.\n        \"\"\"\n        stats = {}\n        server = ThreadedEchoServer(context=server_context,\n                                    chatty=chatty,\n                                    connectionchatty=False)\n        with server:\n            with client_context.wrap_socket(socket.socket()) as s:\n                s.connect((HOST, server.port))\n                for arg in [indata, bytearray(indata), memoryview(indata)]:\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  sending %r...\\n\" % indata)\n                    s.write(arg)\n                    outdata = s.read()\n                    if connectionchatty:\n                        if support.verbose:\n                            sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                    if outdata != indata.lower():\n                        raise AssertionError(\n                            \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                            % (outdata[:20], len(outdata),\n                               indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if connectionchatty:\n                    if support.verbose:\n                        sys.stdout.write(\" client:  closing connection.\\n\")\n                stats.update({\n                    'compression': s.compression(),\n                    'cipher': s.cipher(),\n                    'client_npn_protocol': s.selected_npn_protocol()\n                })\n                s.close()\n            stats['server_npn_protocols'] = server.selected_protocols\n        return stats\n\n    def try_protocol_combo(server_protocol, client_protocol, expect_success,\n                           certsreqs=None, server_options=0, client_options=0):\n        if certsreqs is None:\n            certsreqs = ssl.CERT_NONE\n        certtype = {\n            ssl.CERT_NONE: \"CERT_NONE\",\n            ssl.CERT_OPTIONAL: \"CERT_OPTIONAL\",\n            ssl.CERT_REQUIRED: \"CERT_REQUIRED\",\n        }[certsreqs]\n        if support.verbose:\n            formatstr = (expect_success and \" %s->%s %s\\n\") or \" {%s->%s} %s\\n\"\n            sys.stdout.write(formatstr %\n                             (ssl.get_protocol_name(client_protocol),\n                              ssl.get_protocol_name(server_protocol),\n                              certtype))\n        client_context = ssl.SSLContext(client_protocol)\n        client_context.options = ssl.OP_ALL | client_options\n        server_context = ssl.SSLContext(server_protocol)\n        server_context.options = ssl.OP_ALL | server_options\n        for ctx in (client_context, server_context):\n            ctx.verify_mode = certsreqs\n            # NOTE: we must enable \"ALL\" ciphers, otherwise an SSLv23 client\n            # will send an SSLv3 hello (rather than SSLv2) starting from\n            # OpenSSL 1.0.0 (see issue #8322).\n            ctx.set_ciphers(\"ALL\")\n            ctx.load_cert_chain(CERTFILE)\n            ctx.load_verify_locations(CERTFILE)\n        try:\n            server_params_test(client_context, server_context,\n                               chatty=False, connectionchatty=False)\n        # Protocol mismatch can result in either an SSLError, or a\n        # \"Connection reset by peer\" error.\n        except ssl.SSLError:\n            if expect_success:\n                raise\n        except socket.error as e:\n            if expect_success or e.errno != errno.ECONNRESET:\n                raise\n        else:\n            if not expect_success:\n                raise AssertionError(\n                    \"Client protocol %s succeeded with server protocol %s!\"\n                    % (ssl.get_protocol_name(client_protocol),\n                       ssl.get_protocol_name(server_protocol)))\n\n\n    class ThreadedTests(unittest.TestCase):\n\n        @skip_if_broken_ubuntu_ssl\n        def test_echo(self):\n            \"\"\"Basic test of an SSL client connecting to a server\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            for protocol in PROTOCOLS:\n                context = ssl.SSLContext(protocol)\n                context.load_cert_chain(CERTFILE)\n                server_params_test(context, context,\n                                   chatty=True, connectionchatty=True)\n\n        def test_getpeercert(self):\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = ThreadedEchoServer(context=context, chatty=False)\n            with server:\n                s = context.wrap_socket(socket.socket())\n                s.connect((HOST, server.port))\n                cert = s.getpeercert()\n                self.assertTrue(cert, \"Can't get peer certificate.\")\n                cipher = s.cipher()\n                if support.verbose:\n                    sys.stdout.write(pprint.pformat(cert) + '\\n')\n                    sys.stdout.write(\"Connection cipher is \" + str(cipher) + '.\\n')\n                if 'subject' not in cert:\n                    self.fail(\"No subject field in certificate: %s.\" %\n                              pprint.pformat(cert))\n                if ((('organizationName', 'Python Software Foundation'),)\n                    not in cert['subject']):\n                    self.fail(\n                        \"Missing or invalid 'organizationName' field in certificate subject; \"\n                        \"should be 'Python Software Foundation'.\")\n                self.assertIn('notBefore', cert)\n                self.assertIn('notAfter', cert)\n                before = ssl.cert_time_to_seconds(cert['notBefore'])\n                after = ssl.cert_time_to_seconds(cert['notAfter'])\n                self.assertLess(before, after)\n                s.close()\n\n        def test_empty_cert(self):\n            \"\"\"Connecting with an empty cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                      \"nullcert.pem\"))\n        def test_malformed_cert(self):\n            \"\"\"Connecting with a badly formatted certificate (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badcert.pem\"))\n        def test_nonexisting_cert(self):\n            \"\"\"Connecting with a non-existing cert file\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"wrongcert.pem\"))\n        def test_malformed_key(self):\n            \"\"\"Connecting with a badly formatted key (syntax error)\"\"\"\n            bad_cert_test(os.path.join(os.path.dirname(__file__) or os.curdir,\n                                       \"badkey.pem\"))\n\n        def test_rude_shutdown(self):\n            \"\"\"A brutal shutdown of an SSL server should raise an IOError\n            in the client when attempting handshake.\n            \"\"\"\n            listener_ready = threading.Event()\n            listener_gone = threading.Event()\n\n            s = socket.socket()\n            port = support.bind_port(s, HOST)\n\n            # `listener` runs in a thread.  It sits in an accept() until\n            # the main thread connects.  Then it rudely closes the socket,\n            # and sets Event `listener_gone` to let the main thread know\n            # the socket is gone.\n            def listener():\n                s.listen(5)\n                listener_ready.set()\n                newsock, addr = s.accept()\n                newsock.close()\n                s.close()\n                listener_gone.set()\n\n            def connector():\n                listener_ready.wait()\n                with socket.socket() as c:\n                    c.connect((HOST, port))\n                    listener_gone.wait()\n                    try:\n                        ssl_sock = ssl.wrap_socket(c)\n                    except IOError:\n                        pass\n                    else:\n                        self.fail('connecting to closed SSL socket should have failed')\n\n            t = threading.Thread(target=listener)\n            t.start()\n            try:\n                connector()\n            finally:\n                t.join()\n\n        @skip_if_broken_ubuntu_ssl\n        @unittest.skipUnless(hasattr(ssl, 'PROTOCOL_SSLv2'),\n                             \"OpenSSL is compiled without SSLv2 support\")\n        def test_protocol_sslv2(self):\n            \"\"\"Connecting to an SSLv2 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv2, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_TLSv1, False)\n            # SSLv23 client with specific SSL options\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, False,\n                                   client_options=ssl.OP_NO_SSLv2)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv2, ssl.PROTOCOL_SSLv23, True,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv23(self):\n            \"\"\"Connecting to an SSLv23 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try:\n                    try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv2, True)\n                except (ssl.SSLError, socket.error) as x:\n                    # this fails on some older versions of OpenSSL (0.9.7l, for instance)\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" SSL2 client to SSL23 server test unexpectedly failed:\\n %s\\n\"\n                            % str(x))\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True, ssl.CERT_REQUIRED)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n\n            # Server with specific SSL options\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv3, False,\n                               server_options=ssl.OP_NO_SSLv3)\n            # Will choose TLSv1\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23, True,\n                               server_options=ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_TLSv1, False,\n                               server_options=ssl.OP_NO_TLSv1)\n\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_sslv3(self):\n            \"\"\"Connecting to an SSLv3 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv3, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_SSLv3)\n            try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_TLSv1, False)\n            if no_sslv2_implies_sslv3_hello():\n                # No SSLv2 => client will use an SSLv3 hello on recent OpenSSLs\n                try_protocol_combo(ssl.PROTOCOL_SSLv3, ssl.PROTOCOL_SSLv23, True,\n                                   client_options=ssl.OP_NO_SSLv2)\n\n        @skip_if_broken_ubuntu_ssl\n        def test_protocol_tlsv1(self):\n            \"\"\"Connecting to a TLSv1 server with various client options\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_OPTIONAL)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1, True, ssl.CERT_REQUIRED)\n            if hasattr(ssl, 'PROTOCOL_SSLv2'):\n                try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv2, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv3, False)\n            try_protocol_combo(ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_SSLv23, False,\n                               client_options=ssl.OP_NO_TLSv1)\n\n        def test_starttls(self):\n            \"\"\"Switching from clear text to encrypted and back again.\"\"\"\n            msgs = (b\"msg 1\", b\"MSG 2\", b\"STARTTLS\", b\"MSG 3\", b\"msg 4\", b\"ENDTLS\", b\"msg 5\", b\"msg 6\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        starttls_server=True,\n                                        chatty=True,\n                                        connectionchatty=True)\n            wrapped = False\n            with server:\n                s = socket.socket()\n                s.setblocking(1)\n                s.connect((HOST, server.port))\n                if support.verbose:\n                    sys.stdout.write(\"\\n\")\n                for indata in msgs:\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client:  sending %r...\\n\" % indata)\n                    if wrapped:\n                        conn.write(indata)\n                        outdata = conn.read()\n                    else:\n                        s.send(indata)\n                        outdata = s.recv(1024)\n                    msg = outdata.strip().lower()\n                    if indata == b\"STARTTLS\" and msg.startswith(b\"ok\"):\n                        # STARTTLS ok, switch to secure mode\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, starting TLS...\\n\"\n                                % msg)\n                        conn = ssl.wrap_socket(s, ssl_version=ssl.PROTOCOL_TLSv1)\n                        wrapped = True\n                    elif indata == b\"ENDTLS\" and msg.startswith(b\"ok\"):\n                        # ENDTLS ok, switch back to clear text\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server, ending TLS...\\n\"\n                                % msg)\n                        s = conn.unwrap()\n                        wrapped = False\n                    else:\n                        if support.verbose:\n                            sys.stdout.write(\n                                \" client:  read %r from server\\n\" % msg)\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                if wrapped:\n                    conn.write(b\"over\\n\")\n                else:\n                    s.send(b\"over\\n\")\n                if wrapped:\n                    conn.close()\n                else:\n                    s.close()\n\n        def test_socketserver(self):\n            \"\"\"Using a SocketServer to create and manage SSL connections.\"\"\"\n            server = make_https_server(self, CERTFILE)\n            # try to connect\n            if support.verbose:\n                sys.stdout.write('\\n')\n            with open(CERTFILE, 'rb') as f:\n                d1 = f.read()\n            d2 = ''\n            # now fetch the same data from the HTTPS server\n            url = 'https://%s:%d/%s' % (\n                HOST, server.port, os.path.split(CERTFILE)[1])\n            f = urllib.request.urlopen(url)\n            try:\n                dlen = f.info().get(\"content-length\")\n                if dlen and (int(dlen) > 0):\n                    d2 = f.read(int(dlen))\n                    if support.verbose:\n                        sys.stdout.write(\n                            \" client: read %d bytes from remote server '%s'\\n\"\n                            % (len(d2), server))\n            finally:\n                f.close()\n            self.assertEqual(d1, d2)\n\n        def test_asyncore_server(self):\n            \"\"\"Check the example asyncore integration.\"\"\"\n            indata = \"TEST MESSAGE of mixed case\\n\"\n\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            indata = b\"FOO\\n\"\n            server = AsyncoreEchoServer(CERTFILE)\n            with server:\n                s = ssl.wrap_socket(socket.socket())\n                s.connect(('127.0.0.1', server.port))\n                if support.verbose:\n                    sys.stdout.write(\n                        \" client:  sending %r...\\n\" % indata)\n                s.write(indata)\n                outdata = s.read()\n                if support.verbose:\n                    sys.stdout.write(\" client:  read %r\\n\" % outdata)\n                if outdata != indata.lower():\n                    self.fail(\n                        \"bad data <<%r>> (%d) received; expected <<%r>> (%d)\\n\"\n                        % (outdata[:20], len(outdata),\n                           indata[:20].lower(), len(indata)))\n                s.write(b\"over\\n\")\n                if support.verbose:\n                    sys.stdout.write(\" client:  closing connection.\\n\")\n                s.close()\n                if support.verbose:\n                    sys.stdout.write(\" client:  connection closed.\\n\")\n\n        def test_recv_send(self):\n            \"\"\"Test recv(), send() and friends.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # helper methods for standardising recv* method signatures\n                def _recv_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count = s.recv_into(b)\n                    return b[:count]\n\n                def _recvfrom_into():\n                    b = bytearray(b\"\\0\"*100)\n                    count, addr = s.recvfrom_into(b)\n                    return b[:count]\n\n                # (name, method, whether to expect success, *args)\n                send_methods = [\n                    ('send', s.send, True, []),\n                    ('sendto', s.sendto, False, [\"some.address\"]),\n                    ('sendall', s.sendall, True, []),\n                ]\n                recv_methods = [\n                    ('recv', s.recv, True, []),\n                    ('recvfrom', s.recvfrom, False, [\"some.address\"]),\n                    ('recv_into', _recv_into, True, []),\n                    ('recvfrom_into', _recvfrom_into, False, []),\n                ]\n                data_prefix = \"PREFIX_\"\n\n                for meth_name, send_meth, expect_success, args in send_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        send_meth(indata, *args)\n                        outdata = s.read()\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While sending with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to send with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n\n                for meth_name, recv_meth, expect_success, args in recv_methods:\n                    indata = (data_prefix + meth_name).encode('ascii')\n                    try:\n                        s.send(indata)\n                        outdata = recv_meth(*args)\n                        if outdata != indata.lower():\n                            self.fail(\n                                \"While receiving with <<{name:s}>> bad data \"\n                                \"<<{outdata:r}>> ({nout:d}) received; \"\n                                \"expected <<{indata:r}>> ({nin:d})\\n\".format(\n                                    name=meth_name, outdata=outdata[:20],\n                                    nout=len(outdata),\n                                    indata=indata[:20], nin=len(indata)\n                                )\n                            )\n                    except ValueError as e:\n                        if expect_success:\n                            self.fail(\n                                \"Failed to receive with method <<{name:s}>>; \"\n                                \"expected to succeed.\\n\".format(name=meth_name)\n                            )\n                        if not str(e).startswith(meth_name):\n                            self.fail(\n                                \"Method <<{name:s}>> failed with unexpected \"\n                                \"exception message: {exp:s}\\n\".format(\n                                    name=meth_name, exp=e\n                                )\n                            )\n                        # consume data\n                        s.read()\n\n                # Make sure sendmsg et al are disallowed to avoid\n                # inadvertent disclosure of data and/or corruption\n                # of the encrypted data stream\n                self.assertRaises(NotImplementedError, s.sendmsg, [b\"data\"])\n                self.assertRaises(NotImplementedError, s.recvmsg, 100)\n                self.assertRaises(NotImplementedError,\n                                  s.recvmsg_into, bytearray(100))\n\n                s.write(b\"over\\n\")\n                s.close()\n\n        def test_handshake_timeout(self):\n            # Issue #5103: SSL handshake must respect the socket timeout\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            started = threading.Event()\n            finish = False\n\n            def serve():\n                server.listen(5)\n                started.set()\n                conns = []\n                while not finish:\n                    r, w, e = select.select([server], [], [], 0.1)\n                    if server in r:\n                        # Let the socket hang around rather than having\n                        # it closed by garbage collection.\n                        conns.append(server.accept()[0])\n                for sock in conns:\n                    sock.close()\n\n            t = threading.Thread(target=serve)\n            t.start()\n            started.wait()\n\n            try:\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c.settimeout(0.2)\n                    c.connect((host, port))\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           ssl.wrap_socket, c)\n                finally:\n                    c.close()\n                try:\n                    c = socket.socket(socket.AF_INET)\n                    c = ssl.wrap_socket(c)\n                    c.settimeout(0.2)\n                    # Will attempt handshake and time out\n                    self.assertRaisesRegex(socket.timeout, \"timed out\",\n                                           c.connect, (host, port))\n                finally:\n                    c.close()\n            finally:\n                finish = True\n                t.join()\n                server.close()\n\n        def test_server_accept(self):\n            # Issue #16357: accept() on a SSLSocket created through\n            # SSLContext.wrap_socket().\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            context.verify_mode = ssl.CERT_REQUIRED\n            context.load_verify_locations(CERTFILE)\n            context.load_cert_chain(CERTFILE)\n            server = socket.socket(socket.AF_INET)\n            host = \"127.0.0.1\"\n            port = support.bind_port(server)\n            server = context.wrap_socket(server, server_side=True)\n\n            evt = threading.Event()\n            remote = None\n            peer = None\n            def serve():\n                nonlocal remote, peer\n                server.listen(5)\n                # Block on the accept and wait on the connection to close.\n                evt.set()\n                remote, peer = server.accept()\n                remote.recv(1)\n\n            t = threading.Thread(target=serve)\n            t.start()\n            # Client wait until server setup and perform a connect.\n            evt.wait()\n            client = context.wrap_socket(socket.socket())\n            client.connect((host, port))\n            client_addr = client.getsockname()\n            client.close()\n            t.join()\n            remote.close()\n            server.close()\n            # Sanity checks.\n            self.assertIsInstance(remote, ssl.SSLSocket)\n            self.assertEqual(peer, client_addr)\n\n        def test_default_ciphers(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n            try:\n                # Force a set of weak ciphers on our client context\n                context.set_ciphers(\"DES\")\n            except ssl.SSLError:\n                self.skipTest(\"no DES cipher available\")\n            with ThreadedEchoServer(CERTFILE,\n                                    ssl_version=ssl.PROTOCOL_SSLv23,\n                                    chatty=False) as server:\n                with context.wrap_socket(socket.socket()) as s:\n                    with self.assertRaises((OSError, ssl.SSLError)):\n                        s.connect((HOST, server.port))\n            self.assertIn(\"no shared cipher\", str(server.conn_errors[0]))\n\n        @unittest.skipUnless(\"tls-unique\" in ssl.CHANNEL_BINDING_TYPES,\n                             \"'tls-unique' channel binding not available\")\n        def test_tls_unique_channel_binding(self):\n            \"\"\"Test tls-unique channel binding.\"\"\"\n            if support.verbose:\n                sys.stdout.write(\"\\n\")\n\n            server = ThreadedEchoServer(CERTFILE,\n                                        certreqs=ssl.CERT_NONE,\n                                        ssl_version=ssl.PROTOCOL_TLSv1,\n                                        cacerts=CERTFILE,\n                                        chatty=True,\n                                        connectionchatty=False)\n            with server:\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                # get the data\n                cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\" got channel binding data: {0!r}\\n\"\n                                     .format(cb_data))\n\n                # check if it is sane\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n\n                # and compare with the peers version\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(cb_data).encode(\"us-ascii\"))\n                s.close()\n\n                # now, again\n                s = ssl.wrap_socket(socket.socket(),\n                                    server_side=False,\n                                    certfile=CERTFILE,\n                                    ca_certs=CERTFILE,\n                                    cert_reqs=ssl.CERT_NONE,\n                                    ssl_version=ssl.PROTOCOL_TLSv1)\n                s.connect((HOST, server.port))\n                new_cb_data = s.get_channel_binding(\"tls-unique\")\n                if support.verbose:\n                    sys.stdout.write(\" got another channel binding data: {0!r}\\n\"\n                                     .format(new_cb_data))\n                # is it really unique\n                self.assertNotEqual(cb_data, new_cb_data)\n                self.assertIsNotNone(cb_data)\n                self.assertEqual(len(cb_data), 12) # True for TLSv1\n                s.write(b\"CB tls-unique\\n\")\n                peer_data_repr = s.read().strip()\n                self.assertEqual(peer_data_repr,\n                                 repr(new_cb_data).encode(\"us-ascii\"))\n                s.close()\n\n        def test_compression(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            if support.verbose:\n                sys.stdout.write(\" got compression: {!r}\\n\".format(stats['compression']))\n            self.assertIn(stats['compression'], { None, 'ZLIB', 'RLE' })\n\n        @unittest.skipUnless(hasattr(ssl, 'OP_NO_COMPRESSION'),\n                             \"ssl.OP_NO_COMPRESSION needed for this test\")\n        def test_compression_disabled(self):\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            context.options |= ssl.OP_NO_COMPRESSION\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            self.assertIs(stats['compression'], None)\n\n        def test_dh_params(self):\n            # Check we can get a connection with ephemeral Diffie-Hellman\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            context.load_dh_params(DHFILE)\n            context.set_ciphers(\"kEDH\")\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            cipher = stats[\"cipher\"][0]\n            parts = cipher.split(\"-\")\n            if \"ADH\" not in parts and \"EDH\" not in parts and \"DHE\" not in parts:\n                self.fail(\"Non-DH cipher: \" + cipher[0])\n\n        def test_selected_npn_protocol(self):\n            # selected_npn_protocol() is None unless NPN is used\n            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n            context.load_cert_chain(CERTFILE)\n            stats = server_params_test(context, context,\n                                       chatty=True, connectionchatty=True)\n            self.assertIs(stats['client_npn_protocol'], None)\n\n        @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")\n        def test_npn_protocols(self):\n            server_protocols = ['http/1.1', 'spdy/2']\n            protocol_tests = [\n                (['http/1.1', 'spdy/2'], 'http/1.1'),\n                (['spdy/2', 'http/1.1'], 'http/1.1'),\n                (['spdy/2', 'test'], 'spdy/2'),\n                (['abc', 'def'], 'abc')\n            ]\n            for client_protocols, expected in protocol_tests:\n                server_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n                server_context.load_cert_chain(CERTFILE)\n                server_context.set_npn_protocols(server_protocols)\n                client_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n                client_context.load_cert_chain(CERTFILE)\n                client_context.set_npn_protocols(client_protocols)\n                stats = server_params_test(client_context, server_context,\n                                           chatty=True, connectionchatty=True)\n\n                msg = \"failed trying %s (s) and %s (c).\\n\" \\\n                      \"was expecting %s, but got %%s from the %%s\" \\\n                          % (str(server_protocols), str(client_protocols),\n                             str(expected))\n                client_result = stats['client_npn_protocol']\n                self.assertEqual(client_result, expected, msg % (client_result, \"client\"))\n                server_result = stats['server_npn_protocols'][-1] \\\n                    if len(stats['server_npn_protocols']) else 'nothing'\n                self.assertEqual(server_result, expected, msg % (server_result, \"server\"))\n\n\ndef test_main(verbose=False):\n    if support.verbose:\n        plats = {\n            'Linux': platform.linux_distribution,\n            'Mac': platform.mac_ver,\n            'Windows': platform.win32_ver,\n        }\n        for name, func in plats.items():\n            plat = func()\n            if plat and plat[0]:\n                plat = '%s %r' % (name, plat)\n                break\n        else:\n            plat = repr(platform.platform())\n        print(\"test_ssl: testing with %r %r\" %\n            (ssl.OPENSSL_VERSION, ssl.OPENSSL_VERSION_INFO))\n        print(\"          under %s\" % plat)\n        print(\"          HAS_SNI = %r\" % ssl.HAS_SNI)\n\n    for filename in [\n        CERTFILE, SVN_PYTHON_ORG_ROOT_CERT, BYTES_CERTFILE,\n        ONLYCERT, ONLYKEY, BYTES_ONLYCERT, BYTES_ONLYKEY,\n        BADCERT, BADKEY, EMPTYCERT]:\n        if not os.path.exists(filename):\n            raise support.TestFailed(\"Can't read certificate file %r\" % filename)\n\n    tests = [ContextTests, BasicSocketTests, SSLErrorTests]\n\n    if support.is_resource_enabled('network'):\n        tests.append(NetworkedTests)\n\n    if _have_threads:\n        thread_info = support.threading_setup()\n        if thread_info:\n            tests.append(ThreadedTests)\n\n    try:\n        support.run_unittest(*tests)\n    finally:\n        if _have_threads:\n            support.threading_cleanup(*thread_info)\n\nif __name__ == \"__main__\":\n    test_main()\n"
  },
  {
    "patch": "diff --git a/Lib/test/test_codecs.py b/Lib/test/test_codecs.py\nindex 4899a59ef2d..3426a4dde9a 100644\n--- a/Lib/test/test_codecs.py\n+++ b/Lib/test/test_codecs.py\n@@ -540,8 +540,19 @@ def test_partial(self):\n         )\n \n     def test_errors(self):\n-        self.assertRaises(UnicodeDecodeError, codecs.utf_16_le_decode,\n-                          b\"\\xff\", \"strict\", True)\n+        tests = [\n+            (b'\\xff', '\\ufffd'),\n+            (b'A\\x00Z', 'A\\ufffd'),\n+            (b'A\\x00B\\x00C\\x00D\\x00Z', 'ABCD\\ufffd'),\n+            (b'\\x00\\xd8', '\\ufffd'),\n+            (b'\\x00\\xd8A', '\\ufffd'),\n+            (b'\\x00\\xd8A\\x00', '\\ufffdA'),\n+            (b'\\x00\\xdcA\\x00', '\\ufffdA'),\n+        ]\n+        for raw, expected in tests:\n+            self.assertRaises(UnicodeDecodeError, codecs.utf_16_le_decode,\n+                              raw, 'strict', True)\n+            self.assertEqual(raw.decode('utf-16le', 'replace'), expected)\n \n     def test_nonbmp(self):\n         self.assertEqual(\"\\U00010203\".encode(self.encoding),\n@@ -568,8 +579,19 @@ def test_partial(self):\n         )\n \n     def test_errors(self):\n-        self.assertRaises(UnicodeDecodeError, codecs.utf_16_be_decode,\n-                          b\"\\xff\", \"strict\", True)\n+        tests = [\n+            (b'\\xff', '\\ufffd'),\n+            (b'\\x00A\\xff', 'A\\ufffd'),\n+            (b'\\x00A\\x00B\\x00C\\x00DZ', 'ABCD\\ufffd'),\n+            (b'\\xd8\\x00', '\\ufffd'),\n+            (b'\\xd8\\x00\\xdc', '\\ufffd'),\n+            (b'\\xd8\\x00\\x00A', '\\ufffdA'),\n+            (b'\\xdc\\x00\\x00A', '\\ufffdA'),\n+        ]\n+        for raw, expected in tests:\n+            self.assertRaises(UnicodeDecodeError, codecs.utf_16_be_decode,\n+                              raw, 'strict', True)\n+            self.assertEqual(raw.decode('utf-16be', 'replace'), expected)\n \n     def test_nonbmp(self):\n         self.assertEqual(\"\\U00010203\".encode(self.encoding),\n",
    "commit_message": "Issue #14579: Fix CVE-2012-2135: vulnerability in the utf-16 decoder after error handling.\nPatch by Serhiy Storchaka.\n\n",
    "code_before": "from test import support\nimport unittest\nimport codecs\nimport locale\nimport sys, _testcapi, io\n\nclass Queue(object):\n    \"\"\"\n    queue: write bytes at one end, read bytes from the other end\n    \"\"\"\n    def __init__(self, buffer):\n        self._buffer = buffer\n\n    def write(self, chars):\n        self._buffer += chars\n\n    def read(self, size=-1):\n        if size<0:\n            s = self._buffer\n            self._buffer = self._buffer[:0] # make empty\n            return s\n        else:\n            s = self._buffer[:size]\n            self._buffer = self._buffer[size:]\n            return s\n\nclass MixInCheckStateHandling:\n    def check_state_handling_decode(self, encoding, u, s):\n        for i in range(len(s)+1):\n            d = codecs.getincrementaldecoder(encoding)()\n            part1 = d.decode(s[:i])\n            state = d.getstate()\n            self.assertIsInstance(state[1], int)\n            # Check that the condition stated in the documentation for\n            # IncrementalDecoder.getstate() holds\n            if not state[1]:\n                # reset decoder to the default state without anything buffered\n                d.setstate((state[0][:0], 0))\n                # Feeding the previous input may not produce any output\n                self.assertTrue(not d.decode(state[0]))\n                # The decoder must return to the same state\n                self.assertEqual(state, d.getstate())\n            # Create a new decoder and set it to the state\n            # we extracted from the old one\n            d = codecs.getincrementaldecoder(encoding)()\n            d.setstate(state)\n            part2 = d.decode(s[i:], True)\n            self.assertEqual(u, part1+part2)\n\n    def check_state_handling_encode(self, encoding, u, s):\n        for i in range(len(u)+1):\n            d = codecs.getincrementalencoder(encoding)()\n            part1 = d.encode(u[:i])\n            state = d.getstate()\n            d = codecs.getincrementalencoder(encoding)()\n            d.setstate(state)\n            part2 = d.encode(u[i:], True)\n            self.assertEqual(s, part1+part2)\n\nclass ReadTest(unittest.TestCase, MixInCheckStateHandling):\n    def check_partial(self, input, partialresults):\n        # get a StreamReader for the encoding and feed the bytestring version\n        # of input to the reader byte by byte. Read everything available from\n        # the StreamReader and check that the results equal the appropriate\n        # entries from partialresults.\n        q = Queue(b\"\")\n        r = codecs.getreader(self.encoding)(q)\n        result = \"\"\n        for (c, partialresult) in zip(input.encode(self.encoding), partialresults):\n            q.write(bytes([c]))\n            result += r.read()\n            self.assertEqual(result, partialresult)\n        # check that there's nothing left in the buffers\n        self.assertEqual(r.read(), \"\")\n        self.assertEqual(r.bytebuffer, b\"\")\n\n        # do the check again, this time using a incremental decoder\n        d = codecs.getincrementaldecoder(self.encoding)()\n        result = \"\"\n        for (c, partialresult) in zip(input.encode(self.encoding), partialresults):\n            result += d.decode(bytes([c]))\n            self.assertEqual(result, partialresult)\n        # check that there's nothing left in the buffers\n        self.assertEqual(d.decode(b\"\", True), \"\")\n        self.assertEqual(d.buffer, b\"\")\n\n        # Check whether the reset method works properly\n        d.reset()\n        result = \"\"\n        for (c, partialresult) in zip(input.encode(self.encoding), partialresults):\n            result += d.decode(bytes([c]))\n            self.assertEqual(result, partialresult)\n        # check that there's nothing left in the buffers\n        self.assertEqual(d.decode(b\"\", True), \"\")\n        self.assertEqual(d.buffer, b\"\")\n\n        # check iterdecode()\n        encoded = input.encode(self.encoding)\n        self.assertEqual(\n            input,\n            \"\".join(codecs.iterdecode([bytes([c]) for c in encoded], self.encoding))\n        )\n\n    def test_readline(self):\n        def getreader(input):\n            stream = io.BytesIO(input.encode(self.encoding))\n            return codecs.getreader(self.encoding)(stream)\n\n        def readalllines(input, keepends=True, size=None):\n            reader = getreader(input)\n            lines = []\n            while True:\n                line = reader.readline(size=size, keepends=keepends)\n                if not line:\n                    break\n                lines.append(line)\n            return \"|\".join(lines)\n\n        s = \"foo\\nbar\\r\\nbaz\\rspam\\u2028eggs\"\n        sexpected = \"foo\\n|bar\\r\\n|baz\\r|spam\\u2028|eggs\"\n        sexpectednoends = \"foo|bar|baz|spam|eggs\"\n        self.assertEqual(readalllines(s, True), sexpected)\n        self.assertEqual(readalllines(s, False), sexpectednoends)\n        self.assertEqual(readalllines(s, True, 10), sexpected)\n        self.assertEqual(readalllines(s, False, 10), sexpectednoends)\n\n        # Test long lines (multiple calls to read() in readline())\n        vw = []\n        vwo = []\n        for (i, lineend) in enumerate(\"\\n \\r\\n \\r \\u2028\".split()):\n            vw.append((i*200)*\"\\3042\" + lineend)\n            vwo.append((i*200)*\"\\3042\")\n        self.assertEqual(readalllines(\"\".join(vw), True), \"\".join(vw))\n        self.assertEqual(readalllines(\"\".join(vw), False),\"\".join(vwo))\n\n        # Test lines where the first read might end with \\r, so the\n        # reader has to look ahead whether this is a lone \\r or a \\r\\n\n        for size in range(80):\n            for lineend in \"\\n \\r\\n \\r \\u2028\".split():\n                s = 10*(size*\"a\" + lineend + \"xxx\\n\")\n                reader = getreader(s)\n                for i in range(10):\n                    self.assertEqual(\n                        reader.readline(keepends=True),\n                        size*\"a\" + lineend,\n                    )\n                reader = getreader(s)\n                for i in range(10):\n                    self.assertEqual(\n                        reader.readline(keepends=False),\n                        size*\"a\",\n                    )\n\n    def test_bug1175396(self):\n        s = [\n            '<%!--===================================================\\r\\n',\n            '    BLOG index page: show recent articles,\\r\\n',\n            '    today\\'s articles, or articles of a specific date.\\r\\n',\n            '========================================================--%>\\r\\n',\n            '<%@inputencoding=\"ISO-8859-1\"%>\\r\\n',\n            '<%@pagetemplate=TEMPLATE.y%>\\r\\n',\n            '<%@import=import frog.util, frog%>\\r\\n',\n            '<%@import=import frog.objects%>\\r\\n',\n            '<%@import=from frog.storageerrors import StorageError%>\\r\\n',\n            '<%\\r\\n',\n            '\\r\\n',\n            'import logging\\r\\n',\n            'log=logging.getLogger(\"Snakelets.logger\")\\r\\n',\n            '\\r\\n',\n            '\\r\\n',\n            'user=self.SessionCtx.user\\r\\n',\n            'storageEngine=self.SessionCtx.storageEngine\\r\\n',\n            '\\r\\n',\n            '\\r\\n',\n            'def readArticlesFromDate(date, count=None):\\r\\n',\n            '    entryids=storageEngine.listBlogEntries(date)\\r\\n',\n            '    entryids.reverse() # descending\\r\\n',\n            '    if count:\\r\\n',\n            '        entryids=entryids[:count]\\r\\n',\n            '    try:\\r\\n',\n            '        return [ frog.objects.BlogEntry.load(storageEngine, date, Id) for Id in entryids ]\\r\\n',\n            '    except StorageError,x:\\r\\n',\n            '        log.error(\"Error loading articles: \"+str(x))\\r\\n',\n            '        self.abort(\"cannot load articles\")\\r\\n',\n            '\\r\\n',\n            'showdate=None\\r\\n',\n            '\\r\\n',\n            'arg=self.Request.getArg()\\r\\n',\n            'if arg==\"today\":\\r\\n',\n            '    #-------------------- TODAY\\'S ARTICLES\\r\\n',\n            '    self.write(\"<h2>Today\\'s articles</h2>\")\\r\\n',\n            '    showdate = frog.util.isodatestr() \\r\\n',\n            '    entries = readArticlesFromDate(showdate)\\r\\n',\n            'elif arg==\"active\":\\r\\n',\n            '    #-------------------- ACTIVE ARTICLES redirect\\r\\n',\n            '    self.Yredirect(\"active.y\")\\r\\n',\n            'elif arg==\"login\":\\r\\n',\n            '    #-------------------- LOGIN PAGE redirect\\r\\n',\n            '    self.Yredirect(\"login.y\")\\r\\n',\n            'elif arg==\"date\":\\r\\n',\n            '    #-------------------- ARTICLES OF A SPECIFIC DATE\\r\\n',\n            '    showdate = self.Request.getParameter(\"date\")\\r\\n',\n            '    self.write(\"<h2>Articles written on %s</h2>\"% frog.util.mediumdatestr(showdate))\\r\\n',\n            '    entries = readArticlesFromDate(showdate)\\r\\n',\n            'else:\\r\\n',\n            '    #-------------------- RECENT ARTICLES\\r\\n',\n            '    self.write(\"<h2>Recent articles</h2>\")\\r\\n',\n            '    dates=storageEngine.listBlogEntryDates()\\r\\n',\n            '    if dates:\\r\\n',\n            '        entries=[]\\r\\n',\n            '        SHOWAMOUNT=10\\r\\n',\n            '        for showdate in dates:\\r\\n',\n            '            entries.extend( readArticlesFromDate(showdate, SHOWAMOUNT-len(entries)) )\\r\\n',\n            '            if len(entries)>=SHOWAMOUNT:\\r\\n',\n            '                break\\r\\n',\n            '                \\r\\n',\n        ]\n        stream = io.BytesIO(\"\".join(s).encode(self.encoding))\n        reader = codecs.getreader(self.encoding)(stream)\n        for (i, line) in enumerate(reader):\n            self.assertEqual(line, s[i])\n\n    def test_readlinequeue(self):\n        q = Queue(b\"\")\n        writer = codecs.getwriter(self.encoding)(q)\n        reader = codecs.getreader(self.encoding)(q)\n\n        # No lineends\n        writer.write(\"foo\\r\")\n        self.assertEqual(reader.readline(keepends=False), \"foo\")\n        writer.write(\"\\nbar\\r\")\n        self.assertEqual(reader.readline(keepends=False), \"\")\n        self.assertEqual(reader.readline(keepends=False), \"bar\")\n        writer.write(\"baz\")\n        self.assertEqual(reader.readline(keepends=False), \"baz\")\n        self.assertEqual(reader.readline(keepends=False), \"\")\n\n        # Lineends\n        writer.write(\"foo\\r\")\n        self.assertEqual(reader.readline(keepends=True), \"foo\\r\")\n        writer.write(\"\\nbar\\r\")\n        self.assertEqual(reader.readline(keepends=True), \"\\n\")\n        self.assertEqual(reader.readline(keepends=True), \"bar\\r\")\n        writer.write(\"baz\")\n        self.assertEqual(reader.readline(keepends=True), \"baz\")\n        self.assertEqual(reader.readline(keepends=True), \"\")\n        writer.write(\"foo\\r\\n\")\n        self.assertEqual(reader.readline(keepends=True), \"foo\\r\\n\")\n\n    def test_bug1098990_a(self):\n        s1 = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\\r\\n\"\n        s2 = \"offending line: ladfj askldfj klasdj fskla dfzaskdj fasklfj laskd fjasklfzzzzaa%whereisthis!!!\\r\\n\"\n        s3 = \"next line.\\r\\n\"\n\n        s = (s1+s2+s3).encode(self.encoding)\n        stream = io.BytesIO(s)\n        reader = codecs.getreader(self.encoding)(stream)\n        self.assertEqual(reader.readline(), s1)\n        self.assertEqual(reader.readline(), s2)\n        self.assertEqual(reader.readline(), s3)\n        self.assertEqual(reader.readline(), \"\")\n\n    def test_bug1098990_b(self):\n        s1 = \"aaaaaaaaaaaaaaaaaaaaaaaa\\r\\n\"\n        s2 = \"bbbbbbbbbbbbbbbbbbbbbbbb\\r\\n\"\n        s3 = \"stillokay:bbbbxx\\r\\n\"\n        s4 = \"broken!!!!badbad\\r\\n\"\n        s5 = \"againokay.\\r\\n\"\n\n        s = (s1+s2+s3+s4+s5).encode(self.encoding)\n        stream = io.BytesIO(s)\n        reader = codecs.getreader(self.encoding)(stream)\n        self.assertEqual(reader.readline(), s1)\n        self.assertEqual(reader.readline(), s2)\n        self.assertEqual(reader.readline(), s3)\n        self.assertEqual(reader.readline(), s4)\n        self.assertEqual(reader.readline(), s5)\n        self.assertEqual(reader.readline(), \"\")\n\nclass UTF32Test(ReadTest):\n    encoding = \"utf-32\"\n\n    spamle = (b'\\xff\\xfe\\x00\\x00'\n              b's\\x00\\x00\\x00p\\x00\\x00\\x00a\\x00\\x00\\x00m\\x00\\x00\\x00'\n              b's\\x00\\x00\\x00p\\x00\\x00\\x00a\\x00\\x00\\x00m\\x00\\x00\\x00')\n    spambe = (b'\\x00\\x00\\xfe\\xff'\n              b'\\x00\\x00\\x00s\\x00\\x00\\x00p\\x00\\x00\\x00a\\x00\\x00\\x00m'\n              b'\\x00\\x00\\x00s\\x00\\x00\\x00p\\x00\\x00\\x00a\\x00\\x00\\x00m')\n\n    def test_only_one_bom(self):\n        _,_,reader,writer = codecs.lookup(self.encoding)\n        # encode some stream\n        s = io.BytesIO()\n        f = writer(s)\n        f.write(\"spam\")\n        f.write(\"spam\")\n        d = s.getvalue()\n        # check whether there is exactly one BOM in it\n        self.assertTrue(d == self.spamle or d == self.spambe)\n        # try to read it back\n        s = io.BytesIO(d)\n        f = reader(s)\n        self.assertEqual(f.read(), \"spamspam\")\n\n    def test_badbom(self):\n        s = io.BytesIO(4*b\"\\xff\")\n        f = codecs.getreader(self.encoding)(s)\n        self.assertRaises(UnicodeError, f.read)\n\n        s = io.BytesIO(8*b\"\\xff\")\n        f = codecs.getreader(self.encoding)(s)\n        self.assertRaises(UnicodeError, f.read)\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\", # first byte of BOM read\n                \"\", # second byte of BOM read\n                \"\", # third byte of BOM read\n                \"\", # fourth byte of BOM read => byteorder known\n                \"\",\n                \"\",\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_handlers(self):\n        self.assertEqual(('\\ufffd', 1),\n                         codecs.utf_32_decode(b'\\x01', 'replace', True))\n        self.assertEqual(('', 1),\n                         codecs.utf_32_decode(b'\\x01', 'ignore', True))\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_32_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_decoder_state(self):\n        self.check_state_handling_decode(self.encoding,\n                                         \"spamspam\", self.spamle)\n        self.check_state_handling_decode(self.encoding,\n                                         \"spamspam\", self.spambe)\n\n    def test_issue8941(self):\n        # Issue #8941: insufficient result allocation when decoding into\n        # surrogate pairs on UCS-2 builds.\n        encoded_le = b'\\xff\\xfe\\x00\\x00' + b'\\x00\\x00\\x01\\x00' * 1024\n        self.assertEqual('\\U00010000' * 1024,\n                         codecs.utf_32_decode(encoded_le)[0])\n        encoded_be = b'\\x00\\x00\\xfe\\xff' + b'\\x00\\x01\\x00\\x00' * 1024\n        self.assertEqual('\\U00010000' * 1024,\n                         codecs.utf_32_decode(encoded_be)[0])\n\nclass UTF32LETest(ReadTest):\n    encoding = \"utf-32-le\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\",\n                \"\",\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_simple(self):\n        self.assertEqual(\"\\U00010203\".encode(self.encoding), b\"\\x03\\x02\\x01\\x00\")\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_32_le_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_issue8941(self):\n        # Issue #8941: insufficient result allocation when decoding into\n        # surrogate pairs on UCS-2 builds.\n        encoded = b'\\x00\\x00\\x01\\x00' * 1024\n        self.assertEqual('\\U00010000' * 1024,\n                         codecs.utf_32_le_decode(encoded)[0])\n\nclass UTF32BETest(ReadTest):\n    encoding = \"utf-32-be\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\",\n                \"\",\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_simple(self):\n        self.assertEqual(\"\\U00010203\".encode(self.encoding), b\"\\x00\\x01\\x02\\x03\")\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_32_be_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_issue8941(self):\n        # Issue #8941: insufficient result allocation when decoding into\n        # surrogate pairs on UCS-2 builds.\n        encoded = b'\\x00\\x01\\x00\\x00' * 1024\n        self.assertEqual('\\U00010000' * 1024,\n                         codecs.utf_32_be_decode(encoded)[0])\n\n\nclass UTF16Test(ReadTest):\n    encoding = \"utf-16\"\n\n    spamle = b'\\xff\\xfes\\x00p\\x00a\\x00m\\x00s\\x00p\\x00a\\x00m\\x00'\n    spambe = b'\\xfe\\xff\\x00s\\x00p\\x00a\\x00m\\x00s\\x00p\\x00a\\x00m'\n\n    def test_only_one_bom(self):\n        _,_,reader,writer = codecs.lookup(self.encoding)\n        # encode some stream\n        s = io.BytesIO()\n        f = writer(s)\n        f.write(\"spam\")\n        f.write(\"spam\")\n        d = s.getvalue()\n        # check whether there is exactly one BOM in it\n        self.assertTrue(d == self.spamle or d == self.spambe)\n        # try to read it back\n        s = io.BytesIO(d)\n        f = reader(s)\n        self.assertEqual(f.read(), \"spamspam\")\n\n    def test_badbom(self):\n        s = io.BytesIO(b\"\\xff\\xff\")\n        f = codecs.getreader(self.encoding)(s)\n        self.assertRaises(UnicodeError, f.read)\n\n        s = io.BytesIO(b\"\\xff\\xff\\xff\\xff\")\n        f = codecs.getreader(self.encoding)(s)\n        self.assertRaises(UnicodeError, f.read)\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\", # first byte of BOM read\n                \"\", # second byte of BOM read => byteorder known\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_handlers(self):\n        self.assertEqual(('\\ufffd', 1),\n                         codecs.utf_16_decode(b'\\x01', 'replace', True))\n        self.assertEqual(('', 1),\n                         codecs.utf_16_decode(b'\\x01', 'ignore', True))\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_16_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_decoder_state(self):\n        self.check_state_handling_decode(self.encoding,\n                                         \"spamspam\", self.spamle)\n        self.check_state_handling_decode(self.encoding,\n                                         \"spamspam\", self.spambe)\n\n    def test_bug691291(self):\n        # Files are always opened in binary mode, even if no binary mode was\n        # specified.  This means that no automatic conversion of '\\n' is done\n        # on reading and writing.\n        s1 = 'Hello\\r\\nworld\\r\\n'\n\n        s = s1.encode(self.encoding)\n        self.addCleanup(support.unlink, support.TESTFN)\n        with open(support.TESTFN, 'wb') as fp:\n            fp.write(s)\n        with codecs.open(support.TESTFN, 'U', encoding=self.encoding) as reader:\n            self.assertEqual(reader.read(), s1)\n\nclass UTF16LETest(ReadTest):\n    encoding = \"utf-16-le\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_16_le_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_nonbmp(self):\n        self.assertEqual(\"\\U00010203\".encode(self.encoding),\n                         b'\\x00\\xd8\\x03\\xde')\n        self.assertEqual(b'\\x00\\xd8\\x03\\xde'.decode(self.encoding),\n                         \"\\U00010203\")\n\nclass UTF16BETest(ReadTest):\n    encoding = \"utf-16-be\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_16_be_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_nonbmp(self):\n        self.assertEqual(\"\\U00010203\".encode(self.encoding),\n                         b'\\xd8\\x00\\xde\\x03')\n        self.assertEqual(b'\\xd8\\x00\\xde\\x03'.decode(self.encoding),\n                         \"\\U00010203\")\n\nclass UTF8Test(ReadTest):\n    encoding = \"utf-8\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u07ff\\u0800\\uffff\",\n            [\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u07ff\",\n                \"\\x00\\xff\\u07ff\",\n                \"\\x00\\xff\\u07ff\",\n                \"\\x00\\xff\\u07ff\\u0800\",\n                \"\\x00\\xff\\u07ff\\u0800\",\n                \"\\x00\\xff\\u07ff\\u0800\",\n                \"\\x00\\xff\\u07ff\\u0800\\uffff\",\n            ]\n        )\n\n    def test_decoder_state(self):\n        u = \"\\x00\\x7f\\x80\\xff\\u0100\\u07ff\\u0800\\uffff\\U0010ffff\"\n        self.check_state_handling_decode(self.encoding,\n                                         u, u.encode(self.encoding))\n\n    def test_lone_surrogates(self):\n        self.assertRaises(UnicodeEncodeError, \"\\ud800\".encode, \"utf-8\")\n        self.assertRaises(UnicodeDecodeError, b\"\\xed\\xa0\\x80\".decode, \"utf-8\")\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"backslashreplace\"),\n                         b'[\\\\udc80]')\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"xmlcharrefreplace\"),\n                         b'[&#56448;]')\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"surrogateescape\"),\n                         b'[\\x80]')\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"ignore\"),\n                         b'[]')\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"replace\"),\n                         b'[?]')\n\n    def test_surrogatepass_handler(self):\n        self.assertEqual(\"abc\\ud800def\".encode(\"utf-8\", \"surrogatepass\"),\n                         b\"abc\\xed\\xa0\\x80def\")\n        self.assertEqual(b\"abc\\xed\\xa0\\x80def\".decode(\"utf-8\", \"surrogatepass\"),\n                         \"abc\\ud800def\")\n        self.assertTrue(codecs.lookup_error(\"surrogatepass\"))\n\nclass UTF7Test(ReadTest):\n    encoding = \"utf-7\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"a+-b\",\n            [\n                \"a\",\n                \"a\",\n                \"a+\",\n                \"a+-\",\n                \"a+-b\",\n            ]\n        )\n\nclass UTF16ExTest(unittest.TestCase):\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_16_ex_decode, b\"\\xff\", \"strict\", 0, True)\n\n    def test_bad_args(self):\n        self.assertRaises(TypeError, codecs.utf_16_ex_decode)\n\nclass ReadBufferTest(unittest.TestCase):\n\n    def test_array(self):\n        import array\n        self.assertEqual(\n            codecs.readbuffer_encode(array.array(\"b\", b\"spam\")),\n            (b\"spam\", 4)\n        )\n\n    def test_empty(self):\n        self.assertEqual(codecs.readbuffer_encode(\"\"), (b\"\", 0))\n\n    def test_bad_args(self):\n        self.assertRaises(TypeError, codecs.readbuffer_encode)\n        self.assertRaises(TypeError, codecs.readbuffer_encode, 42)\n\nclass UTF8SigTest(ReadTest):\n    encoding = \"utf-8-sig\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\ufeff\\x00\\xff\\u07ff\\u0800\\uffff\",\n            [\n                \"\",\n                \"\",\n                \"\", # First BOM has been read and skipped\n                \"\",\n                \"\",\n                \"\\ufeff\", # Second BOM has been read and emitted\n                \"\\ufeff\\x00\", # \"\\x00\" read and emitted\n                \"\\ufeff\\x00\", # First byte of encoded \"\\xff\" read\n                \"\\ufeff\\x00\\xff\", # Second byte of encoded \"\\xff\" read\n                \"\\ufeff\\x00\\xff\", # First byte of encoded \"\\u07ff\" read\n                \"\\ufeff\\x00\\xff\\u07ff\", # Second byte of encoded \"\\u07ff\" read\n                \"\\ufeff\\x00\\xff\\u07ff\",\n                \"\\ufeff\\x00\\xff\\u07ff\",\n                \"\\ufeff\\x00\\xff\\u07ff\\u0800\",\n                \"\\ufeff\\x00\\xff\\u07ff\\u0800\",\n                \"\\ufeff\\x00\\xff\\u07ff\\u0800\",\n                \"\\ufeff\\x00\\xff\\u07ff\\u0800\\uffff\",\n            ]\n        )\n\n    def test_bug1601501(self):\n        # SF bug #1601501: check that the codec works with a buffer\n        self.assertEqual(str(b\"\\xef\\xbb\\xbf\", \"utf-8-sig\"), \"\")\n\n    def test_bom(self):\n        d = codecs.getincrementaldecoder(\"utf-8-sig\")()\n        s = \"spam\"\n        self.assertEqual(d.decode(s.encode(\"utf-8-sig\")), s)\n\n    def test_stream_bom(self):\n        unistring = \"ABC\\u00A1\\u2200XYZ\"\n        bytestring = codecs.BOM_UTF8 + b\"ABC\\xC2\\xA1\\xE2\\x88\\x80XYZ\"\n\n        reader = codecs.getreader(\"utf-8-sig\")\n        for sizehint in [None] + list(range(1, 11)) + \\\n                        [64, 128, 256, 512, 1024]:\n            istream = reader(io.BytesIO(bytestring))\n            ostream = io.StringIO()\n            while 1:\n                if sizehint is not None:\n                    data = istream.read(sizehint)\n                else:\n                    data = istream.read()\n\n                if not data:\n                    break\n                ostream.write(data)\n\n            got = ostream.getvalue()\n            self.assertEqual(got, unistring)\n\n    def test_stream_bare(self):\n        unistring = \"ABC\\u00A1\\u2200XYZ\"\n        bytestring = b\"ABC\\xC2\\xA1\\xE2\\x88\\x80XYZ\"\n\n        reader = codecs.getreader(\"utf-8-sig\")\n        for sizehint in [None] + list(range(1, 11)) + \\\n                        [64, 128, 256, 512, 1024]:\n            istream = reader(io.BytesIO(bytestring))\n            ostream = io.StringIO()\n            while 1:\n                if sizehint is not None:\n                    data = istream.read(sizehint)\n                else:\n                    data = istream.read()\n\n                if not data:\n                    break\n                ostream.write(data)\n\n            got = ostream.getvalue()\n            self.assertEqual(got, unistring)\n\nclass EscapeDecodeTest(unittest.TestCase):\n    def test_empty(self):\n        self.assertEqual(codecs.escape_decode(\"\"), (\"\", 0))\n\nclass RecodingTest(unittest.TestCase):\n    def test_recoding(self):\n        f = io.BytesIO()\n        f2 = codecs.EncodedFile(f, \"unicode_internal\", \"utf-8\")\n        f2.write(\"a\")\n        f2.close()\n        # Python used to crash on this at exit because of a refcount\n        # bug in _codecsmodule.c\n\n# From RFC 3492\npunycode_testcases = [\n    # A Arabic (Egyptian):\n    (\"\\u0644\\u064A\\u0647\\u0645\\u0627\\u0628\\u062A\\u0643\\u0644\"\n     \"\\u0645\\u0648\\u0634\\u0639\\u0631\\u0628\\u064A\\u061F\",\n     b\"egbpdaj6bu4bxfgehfvwxn\"),\n    # B Chinese (simplified):\n    (\"\\u4ED6\\u4EEC\\u4E3A\\u4EC0\\u4E48\\u4E0D\\u8BF4\\u4E2D\\u6587\",\n     b\"ihqwcrb4cv8a8dqg056pqjye\"),\n    # C Chinese (traditional):\n    (\"\\u4ED6\\u5011\\u7232\\u4EC0\\u9EBD\\u4E0D\\u8AAA\\u4E2D\\u6587\",\n     b\"ihqwctvzc91f659drss3x8bo0yb\"),\n    # D Czech: Pro<ccaron>prost<ecaron>nemluv<iacute><ccaron>esky\n    (\"\\u0050\\u0072\\u006F\\u010D\\u0070\\u0072\\u006F\\u0073\\u0074\"\n     \"\\u011B\\u006E\\u0065\\u006D\\u006C\\u0075\\u0076\\u00ED\\u010D\"\n     \"\\u0065\\u0073\\u006B\\u0079\",\n     b\"Proprostnemluvesky-uyb24dma41a\"),\n    # E Hebrew:\n    (\"\\u05DC\\u05DE\\u05D4\\u05D4\\u05DD\\u05E4\\u05E9\\u05D5\\u05D8\"\n     \"\\u05DC\\u05D0\\u05DE\\u05D3\\u05D1\\u05E8\\u05D9\\u05DD\\u05E2\"\n     \"\\u05D1\\u05E8\\u05D9\\u05EA\",\n     b\"4dbcagdahymbxekheh6e0a7fei0b\"),\n    # F Hindi (Devanagari):\n    (\"\\u092F\\u0939\\u0932\\u094B\\u0917\\u0939\\u093F\\u0928\\u094D\"\n     \"\\u0926\\u0940\\u0915\\u094D\\u092F\\u094B\\u0902\\u0928\\u0939\"\n     \"\\u0940\\u0902\\u092C\\u094B\\u0932\\u0938\\u0915\\u0924\\u0947\"\n     \"\\u0939\\u0948\\u0902\",\n     b\"i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd\"),\n\n    #(G) Japanese (kanji and hiragana):\n    (\"\\u306A\\u305C\\u307F\\u3093\\u306A\\u65E5\\u672C\\u8A9E\\u3092\"\n     \"\\u8A71\\u3057\\u3066\\u304F\\u308C\\u306A\\u3044\\u306E\\u304B\",\n     b\"n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa\"),\n\n    # (H) Korean (Hangul syllables):\n    (\"\\uC138\\uACC4\\uC758\\uBAA8\\uB4E0\\uC0AC\\uB78C\\uB4E4\\uC774\"\n     \"\\uD55C\\uAD6D\\uC5B4\\uB97C\\uC774\\uD574\\uD55C\\uB2E4\\uBA74\"\n     \"\\uC5BC\\uB9C8\\uB098\\uC88B\\uC744\\uAE4C\",\n     b\"989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j\"\n     b\"psd879ccm6fea98c\"),\n\n    # (I) Russian (Cyrillic):\n    (\"\\u043F\\u043E\\u0447\\u0435\\u043C\\u0443\\u0436\\u0435\\u043E\"\n     \"\\u043D\\u0438\\u043D\\u0435\\u0433\\u043E\\u0432\\u043E\\u0440\"\n     \"\\u044F\\u0442\\u043F\\u043E\\u0440\\u0443\\u0441\\u0441\\u043A\"\n     \"\\u0438\",\n     b\"b1abfaaepdrnnbgefbaDotcwatmq2g4l\"),\n\n    # (J) Spanish: Porqu<eacute>nopuedensimplementehablarenEspa<ntilde>ol\n    (\"\\u0050\\u006F\\u0072\\u0071\\u0075\\u00E9\\u006E\\u006F\\u0070\"\n     \"\\u0075\\u0065\\u0064\\u0065\\u006E\\u0073\\u0069\\u006D\\u0070\"\n     \"\\u006C\\u0065\\u006D\\u0065\\u006E\\u0074\\u0065\\u0068\\u0061\"\n     \"\\u0062\\u006C\\u0061\\u0072\\u0065\\u006E\\u0045\\u0073\\u0070\"\n     \"\\u0061\\u00F1\\u006F\\u006C\",\n     b\"PorqunopuedensimplementehablarenEspaol-fmd56a\"),\n\n    # (K) Vietnamese:\n    #  T<adotbelow>isaoh<odotbelow>kh<ocirc>ngth<ecirchookabove>ch\\\n    #   <ihookabove>n<oacute>iti<ecircacute>ngVi<ecircdotbelow>t\n    (\"\\u0054\\u1EA1\\u0069\\u0073\\u0061\\u006F\\u0068\\u1ECD\\u006B\"\n     \"\\u0068\\u00F4\\u006E\\u0067\\u0074\\u0068\\u1EC3\\u0063\\u0068\"\n     \"\\u1EC9\\u006E\\u00F3\\u0069\\u0074\\u0069\\u1EBF\\u006E\\u0067\"\n     \"\\u0056\\u0069\\u1EC7\\u0074\",\n     b\"TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g\"),\n\n    #(L) 3<nen>B<gumi><kinpachi><sensei>\n    (\"\\u0033\\u5E74\\u0042\\u7D44\\u91D1\\u516B\\u5148\\u751F\",\n     b\"3B-ww4c5e180e575a65lsy2b\"),\n\n    # (M) <amuro><namie>-with-SUPER-MONKEYS\n    (\"\\u5B89\\u5BA4\\u5948\\u7F8E\\u6075\\u002D\\u0077\\u0069\\u0074\"\n     \"\\u0068\\u002D\\u0053\\u0055\\u0050\\u0045\\u0052\\u002D\\u004D\"\n     \"\\u004F\\u004E\\u004B\\u0045\\u0059\\u0053\",\n     b\"-with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n\"),\n\n    # (N) Hello-Another-Way-<sorezore><no><basho>\n    (\"\\u0048\\u0065\\u006C\\u006C\\u006F\\u002D\\u0041\\u006E\\u006F\"\n     \"\\u0074\\u0068\\u0065\\u0072\\u002D\\u0057\\u0061\\u0079\\u002D\"\n     \"\\u305D\\u308C\\u305E\\u308C\\u306E\\u5834\\u6240\",\n     b\"Hello-Another-Way--fc4qua05auwb3674vfr0b\"),\n\n    # (O) <hitotsu><yane><no><shita>2\n    (\"\\u3072\\u3068\\u3064\\u5C4B\\u6839\\u306E\\u4E0B\\u0032\",\n     b\"2-u9tlzr9756bt3uc0v\"),\n\n    # (P) Maji<de>Koi<suru>5<byou><mae>\n    (\"\\u004D\\u0061\\u006A\\u0069\\u3067\\u004B\\u006F\\u0069\\u3059\"\n     \"\\u308B\\u0035\\u79D2\\u524D\",\n     b\"MajiKoi5-783gue6qz075azm5e\"),\n\n     # (Q) <pafii>de<runba>\n    (\"\\u30D1\\u30D5\\u30A3\\u30FC\\u0064\\u0065\\u30EB\\u30F3\\u30D0\",\n     b\"de-jg4avhby1noc0d\"),\n\n    # (R) <sono><supiido><de>\n    (\"\\u305D\\u306E\\u30B9\\u30D4\\u30FC\\u30C9\\u3067\",\n     b\"d9juau41awczczp\"),\n\n    # (S) -> $1.00 <-\n    (\"\\u002D\\u003E\\u0020\\u0024\\u0031\\u002E\\u0030\\u0030\\u0020\"\n     \"\\u003C\\u002D\",\n     b\"-> $1.00 <--\")\n    ]\n\nfor i in punycode_testcases:\n    if len(i)!=2:\n        print(repr(i))\n\nclass PunycodeTest(unittest.TestCase):\n    def test_encode(self):\n        for uni, puny in punycode_testcases:\n            # Need to convert both strings to lower case, since\n            # some of the extended encodings use upper case, but our\n            # code produces only lower case. Converting just puny to\n            # lower is also insufficient, since some of the input characters\n            # are upper case.\n            self.assertEqual(\n                str(uni.encode(\"punycode\"), \"ascii\").lower(),\n                str(puny, \"ascii\").lower()\n            )\n\n    def test_decode(self):\n        for uni, puny in punycode_testcases:\n            self.assertEqual(uni, puny.decode(\"punycode\"))\n            puny = puny.decode(\"ascii\").encode(\"ascii\")\n            self.assertEqual(uni, puny.decode(\"punycode\"))\n\nclass UnicodeInternalTest(unittest.TestCase):\n    def test_bug1251300(self):\n        # Decoding with unicode_internal used to not correctly handle \"code\n        # points\" above 0x10ffff on UCS-4 builds.\n        if sys.maxunicode > 0xffff:\n            ok = [\n                (b\"\\x00\\x10\\xff\\xff\", \"\\U0010ffff\"),\n                (b\"\\x00\\x00\\x01\\x01\", \"\\U00000101\"),\n                (b\"\", \"\"),\n            ]\n            not_ok = [\n                b\"\\x7f\\xff\\xff\\xff\",\n                b\"\\x80\\x00\\x00\\x00\",\n                b\"\\x81\\x00\\x00\\x00\",\n                b\"\\x00\",\n                b\"\\x00\\x00\\x00\\x00\\x00\",\n            ]\n            for internal, uni in ok:\n                if sys.byteorder == \"little\":\n                    internal = bytes(reversed(internal))\n                self.assertEqual(uni, internal.decode(\"unicode_internal\"))\n            for internal in not_ok:\n                if sys.byteorder == \"little\":\n                    internal = bytes(reversed(internal))\n                self.assertRaises(UnicodeDecodeError, internal.decode,\n                    \"unicode_internal\")\n\n    def test_decode_error_attributes(self):\n        if sys.maxunicode > 0xffff:\n            try:\n                b\"\\x00\\x00\\x00\\x00\\x00\\x11\\x11\\x00\".decode(\"unicode_internal\")\n            except UnicodeDecodeError as ex:\n                self.assertEqual(\"unicode_internal\", ex.encoding)\n                self.assertEqual(b\"\\x00\\x00\\x00\\x00\\x00\\x11\\x11\\x00\", ex.object)\n                self.assertEqual(4, ex.start)\n                self.assertEqual(8, ex.end)\n            else:\n                self.fail()\n\n    def test_decode_callback(self):\n        if sys.maxunicode > 0xffff:\n            codecs.register_error(\"UnicodeInternalTest\", codecs.ignore_errors)\n            decoder = codecs.getdecoder(\"unicode_internal\")\n            ab = \"ab\".encode(\"unicode_internal\").decode()\n            ignored = decoder(bytes(\"%s\\x22\\x22\\x22\\x22%s\" % (ab[:4], ab[4:]),\n                                    \"ascii\"),\n                              \"UnicodeInternalTest\")\n            self.assertEqual((\"ab\", 12), ignored)\n\n    def test_encode_length(self):\n        # Issue 3739\n        encoder = codecs.getencoder(\"unicode_internal\")\n        self.assertEqual(encoder(\"a\")[1], 1)\n        self.assertEqual(encoder(\"\\xe9\\u0142\")[1], 2)\n\n        self.assertEqual(codecs.escape_encode(br'\\x00')[1], 4)\n\n# From http://www.gnu.org/software/libidn/draft-josefsson-idn-test-vectors.html\nnameprep_tests = [\n    # 3.1 Map to nothing.\n    (b'foo\\xc2\\xad\\xcd\\x8f\\xe1\\xa0\\x86\\xe1\\xa0\\x8bbar'\n     b'\\xe2\\x80\\x8b\\xe2\\x81\\xa0baz\\xef\\xb8\\x80\\xef\\xb8\\x88\\xef'\n     b'\\xb8\\x8f\\xef\\xbb\\xbf',\n     b'foobarbaz'),\n    # 3.2 Case folding ASCII U+0043 U+0041 U+0046 U+0045.\n    (b'CAFE',\n     b'cafe'),\n    # 3.3 Case folding 8bit U+00DF (german sharp s).\n    # The original test case is bogus; it says \\xc3\\xdf\n    (b'\\xc3\\x9f',\n     b'ss'),\n    # 3.4 Case folding U+0130 (turkish capital I with dot).\n    (b'\\xc4\\xb0',\n     b'i\\xcc\\x87'),\n    # 3.5 Case folding multibyte U+0143 U+037A.\n    (b'\\xc5\\x83\\xcd\\xba',\n     b'\\xc5\\x84 \\xce\\xb9'),\n    # 3.6 Case folding U+2121 U+33C6 U+1D7BB.\n    # XXX: skip this as it fails in UCS-2 mode\n    #('\\xe2\\x84\\xa1\\xe3\\x8f\\x86\\xf0\\x9d\\x9e\\xbb',\n    # 'telc\\xe2\\x88\\x95kg\\xcf\\x83'),\n    (None, None),\n    # 3.7 Normalization of U+006a U+030c U+00A0 U+00AA.\n    (b'j\\xcc\\x8c\\xc2\\xa0\\xc2\\xaa',\n     b'\\xc7\\xb0 a'),\n    # 3.8 Case folding U+1FB7 and normalization.\n    (b'\\xe1\\xbe\\xb7',\n     b'\\xe1\\xbe\\xb6\\xce\\xb9'),\n    # 3.9 Self-reverting case folding U+01F0 and normalization.\n    # The original test case is bogus, it says `\\xc7\\xf0'\n    (b'\\xc7\\xb0',\n     b'\\xc7\\xb0'),\n    # 3.10 Self-reverting case folding U+0390 and normalization.\n    (b'\\xce\\x90',\n     b'\\xce\\x90'),\n    # 3.11 Self-reverting case folding U+03B0 and normalization.\n    (b'\\xce\\xb0',\n     b'\\xce\\xb0'),\n    # 3.12 Self-reverting case folding U+1E96 and normalization.\n    (b'\\xe1\\xba\\x96',\n     b'\\xe1\\xba\\x96'),\n    # 3.13 Self-reverting case folding U+1F56 and normalization.\n    (b'\\xe1\\xbd\\x96',\n     b'\\xe1\\xbd\\x96'),\n    # 3.14 ASCII space character U+0020.\n    (b' ',\n     b' '),\n    # 3.15 Non-ASCII 8bit space character U+00A0.\n    (b'\\xc2\\xa0',\n     b' '),\n    # 3.16 Non-ASCII multibyte space character U+1680.\n    (b'\\xe1\\x9a\\x80',\n     None),\n    # 3.17 Non-ASCII multibyte space character U+2000.\n    (b'\\xe2\\x80\\x80',\n     b' '),\n    # 3.18 Zero Width Space U+200b.\n    (b'\\xe2\\x80\\x8b',\n     b''),\n    # 3.19 Non-ASCII multibyte space character U+3000.\n    (b'\\xe3\\x80\\x80',\n     b' '),\n    # 3.20 ASCII control characters U+0010 U+007F.\n    (b'\\x10\\x7f',\n     b'\\x10\\x7f'),\n    # 3.21 Non-ASCII 8bit control character U+0085.\n    (b'\\xc2\\x85',\n     None),\n    # 3.22 Non-ASCII multibyte control character U+180E.\n    (b'\\xe1\\xa0\\x8e',\n     None),\n    # 3.23 Zero Width No-Break Space U+FEFF.\n    (b'\\xef\\xbb\\xbf',\n     b''),\n    # 3.24 Non-ASCII control character U+1D175.\n    (b'\\xf0\\x9d\\x85\\xb5',\n     None),\n    # 3.25 Plane 0 private use character U+F123.\n    (b'\\xef\\x84\\xa3',\n     None),\n    # 3.26 Plane 15 private use character U+F1234.\n    (b'\\xf3\\xb1\\x88\\xb4',\n     None),\n    # 3.27 Plane 16 private use character U+10F234.\n    (b'\\xf4\\x8f\\x88\\xb4',\n     None),\n    # 3.28 Non-character code point U+8FFFE.\n    (b'\\xf2\\x8f\\xbf\\xbe',\n     None),\n    # 3.29 Non-character code point U+10FFFF.\n    (b'\\xf4\\x8f\\xbf\\xbf',\n     None),\n    # 3.30 Surrogate code U+DF42.\n    (b'\\xed\\xbd\\x82',\n     None),\n    # 3.31 Non-plain text character U+FFFD.\n    (b'\\xef\\xbf\\xbd',\n     None),\n    # 3.32 Ideographic description character U+2FF5.\n    (b'\\xe2\\xbf\\xb5',\n     None),\n    # 3.33 Display property character U+0341.\n    (b'\\xcd\\x81',\n     b'\\xcc\\x81'),\n    # 3.34 Left-to-right mark U+200E.\n    (b'\\xe2\\x80\\x8e',\n     None),\n    # 3.35 Deprecated U+202A.\n    (b'\\xe2\\x80\\xaa',\n     None),\n    # 3.36 Language tagging character U+E0001.\n    (b'\\xf3\\xa0\\x80\\x81',\n     None),\n    # 3.37 Language tagging character U+E0042.\n    (b'\\xf3\\xa0\\x81\\x82',\n     None),\n    # 3.38 Bidi: RandALCat character U+05BE and LCat characters.\n    (b'foo\\xd6\\xbebar',\n     None),\n    # 3.39 Bidi: RandALCat character U+FD50 and LCat characters.\n    (b'foo\\xef\\xb5\\x90bar',\n     None),\n    # 3.40 Bidi: RandALCat character U+FB38 and LCat characters.\n    (b'foo\\xef\\xb9\\xb6bar',\n     b'foo \\xd9\\x8ebar'),\n    # 3.41 Bidi: RandALCat without trailing RandALCat U+0627 U+0031.\n    (b'\\xd8\\xa71',\n     None),\n    # 3.42 Bidi: RandALCat character U+0627 U+0031 U+0628.\n    (b'\\xd8\\xa71\\xd8\\xa8',\n     b'\\xd8\\xa71\\xd8\\xa8'),\n    # 3.43 Unassigned code point U+E0002.\n    # Skip this test as we allow unassigned\n    #(b'\\xf3\\xa0\\x80\\x82',\n    # None),\n    (None, None),\n    # 3.44 Larger test (shrinking).\n    # Original test case reads \\xc3\\xdf\n    (b'X\\xc2\\xad\\xc3\\x9f\\xc4\\xb0\\xe2\\x84\\xa1j\\xcc\\x8c\\xc2\\xa0\\xc2'\n     b'\\xaa\\xce\\xb0\\xe2\\x80\\x80',\n     b'xssi\\xcc\\x87tel\\xc7\\xb0 a\\xce\\xb0 '),\n    # 3.45 Larger test (expanding).\n    # Original test case reads \\xc3\\x9f\n    (b'X\\xc3\\x9f\\xe3\\x8c\\x96\\xc4\\xb0\\xe2\\x84\\xa1\\xe2\\x92\\x9f\\xe3\\x8c'\n     b'\\x80',\n     b'xss\\xe3\\x82\\xad\\xe3\\x83\\xad\\xe3\\x83\\xa1\\xe3\\x83\\xbc\\xe3'\n     b'\\x83\\x88\\xe3\\x83\\xabi\\xcc\\x87tel\\x28d\\x29\\xe3\\x82'\n     b'\\xa2\\xe3\\x83\\x91\\xe3\\x83\\xbc\\xe3\\x83\\x88')\n    ]\n\n\nclass NameprepTest(unittest.TestCase):\n    def test_nameprep(self):\n        from encodings.idna import nameprep\n        for pos, (orig, prepped) in enumerate(nameprep_tests):\n            if orig is None:\n                # Skipped\n                continue\n            # The Unicode strings are given in UTF-8\n            orig = str(orig, \"utf-8\", \"surrogatepass\")\n            if prepped is None:\n                # Input contains prohibited characters\n                self.assertRaises(UnicodeError, nameprep, orig)\n            else:\n                prepped = str(prepped, \"utf-8\", \"surrogatepass\")\n                try:\n                    self.assertEqual(nameprep(orig), prepped)\n                except Exception as e:\n                    raise support.TestFailed(\"Test 3.%d: %s\" % (pos+1, str(e)))\n\nclass IDNACodecTest(unittest.TestCase):\n    def test_builtin_decode(self):\n        self.assertEqual(str(b\"python.org\", \"idna\"), \"python.org\")\n        self.assertEqual(str(b\"python.org.\", \"idna\"), \"python.org.\")\n        self.assertEqual(str(b\"xn--pythn-mua.org\", \"idna\"), \"pyth\\xf6n.org\")\n        self.assertEqual(str(b\"xn--pythn-mua.org.\", \"idna\"), \"pyth\\xf6n.org.\")\n\n    def test_builtin_encode(self):\n        self.assertEqual(\"python.org\".encode(\"idna\"), b\"python.org\")\n        self.assertEqual(\"python.org.\".encode(\"idna\"), b\"python.org.\")\n        self.assertEqual(\"pyth\\xf6n.org\".encode(\"idna\"), b\"xn--pythn-mua.org\")\n        self.assertEqual(\"pyth\\xf6n.org.\".encode(\"idna\"), b\"xn--pythn-mua.org.\")\n\n    def test_stream(self):\n        r = codecs.getreader(\"idna\")(io.BytesIO(b\"abc\"))\n        r.read(3)\n        self.assertEqual(r.read(), \"\")\n\n    def test_incremental_decode(self):\n        self.assertEqual(\n            \"\".join(codecs.iterdecode((bytes([c]) for c in b\"python.org\"), \"idna\")),\n            \"python.org\"\n        )\n        self.assertEqual(\n            \"\".join(codecs.iterdecode((bytes([c]) for c in b\"python.org.\"), \"idna\")),\n            \"python.org.\"\n        )\n        self.assertEqual(\n            \"\".join(codecs.iterdecode((bytes([c]) for c in b\"xn--pythn-mua.org.\"), \"idna\")),\n            \"pyth\\xf6n.org.\"\n        )\n        self.assertEqual(\n            \"\".join(codecs.iterdecode((bytes([c]) for c in b\"xn--pythn-mua.org.\"), \"idna\")),\n            \"pyth\\xf6n.org.\"\n        )\n\n        decoder = codecs.getincrementaldecoder(\"idna\")()\n        self.assertEqual(decoder.decode(b\"xn--xam\", ), \"\")\n        self.assertEqual(decoder.decode(b\"ple-9ta.o\", ), \"\\xe4xample.\")\n        self.assertEqual(decoder.decode(b\"rg\"), \"\")\n        self.assertEqual(decoder.decode(b\"\", True), \"org\")\n\n        decoder.reset()\n        self.assertEqual(decoder.decode(b\"xn--xam\", ), \"\")\n        self.assertEqual(decoder.decode(b\"ple-9ta.o\", ), \"\\xe4xample.\")\n        self.assertEqual(decoder.decode(b\"rg.\"), \"org.\")\n        self.assertEqual(decoder.decode(b\"\", True), \"\")\n\n    def test_incremental_encode(self):\n        self.assertEqual(\n            b\"\".join(codecs.iterencode(\"python.org\", \"idna\")),\n            b\"python.org\"\n        )\n        self.assertEqual(\n            b\"\".join(codecs.iterencode(\"python.org.\", \"idna\")),\n            b\"python.org.\"\n        )\n        self.assertEqual(\n            b\"\".join(codecs.iterencode(\"pyth\\xf6n.org.\", \"idna\")),\n            b\"xn--pythn-mua.org.\"\n        )\n        self.assertEqual(\n            b\"\".join(codecs.iterencode(\"pyth\\xf6n.org.\", \"idna\")),\n            b\"xn--pythn-mua.org.\"\n        )\n\n        encoder = codecs.getincrementalencoder(\"idna\")()\n        self.assertEqual(encoder.encode(\"\\xe4x\"), b\"\")\n        self.assertEqual(encoder.encode(\"ample.org\"), b\"xn--xample-9ta.\")\n        self.assertEqual(encoder.encode(\"\", True), b\"org\")\n\n        encoder.reset()\n        self.assertEqual(encoder.encode(\"\\xe4x\"), b\"\")\n        self.assertEqual(encoder.encode(\"ample.org.\"), b\"xn--xample-9ta.org.\")\n        self.assertEqual(encoder.encode(\"\", True), b\"\")\n\nclass CodecsModuleTest(unittest.TestCase):\n\n    def test_decode(self):\n        self.assertEqual(codecs.decode(b'\\xe4\\xf6\\xfc', 'latin-1'),\n                         '\\xe4\\xf6\\xfc')\n        self.assertRaises(TypeError, codecs.decode)\n        self.assertEqual(codecs.decode(b'abc'), 'abc')\n        self.assertRaises(UnicodeDecodeError, codecs.decode, b'\\xff', 'ascii')\n\n    def test_encode(self):\n        self.assertEqual(codecs.encode('\\xe4\\xf6\\xfc', 'latin-1'),\n                         b'\\xe4\\xf6\\xfc')\n        self.assertRaises(TypeError, codecs.encode)\n        self.assertRaises(LookupError, codecs.encode, \"foo\", \"__spam__\")\n        self.assertEqual(codecs.encode('abc'), b'abc')\n        self.assertRaises(UnicodeEncodeError, codecs.encode, '\\xffff', 'ascii')\n\n    def test_register(self):\n        self.assertRaises(TypeError, codecs.register)\n        self.assertRaises(TypeError, codecs.register, 42)\n\n    def test_lookup(self):\n        self.assertRaises(TypeError, codecs.lookup)\n        self.assertRaises(LookupError, codecs.lookup, \"__spam__\")\n        self.assertRaises(LookupError, codecs.lookup, \" \")\n\n    def test_getencoder(self):\n        self.assertRaises(TypeError, codecs.getencoder)\n        self.assertRaises(LookupError, codecs.getencoder, \"__spam__\")\n\n    def test_getdecoder(self):\n        self.assertRaises(TypeError, codecs.getdecoder)\n        self.assertRaises(LookupError, codecs.getdecoder, \"__spam__\")\n\n    def test_getreader(self):\n        self.assertRaises(TypeError, codecs.getreader)\n        self.assertRaises(LookupError, codecs.getreader, \"__spam__\")\n\n    def test_getwriter(self):\n        self.assertRaises(TypeError, codecs.getwriter)\n        self.assertRaises(LookupError, codecs.getwriter, \"__spam__\")\n\n    def test_lookup_issue1813(self):\n        # Issue #1813: under Turkish locales, lookup of some codecs failed\n        # because 'I' is lowercased as \"\u0131\" (dotless i)\n        oldlocale = locale.setlocale(locale.LC_CTYPE)\n        self.addCleanup(locale.setlocale, locale.LC_CTYPE, oldlocale)\n        try:\n            locale.setlocale(locale.LC_CTYPE, 'tr_TR')\n        except locale.Error:\n            # Unsupported locale on this system\n            self.skipTest('test needs Turkish locale')\n        c = codecs.lookup('ASCII')\n        self.assertEqual(c.name, 'ascii')\n\nclass StreamReaderTest(unittest.TestCase):\n\n    def setUp(self):\n        self.reader = codecs.getreader('utf-8')\n        self.stream = io.BytesIO(b'\\xed\\x95\\x9c\\n\\xea\\xb8\\x80')\n\n    def test_readlines(self):\n        f = self.reader(self.stream)\n        self.assertEqual(f.readlines(), ['\\ud55c\\n', '\\uae00'])\n\nclass EncodedFileTest(unittest.TestCase):\n\n    def test_basic(self):\n        f = io.BytesIO(b'\\xed\\x95\\x9c\\n\\xea\\xb8\\x80')\n        ef = codecs.EncodedFile(f, 'utf-16-le', 'utf-8')\n        self.assertEqual(ef.read(), b'\\\\\\xd5\\n\\x00\\x00\\xae')\n\n        f = io.BytesIO()\n        ef = codecs.EncodedFile(f, 'utf-8', 'latin1')\n        ef.write(b'\\xc3\\xbc')\n        self.assertEqual(f.getvalue(), b'\\xfc')\n\nall_unicode_encodings = [\n    \"ascii\",\n    \"big5\",\n    \"big5hkscs\",\n    \"charmap\",\n    \"cp037\",\n    \"cp1006\",\n    \"cp1026\",\n    \"cp1140\",\n    \"cp1250\",\n    \"cp1251\",\n    \"cp1252\",\n    \"cp1253\",\n    \"cp1254\",\n    \"cp1255\",\n    \"cp1256\",\n    \"cp1257\",\n    \"cp1258\",\n    \"cp424\",\n    \"cp437\",\n    \"cp500\",\n    \"cp720\",\n    \"cp737\",\n    \"cp775\",\n    \"cp850\",\n    \"cp852\",\n    \"cp855\",\n    \"cp856\",\n    \"cp857\",\n    \"cp858\",\n    \"cp860\",\n    \"cp861\",\n    \"cp862\",\n    \"cp863\",\n    \"cp864\",\n    \"cp865\",\n    \"cp866\",\n    \"cp869\",\n    \"cp874\",\n    \"cp875\",\n    \"cp932\",\n    \"cp949\",\n    \"cp950\",\n    \"euc_jis_2004\",\n    \"euc_jisx0213\",\n    \"euc_jp\",\n    \"euc_kr\",\n    \"gb18030\",\n    \"gb2312\",\n    \"gbk\",\n    \"hp_roman8\",\n    \"hz\",\n    \"idna\",\n    \"iso2022_jp\",\n    \"iso2022_jp_1\",\n    \"iso2022_jp_2\",\n    \"iso2022_jp_2004\",\n    \"iso2022_jp_3\",\n    \"iso2022_jp_ext\",\n    \"iso2022_kr\",\n    \"iso8859_1\",\n    \"iso8859_10\",\n    \"iso8859_11\",\n    \"iso8859_13\",\n    \"iso8859_14\",\n    \"iso8859_15\",\n    \"iso8859_16\",\n    \"iso8859_2\",\n    \"iso8859_3\",\n    \"iso8859_4\",\n    \"iso8859_5\",\n    \"iso8859_6\",\n    \"iso8859_7\",\n    \"iso8859_8\",\n    \"iso8859_9\",\n    \"johab\",\n    \"koi8_r\",\n    \"koi8_u\",\n    \"latin_1\",\n    \"mac_cyrillic\",\n    \"mac_greek\",\n    \"mac_iceland\",\n    \"mac_latin2\",\n    \"mac_roman\",\n    \"mac_turkish\",\n    \"palmos\",\n    \"ptcp154\",\n    \"punycode\",\n    \"raw_unicode_escape\",\n    \"shift_jis\",\n    \"shift_jis_2004\",\n    \"shift_jisx0213\",\n    \"tis_620\",\n    \"unicode_escape\",\n    \"unicode_internal\",\n    \"utf_16\",\n    \"utf_16_be\",\n    \"utf_16_le\",\n    \"utf_7\",\n    \"utf_8\",\n]\n\nif hasattr(codecs, \"mbcs_encode\"):\n    all_unicode_encodings.append(\"mbcs\")\n\n# The following encoding is not tested, because it's not supposed\n# to work:\n#    \"undefined\"\n\n# The following encodings don't work in stateful mode\nbroken_unicode_with_streams = [\n    \"punycode\",\n    \"unicode_internal\"\n]\nbroken_incremental_coders = broken_unicode_with_streams + [\n    \"idna\",\n]\n\nclass BasicUnicodeTest(unittest.TestCase, MixInCheckStateHandling):\n    def test_basics(self):\n        s = \"abc123\" # all codecs should be able to encode these\n        for encoding in all_unicode_encodings:\n            name = codecs.lookup(encoding).name\n            if encoding.endswith(\"_codec\"):\n                name += \"_codec\"\n            elif encoding == \"latin_1\":\n                name = \"latin_1\"\n            self.assertEqual(encoding.replace(\"_\", \"-\"), name.replace(\"_\", \"-\"))\n            (b, size) = codecs.getencoder(encoding)(s)\n            self.assertEqual(size, len(s), \"%r != %r (encoding=%r)\" % (size, len(s), encoding))\n            (chars, size) = codecs.getdecoder(encoding)(b)\n            self.assertEqual(chars, s, \"%r != %r (encoding=%r)\" % (chars, s, encoding))\n\n            if encoding not in broken_unicode_with_streams:\n                # check stream reader/writer\n                q = Queue(b\"\")\n                writer = codecs.getwriter(encoding)(q)\n                encodedresult = b\"\"\n                for c in s:\n                    writer.write(c)\n                    chunk = q.read()\n                    self.assertTrue(type(chunk) is bytes, type(chunk))\n                    encodedresult += chunk\n                q = Queue(b\"\")\n                reader = codecs.getreader(encoding)(q)\n                decodedresult = \"\"\n                for c in encodedresult:\n                    q.write(bytes([c]))\n                    decodedresult += reader.read()\n                self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n            if encoding not in broken_incremental_coders:\n                # check incremental decoder/encoder (fetched via the Python\n                # and C API) and iterencode()/iterdecode()\n                try:\n                    encoder = codecs.getincrementalencoder(encoding)()\n                    cencoder = _testcapi.codec_incrementalencoder(encoding)\n                except LookupError: # no IncrementalEncoder\n                    pass\n                else:\n                    # check incremental decoder/encoder\n                    encodedresult = b\"\"\n                    for c in s:\n                        encodedresult += encoder.encode(c)\n                    encodedresult += encoder.encode(\"\", True)\n                    decoder = codecs.getincrementaldecoder(encoding)()\n                    decodedresult = \"\"\n                    for c in encodedresult:\n                        decodedresult += decoder.decode(bytes([c]))\n                    decodedresult += decoder.decode(b\"\", True)\n                    self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n                    # check C API\n                    encodedresult = b\"\"\n                    for c in s:\n                        encodedresult += cencoder.encode(c)\n                    encodedresult += cencoder.encode(\"\", True)\n                    cdecoder = _testcapi.codec_incrementaldecoder(encoding)\n                    decodedresult = \"\"\n                    for c in encodedresult:\n                        decodedresult += cdecoder.decode(bytes([c]))\n                    decodedresult += cdecoder.decode(b\"\", True)\n                    self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n                    # check iterencode()/iterdecode()\n                    result = \"\".join(codecs.iterdecode(codecs.iterencode(s, encoding), encoding))\n                    self.assertEqual(result, s, \"%r != %r (encoding=%r)\" % (result, s, encoding))\n\n                    # check iterencode()/iterdecode() with empty string\n                    result = \"\".join(codecs.iterdecode(codecs.iterencode(\"\", encoding), encoding))\n                    self.assertEqual(result, \"\")\n\n                if encoding not in (\"idna\", \"mbcs\"):\n                    # check incremental decoder/encoder with errors argument\n                    try:\n                        encoder = codecs.getincrementalencoder(encoding)(\"ignore\")\n                        cencoder = _testcapi.codec_incrementalencoder(encoding, \"ignore\")\n                    except LookupError: # no IncrementalEncoder\n                        pass\n                    else:\n                        encodedresult = b\"\".join(encoder.encode(c) for c in s)\n                        decoder = codecs.getincrementaldecoder(encoding)(\"ignore\")\n                        decodedresult = \"\".join(decoder.decode(bytes([c])) for c in encodedresult)\n                        self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n                        encodedresult = b\"\".join(cencoder.encode(c) for c in s)\n                        cdecoder = _testcapi.codec_incrementaldecoder(encoding, \"ignore\")\n                        decodedresult = \"\".join(cdecoder.decode(bytes([c])) for c in encodedresult)\n                        self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n    def test_seek(self):\n        # all codecs should be able to encode these\n        s = \"%s\\n%s\\n\" % (100*\"abc123\", 100*\"def456\")\n        for encoding in all_unicode_encodings:\n            if encoding == \"idna\": # FIXME: See SF bug #1163178\n                continue\n            if encoding in broken_unicode_with_streams:\n                continue\n            reader = codecs.getreader(encoding)(io.BytesIO(s.encode(encoding)))\n            for t in range(5):\n                # Test that calling seek resets the internal codec state and buffers\n                reader.seek(0, 0)\n                data = reader.read()\n                self.assertEqual(s, data)\n\n    def test_bad_decode_args(self):\n        for encoding in all_unicode_encodings:\n            decoder = codecs.getdecoder(encoding)\n            self.assertRaises(TypeError, decoder)\n            if encoding not in (\"idna\", \"punycode\"):\n                self.assertRaises(TypeError, decoder, 42)\n\n    def test_bad_encode_args(self):\n        for encoding in all_unicode_encodings:\n            encoder = codecs.getencoder(encoding)\n            self.assertRaises(TypeError, encoder)\n\n    def test_encoding_map_type_initialized(self):\n        from encodings import cp1140\n        # This used to crash, we are only verifying there's no crash.\n        table_type = type(cp1140.encoding_table)\n        self.assertEqual(table_type, table_type)\n\n    def test_decoder_state(self):\n        # Check that getstate() and setstate() handle the state properly\n        u = \"abc123\"\n        for encoding in all_unicode_encodings:\n            if encoding not in broken_incremental_coders:\n                self.check_state_handling_decode(encoding, u, u.encode(encoding))\n                self.check_state_handling_encode(encoding, u, u.encode(encoding))\n\nclass CharmapTest(unittest.TestCase):\n    def test_decode_with_string_map(self):\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"strict\", \"abc\"),\n            (\"abc\", 3)\n        )\n\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"replace\", \"ab\"),\n            (\"ab\\ufffd\", 3)\n        )\n\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"replace\", \"ab\\ufffe\"),\n            (\"ab\\ufffd\", 3)\n        )\n\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"ignore\", \"ab\"),\n            (\"ab\", 3)\n        )\n\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"ignore\", \"ab\\ufffe\"),\n            (\"ab\", 3)\n        )\n\n        allbytes = bytes(range(256))\n        self.assertEqual(\n            codecs.charmap_decode(allbytes, \"ignore\", \"\"),\n            (\"\", len(allbytes))\n        )\n\nclass WithStmtTest(unittest.TestCase):\n    def test_encodedfile(self):\n        f = io.BytesIO(b\"\\xc3\\xbc\")\n        with codecs.EncodedFile(f, \"latin-1\", \"utf-8\") as ef:\n            self.assertEqual(ef.read(), b\"\\xfc\")\n\n    def test_streamreaderwriter(self):\n        f = io.BytesIO(b\"\\xc3\\xbc\")\n        info = codecs.lookup(\"utf-8\")\n        with codecs.StreamReaderWriter(f, info.streamreader,\n                                       info.streamwriter, 'strict') as srw:\n            self.assertEqual(srw.read(), \"\\xfc\")\n\nclass TypesTest(unittest.TestCase):\n    def test_decode_unicode(self):\n        # Most decoders don't accept unicode input\n        decoders = [\n            codecs.utf_7_decode,\n            codecs.utf_8_decode,\n            codecs.utf_16_le_decode,\n            codecs.utf_16_be_decode,\n            codecs.utf_16_ex_decode,\n            codecs.utf_32_decode,\n            codecs.utf_32_le_decode,\n            codecs.utf_32_be_decode,\n            codecs.utf_32_ex_decode,\n            codecs.latin_1_decode,\n            codecs.ascii_decode,\n            codecs.charmap_decode,\n        ]\n        if hasattr(codecs, \"mbcs_decode\"):\n            decoders.append(codecs.mbcs_decode)\n        for decoder in decoders:\n            self.assertRaises(TypeError, decoder, \"xxx\")\n\n    def test_unicode_escape(self):\n        # Escape-decoding an unicode string is supported ang gives the same\n        # result as decoding the equivalent ASCII bytes string.\n        self.assertEqual(codecs.unicode_escape_decode(r\"\\u1234\"), (\"\\u1234\", 6))\n        self.assertEqual(codecs.unicode_escape_decode(br\"\\u1234\"), (\"\\u1234\", 6))\n        self.assertEqual(codecs.raw_unicode_escape_decode(r\"\\u1234\"), (\"\\u1234\", 6))\n        self.assertEqual(codecs.raw_unicode_escape_decode(br\"\\u1234\"), (\"\\u1234\", 6))\n\nclass SurrogateEscapeTest(unittest.TestCase):\n\n    def test_utf8(self):\n        # Bad byte\n        self.assertEqual(b\"foo\\x80bar\".decode(\"utf-8\", \"surrogateescape\"),\n                         \"foo\\udc80bar\")\n        self.assertEqual(\"foo\\udc80bar\".encode(\"utf-8\", \"surrogateescape\"),\n                         b\"foo\\x80bar\")\n        # bad-utf-8 encoded surrogate\n        self.assertEqual(b\"\\xed\\xb0\\x80\".decode(\"utf-8\", \"surrogateescape\"),\n                         \"\\udced\\udcb0\\udc80\")\n        self.assertEqual(\"\\udced\\udcb0\\udc80\".encode(\"utf-8\", \"surrogateescape\"),\n                         b\"\\xed\\xb0\\x80\")\n\n    def test_ascii(self):\n        # bad byte\n        self.assertEqual(b\"foo\\x80bar\".decode(\"ascii\", \"surrogateescape\"),\n                         \"foo\\udc80bar\")\n        self.assertEqual(\"foo\\udc80bar\".encode(\"ascii\", \"surrogateescape\"),\n                         b\"foo\\x80bar\")\n\n    def test_charmap(self):\n        # bad byte: \\xa5 is unmapped in iso-8859-3\n        self.assertEqual(b\"foo\\xa5bar\".decode(\"iso-8859-3\", \"surrogateescape\"),\n                         \"foo\\udca5bar\")\n        self.assertEqual(\"foo\\udca5bar\".encode(\"iso-8859-3\", \"surrogateescape\"),\n                         b\"foo\\xa5bar\")\n\n    def test_latin1(self):\n        # Issue6373\n        self.assertEqual(\"\\udce4\\udceb\\udcef\\udcf6\\udcfc\".encode(\"latin1\", \"surrogateescape\"),\n                         b\"\\xe4\\xeb\\xef\\xf6\\xfc\")\n\n\nclass BomTest(unittest.TestCase):\n    def test_seek0(self):\n        data = \"1234567890\"\n        tests = (\"utf-16\",\n                 \"utf-16-le\",\n                 \"utf-16-be\",\n                 \"utf-32\",\n                 \"utf-32-le\",\n                 \"utf-32-be\")\n        self.addCleanup(support.unlink, support.TESTFN)\n        for encoding in tests:\n            # Check if the BOM is written only once\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.write(data)\n                f.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data * 2)\n                f.seek(0)\n                self.assertEqual(f.read(), data * 2)\n\n            # Check that the BOM is written after a seek(0)\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.write(data[0])\n                self.assertNotEqual(f.tell(), 0)\n                f.seek(0)\n                f.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data)\n\n            # (StreamWriter) Check that the BOM is written after a seek(0)\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.writer.write(data[0])\n                self.assertNotEqual(f.writer.tell(), 0)\n                f.writer.seek(0)\n                f.writer.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data)\n\n            # Check that the BOM is not written after a seek() at a position\n            # different than the start\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.write(data)\n                f.seek(f.tell())\n                f.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data * 2)\n\n            # (StreamWriter) Check that the BOM is not written after a seek()\n            # at a position different than the start\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.writer.write(data)\n                f.writer.seek(f.writer.tell())\n                f.writer.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data * 2)\n\n\nbytes_transform_encodings = [\n    \"base64_codec\",\n    \"uu_codec\",\n    \"quopri_codec\",\n    \"hex_codec\",\n]\ntry:\n    import zlib\nexcept ImportError:\n    pass\nelse:\n    bytes_transform_encodings.append(\"zlib_codec\")\ntry:\n    import bz2\nexcept ImportError:\n    pass\nelse:\n    bytes_transform_encodings.append(\"bz2_codec\")\n\nclass TransformCodecTest(unittest.TestCase):\n\n    def test_basics(self):\n        binput = bytes(range(256))\n        for encoding in bytes_transform_encodings:\n            # generic codecs interface\n            (o, size) = codecs.getencoder(encoding)(binput)\n            self.assertEqual(size, len(binput))\n            (i, size) = codecs.getdecoder(encoding)(o)\n            self.assertEqual(size, len(o))\n            self.assertEqual(i, binput)\n\n    def test_read(self):\n        for encoding in bytes_transform_encodings:\n            sin = codecs.encode(b\"\\x80\", encoding)\n            reader = codecs.getreader(encoding)(io.BytesIO(sin))\n            sout = reader.read()\n            self.assertEqual(sout, b\"\\x80\")\n\n    def test_readline(self):\n        for encoding in bytes_transform_encodings:\n            if encoding in ['uu_codec', 'zlib_codec']:\n                continue\n            sin = codecs.encode(b\"\\x80\", encoding)\n            reader = codecs.getreader(encoding)(io.BytesIO(sin))\n            sout = reader.readline()\n            self.assertEqual(sout, b\"\\x80\")\n\n\ndef test_main():\n    support.run_unittest(\n        UTF32Test,\n        UTF32LETest,\n        UTF32BETest,\n        UTF16Test,\n        UTF16LETest,\n        UTF16BETest,\n        UTF8Test,\n        UTF8SigTest,\n        UTF7Test,\n        UTF16ExTest,\n        ReadBufferTest,\n        RecodingTest,\n        PunycodeTest,\n        UnicodeInternalTest,\n        NameprepTest,\n        IDNACodecTest,\n        CodecsModuleTest,\n        StreamReaderTest,\n        EncodedFileTest,\n        BasicUnicodeTest,\n        CharmapTest,\n        WithStmtTest,\n        TypesTest,\n        SurrogateEscapeTest,\n        BomTest,\n        TransformCodecTest,\n    )\n\n\nif __name__ == \"__main__\":\n    test_main()\n",
    "code_after": "from test import support\nimport unittest\nimport codecs\nimport locale\nimport sys, _testcapi, io\n\nclass Queue(object):\n    \"\"\"\n    queue: write bytes at one end, read bytes from the other end\n    \"\"\"\n    def __init__(self, buffer):\n        self._buffer = buffer\n\n    def write(self, chars):\n        self._buffer += chars\n\n    def read(self, size=-1):\n        if size<0:\n            s = self._buffer\n            self._buffer = self._buffer[:0] # make empty\n            return s\n        else:\n            s = self._buffer[:size]\n            self._buffer = self._buffer[size:]\n            return s\n\nclass MixInCheckStateHandling:\n    def check_state_handling_decode(self, encoding, u, s):\n        for i in range(len(s)+1):\n            d = codecs.getincrementaldecoder(encoding)()\n            part1 = d.decode(s[:i])\n            state = d.getstate()\n            self.assertIsInstance(state[1], int)\n            # Check that the condition stated in the documentation for\n            # IncrementalDecoder.getstate() holds\n            if not state[1]:\n                # reset decoder to the default state without anything buffered\n                d.setstate((state[0][:0], 0))\n                # Feeding the previous input may not produce any output\n                self.assertTrue(not d.decode(state[0]))\n                # The decoder must return to the same state\n                self.assertEqual(state, d.getstate())\n            # Create a new decoder and set it to the state\n            # we extracted from the old one\n            d = codecs.getincrementaldecoder(encoding)()\n            d.setstate(state)\n            part2 = d.decode(s[i:], True)\n            self.assertEqual(u, part1+part2)\n\n    def check_state_handling_encode(self, encoding, u, s):\n        for i in range(len(u)+1):\n            d = codecs.getincrementalencoder(encoding)()\n            part1 = d.encode(u[:i])\n            state = d.getstate()\n            d = codecs.getincrementalencoder(encoding)()\n            d.setstate(state)\n            part2 = d.encode(u[i:], True)\n            self.assertEqual(s, part1+part2)\n\nclass ReadTest(unittest.TestCase, MixInCheckStateHandling):\n    def check_partial(self, input, partialresults):\n        # get a StreamReader for the encoding and feed the bytestring version\n        # of input to the reader byte by byte. Read everything available from\n        # the StreamReader and check that the results equal the appropriate\n        # entries from partialresults.\n        q = Queue(b\"\")\n        r = codecs.getreader(self.encoding)(q)\n        result = \"\"\n        for (c, partialresult) in zip(input.encode(self.encoding), partialresults):\n            q.write(bytes([c]))\n            result += r.read()\n            self.assertEqual(result, partialresult)\n        # check that there's nothing left in the buffers\n        self.assertEqual(r.read(), \"\")\n        self.assertEqual(r.bytebuffer, b\"\")\n\n        # do the check again, this time using a incremental decoder\n        d = codecs.getincrementaldecoder(self.encoding)()\n        result = \"\"\n        for (c, partialresult) in zip(input.encode(self.encoding), partialresults):\n            result += d.decode(bytes([c]))\n            self.assertEqual(result, partialresult)\n        # check that there's nothing left in the buffers\n        self.assertEqual(d.decode(b\"\", True), \"\")\n        self.assertEqual(d.buffer, b\"\")\n\n        # Check whether the reset method works properly\n        d.reset()\n        result = \"\"\n        for (c, partialresult) in zip(input.encode(self.encoding), partialresults):\n            result += d.decode(bytes([c]))\n            self.assertEqual(result, partialresult)\n        # check that there's nothing left in the buffers\n        self.assertEqual(d.decode(b\"\", True), \"\")\n        self.assertEqual(d.buffer, b\"\")\n\n        # check iterdecode()\n        encoded = input.encode(self.encoding)\n        self.assertEqual(\n            input,\n            \"\".join(codecs.iterdecode([bytes([c]) for c in encoded], self.encoding))\n        )\n\n    def test_readline(self):\n        def getreader(input):\n            stream = io.BytesIO(input.encode(self.encoding))\n            return codecs.getreader(self.encoding)(stream)\n\n        def readalllines(input, keepends=True, size=None):\n            reader = getreader(input)\n            lines = []\n            while True:\n                line = reader.readline(size=size, keepends=keepends)\n                if not line:\n                    break\n                lines.append(line)\n            return \"|\".join(lines)\n\n        s = \"foo\\nbar\\r\\nbaz\\rspam\\u2028eggs\"\n        sexpected = \"foo\\n|bar\\r\\n|baz\\r|spam\\u2028|eggs\"\n        sexpectednoends = \"foo|bar|baz|spam|eggs\"\n        self.assertEqual(readalllines(s, True), sexpected)\n        self.assertEqual(readalllines(s, False), sexpectednoends)\n        self.assertEqual(readalllines(s, True, 10), sexpected)\n        self.assertEqual(readalllines(s, False, 10), sexpectednoends)\n\n        # Test long lines (multiple calls to read() in readline())\n        vw = []\n        vwo = []\n        for (i, lineend) in enumerate(\"\\n \\r\\n \\r \\u2028\".split()):\n            vw.append((i*200)*\"\\3042\" + lineend)\n            vwo.append((i*200)*\"\\3042\")\n        self.assertEqual(readalllines(\"\".join(vw), True), \"\".join(vw))\n        self.assertEqual(readalllines(\"\".join(vw), False),\"\".join(vwo))\n\n        # Test lines where the first read might end with \\r, so the\n        # reader has to look ahead whether this is a lone \\r or a \\r\\n\n        for size in range(80):\n            for lineend in \"\\n \\r\\n \\r \\u2028\".split():\n                s = 10*(size*\"a\" + lineend + \"xxx\\n\")\n                reader = getreader(s)\n                for i in range(10):\n                    self.assertEqual(\n                        reader.readline(keepends=True),\n                        size*\"a\" + lineend,\n                    )\n                reader = getreader(s)\n                for i in range(10):\n                    self.assertEqual(\n                        reader.readline(keepends=False),\n                        size*\"a\",\n                    )\n\n    def test_bug1175396(self):\n        s = [\n            '<%!--===================================================\\r\\n',\n            '    BLOG index page: show recent articles,\\r\\n',\n            '    today\\'s articles, or articles of a specific date.\\r\\n',\n            '========================================================--%>\\r\\n',\n            '<%@inputencoding=\"ISO-8859-1\"%>\\r\\n',\n            '<%@pagetemplate=TEMPLATE.y%>\\r\\n',\n            '<%@import=import frog.util, frog%>\\r\\n',\n            '<%@import=import frog.objects%>\\r\\n',\n            '<%@import=from frog.storageerrors import StorageError%>\\r\\n',\n            '<%\\r\\n',\n            '\\r\\n',\n            'import logging\\r\\n',\n            'log=logging.getLogger(\"Snakelets.logger\")\\r\\n',\n            '\\r\\n',\n            '\\r\\n',\n            'user=self.SessionCtx.user\\r\\n',\n            'storageEngine=self.SessionCtx.storageEngine\\r\\n',\n            '\\r\\n',\n            '\\r\\n',\n            'def readArticlesFromDate(date, count=None):\\r\\n',\n            '    entryids=storageEngine.listBlogEntries(date)\\r\\n',\n            '    entryids.reverse() # descending\\r\\n',\n            '    if count:\\r\\n',\n            '        entryids=entryids[:count]\\r\\n',\n            '    try:\\r\\n',\n            '        return [ frog.objects.BlogEntry.load(storageEngine, date, Id) for Id in entryids ]\\r\\n',\n            '    except StorageError,x:\\r\\n',\n            '        log.error(\"Error loading articles: \"+str(x))\\r\\n',\n            '        self.abort(\"cannot load articles\")\\r\\n',\n            '\\r\\n',\n            'showdate=None\\r\\n',\n            '\\r\\n',\n            'arg=self.Request.getArg()\\r\\n',\n            'if arg==\"today\":\\r\\n',\n            '    #-------------------- TODAY\\'S ARTICLES\\r\\n',\n            '    self.write(\"<h2>Today\\'s articles</h2>\")\\r\\n',\n            '    showdate = frog.util.isodatestr() \\r\\n',\n            '    entries = readArticlesFromDate(showdate)\\r\\n',\n            'elif arg==\"active\":\\r\\n',\n            '    #-------------------- ACTIVE ARTICLES redirect\\r\\n',\n            '    self.Yredirect(\"active.y\")\\r\\n',\n            'elif arg==\"login\":\\r\\n',\n            '    #-------------------- LOGIN PAGE redirect\\r\\n',\n            '    self.Yredirect(\"login.y\")\\r\\n',\n            'elif arg==\"date\":\\r\\n',\n            '    #-------------------- ARTICLES OF A SPECIFIC DATE\\r\\n',\n            '    showdate = self.Request.getParameter(\"date\")\\r\\n',\n            '    self.write(\"<h2>Articles written on %s</h2>\"% frog.util.mediumdatestr(showdate))\\r\\n',\n            '    entries = readArticlesFromDate(showdate)\\r\\n',\n            'else:\\r\\n',\n            '    #-------------------- RECENT ARTICLES\\r\\n',\n            '    self.write(\"<h2>Recent articles</h2>\")\\r\\n',\n            '    dates=storageEngine.listBlogEntryDates()\\r\\n',\n            '    if dates:\\r\\n',\n            '        entries=[]\\r\\n',\n            '        SHOWAMOUNT=10\\r\\n',\n            '        for showdate in dates:\\r\\n',\n            '            entries.extend( readArticlesFromDate(showdate, SHOWAMOUNT-len(entries)) )\\r\\n',\n            '            if len(entries)>=SHOWAMOUNT:\\r\\n',\n            '                break\\r\\n',\n            '                \\r\\n',\n        ]\n        stream = io.BytesIO(\"\".join(s).encode(self.encoding))\n        reader = codecs.getreader(self.encoding)(stream)\n        for (i, line) in enumerate(reader):\n            self.assertEqual(line, s[i])\n\n    def test_readlinequeue(self):\n        q = Queue(b\"\")\n        writer = codecs.getwriter(self.encoding)(q)\n        reader = codecs.getreader(self.encoding)(q)\n\n        # No lineends\n        writer.write(\"foo\\r\")\n        self.assertEqual(reader.readline(keepends=False), \"foo\")\n        writer.write(\"\\nbar\\r\")\n        self.assertEqual(reader.readline(keepends=False), \"\")\n        self.assertEqual(reader.readline(keepends=False), \"bar\")\n        writer.write(\"baz\")\n        self.assertEqual(reader.readline(keepends=False), \"baz\")\n        self.assertEqual(reader.readline(keepends=False), \"\")\n\n        # Lineends\n        writer.write(\"foo\\r\")\n        self.assertEqual(reader.readline(keepends=True), \"foo\\r\")\n        writer.write(\"\\nbar\\r\")\n        self.assertEqual(reader.readline(keepends=True), \"\\n\")\n        self.assertEqual(reader.readline(keepends=True), \"bar\\r\")\n        writer.write(\"baz\")\n        self.assertEqual(reader.readline(keepends=True), \"baz\")\n        self.assertEqual(reader.readline(keepends=True), \"\")\n        writer.write(\"foo\\r\\n\")\n        self.assertEqual(reader.readline(keepends=True), \"foo\\r\\n\")\n\n    def test_bug1098990_a(self):\n        s1 = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\\r\\n\"\n        s2 = \"offending line: ladfj askldfj klasdj fskla dfzaskdj fasklfj laskd fjasklfzzzzaa%whereisthis!!!\\r\\n\"\n        s3 = \"next line.\\r\\n\"\n\n        s = (s1+s2+s3).encode(self.encoding)\n        stream = io.BytesIO(s)\n        reader = codecs.getreader(self.encoding)(stream)\n        self.assertEqual(reader.readline(), s1)\n        self.assertEqual(reader.readline(), s2)\n        self.assertEqual(reader.readline(), s3)\n        self.assertEqual(reader.readline(), \"\")\n\n    def test_bug1098990_b(self):\n        s1 = \"aaaaaaaaaaaaaaaaaaaaaaaa\\r\\n\"\n        s2 = \"bbbbbbbbbbbbbbbbbbbbbbbb\\r\\n\"\n        s3 = \"stillokay:bbbbxx\\r\\n\"\n        s4 = \"broken!!!!badbad\\r\\n\"\n        s5 = \"againokay.\\r\\n\"\n\n        s = (s1+s2+s3+s4+s5).encode(self.encoding)\n        stream = io.BytesIO(s)\n        reader = codecs.getreader(self.encoding)(stream)\n        self.assertEqual(reader.readline(), s1)\n        self.assertEqual(reader.readline(), s2)\n        self.assertEqual(reader.readline(), s3)\n        self.assertEqual(reader.readline(), s4)\n        self.assertEqual(reader.readline(), s5)\n        self.assertEqual(reader.readline(), \"\")\n\nclass UTF32Test(ReadTest):\n    encoding = \"utf-32\"\n\n    spamle = (b'\\xff\\xfe\\x00\\x00'\n              b's\\x00\\x00\\x00p\\x00\\x00\\x00a\\x00\\x00\\x00m\\x00\\x00\\x00'\n              b's\\x00\\x00\\x00p\\x00\\x00\\x00a\\x00\\x00\\x00m\\x00\\x00\\x00')\n    spambe = (b'\\x00\\x00\\xfe\\xff'\n              b'\\x00\\x00\\x00s\\x00\\x00\\x00p\\x00\\x00\\x00a\\x00\\x00\\x00m'\n              b'\\x00\\x00\\x00s\\x00\\x00\\x00p\\x00\\x00\\x00a\\x00\\x00\\x00m')\n\n    def test_only_one_bom(self):\n        _,_,reader,writer = codecs.lookup(self.encoding)\n        # encode some stream\n        s = io.BytesIO()\n        f = writer(s)\n        f.write(\"spam\")\n        f.write(\"spam\")\n        d = s.getvalue()\n        # check whether there is exactly one BOM in it\n        self.assertTrue(d == self.spamle or d == self.spambe)\n        # try to read it back\n        s = io.BytesIO(d)\n        f = reader(s)\n        self.assertEqual(f.read(), \"spamspam\")\n\n    def test_badbom(self):\n        s = io.BytesIO(4*b\"\\xff\")\n        f = codecs.getreader(self.encoding)(s)\n        self.assertRaises(UnicodeError, f.read)\n\n        s = io.BytesIO(8*b\"\\xff\")\n        f = codecs.getreader(self.encoding)(s)\n        self.assertRaises(UnicodeError, f.read)\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\", # first byte of BOM read\n                \"\", # second byte of BOM read\n                \"\", # third byte of BOM read\n                \"\", # fourth byte of BOM read => byteorder known\n                \"\",\n                \"\",\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_handlers(self):\n        self.assertEqual(('\\ufffd', 1),\n                         codecs.utf_32_decode(b'\\x01', 'replace', True))\n        self.assertEqual(('', 1),\n                         codecs.utf_32_decode(b'\\x01', 'ignore', True))\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_32_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_decoder_state(self):\n        self.check_state_handling_decode(self.encoding,\n                                         \"spamspam\", self.spamle)\n        self.check_state_handling_decode(self.encoding,\n                                         \"spamspam\", self.spambe)\n\n    def test_issue8941(self):\n        # Issue #8941: insufficient result allocation when decoding into\n        # surrogate pairs on UCS-2 builds.\n        encoded_le = b'\\xff\\xfe\\x00\\x00' + b'\\x00\\x00\\x01\\x00' * 1024\n        self.assertEqual('\\U00010000' * 1024,\n                         codecs.utf_32_decode(encoded_le)[0])\n        encoded_be = b'\\x00\\x00\\xfe\\xff' + b'\\x00\\x01\\x00\\x00' * 1024\n        self.assertEqual('\\U00010000' * 1024,\n                         codecs.utf_32_decode(encoded_be)[0])\n\nclass UTF32LETest(ReadTest):\n    encoding = \"utf-32-le\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\",\n                \"\",\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_simple(self):\n        self.assertEqual(\"\\U00010203\".encode(self.encoding), b\"\\x03\\x02\\x01\\x00\")\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_32_le_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_issue8941(self):\n        # Issue #8941: insufficient result allocation when decoding into\n        # surrogate pairs on UCS-2 builds.\n        encoded = b'\\x00\\x00\\x01\\x00' * 1024\n        self.assertEqual('\\U00010000' * 1024,\n                         codecs.utf_32_le_decode(encoded)[0])\n\nclass UTF32BETest(ReadTest):\n    encoding = \"utf-32-be\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\",\n                \"\",\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_simple(self):\n        self.assertEqual(\"\\U00010203\".encode(self.encoding), b\"\\x00\\x01\\x02\\x03\")\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_32_be_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_issue8941(self):\n        # Issue #8941: insufficient result allocation when decoding into\n        # surrogate pairs on UCS-2 builds.\n        encoded = b'\\x00\\x01\\x00\\x00' * 1024\n        self.assertEqual('\\U00010000' * 1024,\n                         codecs.utf_32_be_decode(encoded)[0])\n\n\nclass UTF16Test(ReadTest):\n    encoding = \"utf-16\"\n\n    spamle = b'\\xff\\xfes\\x00p\\x00a\\x00m\\x00s\\x00p\\x00a\\x00m\\x00'\n    spambe = b'\\xfe\\xff\\x00s\\x00p\\x00a\\x00m\\x00s\\x00p\\x00a\\x00m'\n\n    def test_only_one_bom(self):\n        _,_,reader,writer = codecs.lookup(self.encoding)\n        # encode some stream\n        s = io.BytesIO()\n        f = writer(s)\n        f.write(\"spam\")\n        f.write(\"spam\")\n        d = s.getvalue()\n        # check whether there is exactly one BOM in it\n        self.assertTrue(d == self.spamle or d == self.spambe)\n        # try to read it back\n        s = io.BytesIO(d)\n        f = reader(s)\n        self.assertEqual(f.read(), \"spamspam\")\n\n    def test_badbom(self):\n        s = io.BytesIO(b\"\\xff\\xff\")\n        f = codecs.getreader(self.encoding)(s)\n        self.assertRaises(UnicodeError, f.read)\n\n        s = io.BytesIO(b\"\\xff\\xff\\xff\\xff\")\n        f = codecs.getreader(self.encoding)(s)\n        self.assertRaises(UnicodeError, f.read)\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\", # first byte of BOM read\n                \"\", # second byte of BOM read => byteorder known\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_handlers(self):\n        self.assertEqual(('\\ufffd', 1),\n                         codecs.utf_16_decode(b'\\x01', 'replace', True))\n        self.assertEqual(('', 1),\n                         codecs.utf_16_decode(b'\\x01', 'ignore', True))\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_16_decode,\n                          b\"\\xff\", \"strict\", True)\n\n    def test_decoder_state(self):\n        self.check_state_handling_decode(self.encoding,\n                                         \"spamspam\", self.spamle)\n        self.check_state_handling_decode(self.encoding,\n                                         \"spamspam\", self.spambe)\n\n    def test_bug691291(self):\n        # Files are always opened in binary mode, even if no binary mode was\n        # specified.  This means that no automatic conversion of '\\n' is done\n        # on reading and writing.\n        s1 = 'Hello\\r\\nworld\\r\\n'\n\n        s = s1.encode(self.encoding)\n        self.addCleanup(support.unlink, support.TESTFN)\n        with open(support.TESTFN, 'wb') as fp:\n            fp.write(s)\n        with codecs.open(support.TESTFN, 'U', encoding=self.encoding) as reader:\n            self.assertEqual(reader.read(), s1)\n\nclass UTF16LETest(ReadTest):\n    encoding = \"utf-16-le\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_errors(self):\n        tests = [\n            (b'\\xff', '\\ufffd'),\n            (b'A\\x00Z', 'A\\ufffd'),\n            (b'A\\x00B\\x00C\\x00D\\x00Z', 'ABCD\\ufffd'),\n            (b'\\x00\\xd8', '\\ufffd'),\n            (b'\\x00\\xd8A', '\\ufffd'),\n            (b'\\x00\\xd8A\\x00', '\\ufffdA'),\n            (b'\\x00\\xdcA\\x00', '\\ufffdA'),\n        ]\n        for raw, expected in tests:\n            self.assertRaises(UnicodeDecodeError, codecs.utf_16_le_decode,\n                              raw, 'strict', True)\n            self.assertEqual(raw.decode('utf-16le', 'replace'), expected)\n\n    def test_nonbmp(self):\n        self.assertEqual(\"\\U00010203\".encode(self.encoding),\n                         b'\\x00\\xd8\\x03\\xde')\n        self.assertEqual(b'\\x00\\xd8\\x03\\xde'.decode(self.encoding),\n                         \"\\U00010203\")\n\nclass UTF16BETest(ReadTest):\n    encoding = \"utf-16-be\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u0100\\uffff\",\n            [\n                \"\",\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\",\n                \"\\x00\\xff\\u0100\\uffff\",\n            ]\n        )\n\n    def test_errors(self):\n        tests = [\n            (b'\\xff', '\\ufffd'),\n            (b'\\x00A\\xff', 'A\\ufffd'),\n            (b'\\x00A\\x00B\\x00C\\x00DZ', 'ABCD\\ufffd'),\n            (b'\\xd8\\x00', '\\ufffd'),\n            (b'\\xd8\\x00\\xdc', '\\ufffd'),\n            (b'\\xd8\\x00\\x00A', '\\ufffdA'),\n            (b'\\xdc\\x00\\x00A', '\\ufffdA'),\n        ]\n        for raw, expected in tests:\n            self.assertRaises(UnicodeDecodeError, codecs.utf_16_be_decode,\n                              raw, 'strict', True)\n            self.assertEqual(raw.decode('utf-16be', 'replace'), expected)\n\n    def test_nonbmp(self):\n        self.assertEqual(\"\\U00010203\".encode(self.encoding),\n                         b'\\xd8\\x00\\xde\\x03')\n        self.assertEqual(b'\\xd8\\x00\\xde\\x03'.decode(self.encoding),\n                         \"\\U00010203\")\n\nclass UTF8Test(ReadTest):\n    encoding = \"utf-8\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\x00\\xff\\u07ff\\u0800\\uffff\",\n            [\n                \"\\x00\",\n                \"\\x00\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\",\n                \"\\x00\\xff\\u07ff\",\n                \"\\x00\\xff\\u07ff\",\n                \"\\x00\\xff\\u07ff\",\n                \"\\x00\\xff\\u07ff\\u0800\",\n                \"\\x00\\xff\\u07ff\\u0800\",\n                \"\\x00\\xff\\u07ff\\u0800\",\n                \"\\x00\\xff\\u07ff\\u0800\\uffff\",\n            ]\n        )\n\n    def test_decoder_state(self):\n        u = \"\\x00\\x7f\\x80\\xff\\u0100\\u07ff\\u0800\\uffff\\U0010ffff\"\n        self.check_state_handling_decode(self.encoding,\n                                         u, u.encode(self.encoding))\n\n    def test_lone_surrogates(self):\n        self.assertRaises(UnicodeEncodeError, \"\\ud800\".encode, \"utf-8\")\n        self.assertRaises(UnicodeDecodeError, b\"\\xed\\xa0\\x80\".decode, \"utf-8\")\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"backslashreplace\"),\n                         b'[\\\\udc80]')\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"xmlcharrefreplace\"),\n                         b'[&#56448;]')\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"surrogateescape\"),\n                         b'[\\x80]')\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"ignore\"),\n                         b'[]')\n        self.assertEqual(\"[\\uDC80]\".encode(\"utf-8\", \"replace\"),\n                         b'[?]')\n\n    def test_surrogatepass_handler(self):\n        self.assertEqual(\"abc\\ud800def\".encode(\"utf-8\", \"surrogatepass\"),\n                         b\"abc\\xed\\xa0\\x80def\")\n        self.assertEqual(b\"abc\\xed\\xa0\\x80def\".decode(\"utf-8\", \"surrogatepass\"),\n                         \"abc\\ud800def\")\n        self.assertTrue(codecs.lookup_error(\"surrogatepass\"))\n\nclass UTF7Test(ReadTest):\n    encoding = \"utf-7\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"a+-b\",\n            [\n                \"a\",\n                \"a\",\n                \"a+\",\n                \"a+-\",\n                \"a+-b\",\n            ]\n        )\n\nclass UTF16ExTest(unittest.TestCase):\n\n    def test_errors(self):\n        self.assertRaises(UnicodeDecodeError, codecs.utf_16_ex_decode, b\"\\xff\", \"strict\", 0, True)\n\n    def test_bad_args(self):\n        self.assertRaises(TypeError, codecs.utf_16_ex_decode)\n\nclass ReadBufferTest(unittest.TestCase):\n\n    def test_array(self):\n        import array\n        self.assertEqual(\n            codecs.readbuffer_encode(array.array(\"b\", b\"spam\")),\n            (b\"spam\", 4)\n        )\n\n    def test_empty(self):\n        self.assertEqual(codecs.readbuffer_encode(\"\"), (b\"\", 0))\n\n    def test_bad_args(self):\n        self.assertRaises(TypeError, codecs.readbuffer_encode)\n        self.assertRaises(TypeError, codecs.readbuffer_encode, 42)\n\nclass UTF8SigTest(ReadTest):\n    encoding = \"utf-8-sig\"\n\n    def test_partial(self):\n        self.check_partial(\n            \"\\ufeff\\x00\\xff\\u07ff\\u0800\\uffff\",\n            [\n                \"\",\n                \"\",\n                \"\", # First BOM has been read and skipped\n                \"\",\n                \"\",\n                \"\\ufeff\", # Second BOM has been read and emitted\n                \"\\ufeff\\x00\", # \"\\x00\" read and emitted\n                \"\\ufeff\\x00\", # First byte of encoded \"\\xff\" read\n                \"\\ufeff\\x00\\xff\", # Second byte of encoded \"\\xff\" read\n                \"\\ufeff\\x00\\xff\", # First byte of encoded \"\\u07ff\" read\n                \"\\ufeff\\x00\\xff\\u07ff\", # Second byte of encoded \"\\u07ff\" read\n                \"\\ufeff\\x00\\xff\\u07ff\",\n                \"\\ufeff\\x00\\xff\\u07ff\",\n                \"\\ufeff\\x00\\xff\\u07ff\\u0800\",\n                \"\\ufeff\\x00\\xff\\u07ff\\u0800\",\n                \"\\ufeff\\x00\\xff\\u07ff\\u0800\",\n                \"\\ufeff\\x00\\xff\\u07ff\\u0800\\uffff\",\n            ]\n        )\n\n    def test_bug1601501(self):\n        # SF bug #1601501: check that the codec works with a buffer\n        self.assertEqual(str(b\"\\xef\\xbb\\xbf\", \"utf-8-sig\"), \"\")\n\n    def test_bom(self):\n        d = codecs.getincrementaldecoder(\"utf-8-sig\")()\n        s = \"spam\"\n        self.assertEqual(d.decode(s.encode(\"utf-8-sig\")), s)\n\n    def test_stream_bom(self):\n        unistring = \"ABC\\u00A1\\u2200XYZ\"\n        bytestring = codecs.BOM_UTF8 + b\"ABC\\xC2\\xA1\\xE2\\x88\\x80XYZ\"\n\n        reader = codecs.getreader(\"utf-8-sig\")\n        for sizehint in [None] + list(range(1, 11)) + \\\n                        [64, 128, 256, 512, 1024]:\n            istream = reader(io.BytesIO(bytestring))\n            ostream = io.StringIO()\n            while 1:\n                if sizehint is not None:\n                    data = istream.read(sizehint)\n                else:\n                    data = istream.read()\n\n                if not data:\n                    break\n                ostream.write(data)\n\n            got = ostream.getvalue()\n            self.assertEqual(got, unistring)\n\n    def test_stream_bare(self):\n        unistring = \"ABC\\u00A1\\u2200XYZ\"\n        bytestring = b\"ABC\\xC2\\xA1\\xE2\\x88\\x80XYZ\"\n\n        reader = codecs.getreader(\"utf-8-sig\")\n        for sizehint in [None] + list(range(1, 11)) + \\\n                        [64, 128, 256, 512, 1024]:\n            istream = reader(io.BytesIO(bytestring))\n            ostream = io.StringIO()\n            while 1:\n                if sizehint is not None:\n                    data = istream.read(sizehint)\n                else:\n                    data = istream.read()\n\n                if not data:\n                    break\n                ostream.write(data)\n\n            got = ostream.getvalue()\n            self.assertEqual(got, unistring)\n\nclass EscapeDecodeTest(unittest.TestCase):\n    def test_empty(self):\n        self.assertEqual(codecs.escape_decode(\"\"), (\"\", 0))\n\nclass RecodingTest(unittest.TestCase):\n    def test_recoding(self):\n        f = io.BytesIO()\n        f2 = codecs.EncodedFile(f, \"unicode_internal\", \"utf-8\")\n        f2.write(\"a\")\n        f2.close()\n        # Python used to crash on this at exit because of a refcount\n        # bug in _codecsmodule.c\n\n# From RFC 3492\npunycode_testcases = [\n    # A Arabic (Egyptian):\n    (\"\\u0644\\u064A\\u0647\\u0645\\u0627\\u0628\\u062A\\u0643\\u0644\"\n     \"\\u0645\\u0648\\u0634\\u0639\\u0631\\u0628\\u064A\\u061F\",\n     b\"egbpdaj6bu4bxfgehfvwxn\"),\n    # B Chinese (simplified):\n    (\"\\u4ED6\\u4EEC\\u4E3A\\u4EC0\\u4E48\\u4E0D\\u8BF4\\u4E2D\\u6587\",\n     b\"ihqwcrb4cv8a8dqg056pqjye\"),\n    # C Chinese (traditional):\n    (\"\\u4ED6\\u5011\\u7232\\u4EC0\\u9EBD\\u4E0D\\u8AAA\\u4E2D\\u6587\",\n     b\"ihqwctvzc91f659drss3x8bo0yb\"),\n    # D Czech: Pro<ccaron>prost<ecaron>nemluv<iacute><ccaron>esky\n    (\"\\u0050\\u0072\\u006F\\u010D\\u0070\\u0072\\u006F\\u0073\\u0074\"\n     \"\\u011B\\u006E\\u0065\\u006D\\u006C\\u0075\\u0076\\u00ED\\u010D\"\n     \"\\u0065\\u0073\\u006B\\u0079\",\n     b\"Proprostnemluvesky-uyb24dma41a\"),\n    # E Hebrew:\n    (\"\\u05DC\\u05DE\\u05D4\\u05D4\\u05DD\\u05E4\\u05E9\\u05D5\\u05D8\"\n     \"\\u05DC\\u05D0\\u05DE\\u05D3\\u05D1\\u05E8\\u05D9\\u05DD\\u05E2\"\n     \"\\u05D1\\u05E8\\u05D9\\u05EA\",\n     b\"4dbcagdahymbxekheh6e0a7fei0b\"),\n    # F Hindi (Devanagari):\n    (\"\\u092F\\u0939\\u0932\\u094B\\u0917\\u0939\\u093F\\u0928\\u094D\"\n     \"\\u0926\\u0940\\u0915\\u094D\\u092F\\u094B\\u0902\\u0928\\u0939\"\n     \"\\u0940\\u0902\\u092C\\u094B\\u0932\\u0938\\u0915\\u0924\\u0947\"\n     \"\\u0939\\u0948\\u0902\",\n     b\"i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd\"),\n\n    #(G) Japanese (kanji and hiragana):\n    (\"\\u306A\\u305C\\u307F\\u3093\\u306A\\u65E5\\u672C\\u8A9E\\u3092\"\n     \"\\u8A71\\u3057\\u3066\\u304F\\u308C\\u306A\\u3044\\u306E\\u304B\",\n     b\"n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa\"),\n\n    # (H) Korean (Hangul syllables):\n    (\"\\uC138\\uACC4\\uC758\\uBAA8\\uB4E0\\uC0AC\\uB78C\\uB4E4\\uC774\"\n     \"\\uD55C\\uAD6D\\uC5B4\\uB97C\\uC774\\uD574\\uD55C\\uB2E4\\uBA74\"\n     \"\\uC5BC\\uB9C8\\uB098\\uC88B\\uC744\\uAE4C\",\n     b\"989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j\"\n     b\"psd879ccm6fea98c\"),\n\n    # (I) Russian (Cyrillic):\n    (\"\\u043F\\u043E\\u0447\\u0435\\u043C\\u0443\\u0436\\u0435\\u043E\"\n     \"\\u043D\\u0438\\u043D\\u0435\\u0433\\u043E\\u0432\\u043E\\u0440\"\n     \"\\u044F\\u0442\\u043F\\u043E\\u0440\\u0443\\u0441\\u0441\\u043A\"\n     \"\\u0438\",\n     b\"b1abfaaepdrnnbgefbaDotcwatmq2g4l\"),\n\n    # (J) Spanish: Porqu<eacute>nopuedensimplementehablarenEspa<ntilde>ol\n    (\"\\u0050\\u006F\\u0072\\u0071\\u0075\\u00E9\\u006E\\u006F\\u0070\"\n     \"\\u0075\\u0065\\u0064\\u0065\\u006E\\u0073\\u0069\\u006D\\u0070\"\n     \"\\u006C\\u0065\\u006D\\u0065\\u006E\\u0074\\u0065\\u0068\\u0061\"\n     \"\\u0062\\u006C\\u0061\\u0072\\u0065\\u006E\\u0045\\u0073\\u0070\"\n     \"\\u0061\\u00F1\\u006F\\u006C\",\n     b\"PorqunopuedensimplementehablarenEspaol-fmd56a\"),\n\n    # (K) Vietnamese:\n    #  T<adotbelow>isaoh<odotbelow>kh<ocirc>ngth<ecirchookabove>ch\\\n    #   <ihookabove>n<oacute>iti<ecircacute>ngVi<ecircdotbelow>t\n    (\"\\u0054\\u1EA1\\u0069\\u0073\\u0061\\u006F\\u0068\\u1ECD\\u006B\"\n     \"\\u0068\\u00F4\\u006E\\u0067\\u0074\\u0068\\u1EC3\\u0063\\u0068\"\n     \"\\u1EC9\\u006E\\u00F3\\u0069\\u0074\\u0069\\u1EBF\\u006E\\u0067\"\n     \"\\u0056\\u0069\\u1EC7\\u0074\",\n     b\"TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g\"),\n\n    #(L) 3<nen>B<gumi><kinpachi><sensei>\n    (\"\\u0033\\u5E74\\u0042\\u7D44\\u91D1\\u516B\\u5148\\u751F\",\n     b\"3B-ww4c5e180e575a65lsy2b\"),\n\n    # (M) <amuro><namie>-with-SUPER-MONKEYS\n    (\"\\u5B89\\u5BA4\\u5948\\u7F8E\\u6075\\u002D\\u0077\\u0069\\u0074\"\n     \"\\u0068\\u002D\\u0053\\u0055\\u0050\\u0045\\u0052\\u002D\\u004D\"\n     \"\\u004F\\u004E\\u004B\\u0045\\u0059\\u0053\",\n     b\"-with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n\"),\n\n    # (N) Hello-Another-Way-<sorezore><no><basho>\n    (\"\\u0048\\u0065\\u006C\\u006C\\u006F\\u002D\\u0041\\u006E\\u006F\"\n     \"\\u0074\\u0068\\u0065\\u0072\\u002D\\u0057\\u0061\\u0079\\u002D\"\n     \"\\u305D\\u308C\\u305E\\u308C\\u306E\\u5834\\u6240\",\n     b\"Hello-Another-Way--fc4qua05auwb3674vfr0b\"),\n\n    # (O) <hitotsu><yane><no><shita>2\n    (\"\\u3072\\u3068\\u3064\\u5C4B\\u6839\\u306E\\u4E0B\\u0032\",\n     b\"2-u9tlzr9756bt3uc0v\"),\n\n    # (P) Maji<de>Koi<suru>5<byou><mae>\n    (\"\\u004D\\u0061\\u006A\\u0069\\u3067\\u004B\\u006F\\u0069\\u3059\"\n     \"\\u308B\\u0035\\u79D2\\u524D\",\n     b\"MajiKoi5-783gue6qz075azm5e\"),\n\n     # (Q) <pafii>de<runba>\n    (\"\\u30D1\\u30D5\\u30A3\\u30FC\\u0064\\u0065\\u30EB\\u30F3\\u30D0\",\n     b\"de-jg4avhby1noc0d\"),\n\n    # (R) <sono><supiido><de>\n    (\"\\u305D\\u306E\\u30B9\\u30D4\\u30FC\\u30C9\\u3067\",\n     b\"d9juau41awczczp\"),\n\n    # (S) -> $1.00 <-\n    (\"\\u002D\\u003E\\u0020\\u0024\\u0031\\u002E\\u0030\\u0030\\u0020\"\n     \"\\u003C\\u002D\",\n     b\"-> $1.00 <--\")\n    ]\n\nfor i in punycode_testcases:\n    if len(i)!=2:\n        print(repr(i))\n\nclass PunycodeTest(unittest.TestCase):\n    def test_encode(self):\n        for uni, puny in punycode_testcases:\n            # Need to convert both strings to lower case, since\n            # some of the extended encodings use upper case, but our\n            # code produces only lower case. Converting just puny to\n            # lower is also insufficient, since some of the input characters\n            # are upper case.\n            self.assertEqual(\n                str(uni.encode(\"punycode\"), \"ascii\").lower(),\n                str(puny, \"ascii\").lower()\n            )\n\n    def test_decode(self):\n        for uni, puny in punycode_testcases:\n            self.assertEqual(uni, puny.decode(\"punycode\"))\n            puny = puny.decode(\"ascii\").encode(\"ascii\")\n            self.assertEqual(uni, puny.decode(\"punycode\"))\n\nclass UnicodeInternalTest(unittest.TestCase):\n    def test_bug1251300(self):\n        # Decoding with unicode_internal used to not correctly handle \"code\n        # points\" above 0x10ffff on UCS-4 builds.\n        if sys.maxunicode > 0xffff:\n            ok = [\n                (b\"\\x00\\x10\\xff\\xff\", \"\\U0010ffff\"),\n                (b\"\\x00\\x00\\x01\\x01\", \"\\U00000101\"),\n                (b\"\", \"\"),\n            ]\n            not_ok = [\n                b\"\\x7f\\xff\\xff\\xff\",\n                b\"\\x80\\x00\\x00\\x00\",\n                b\"\\x81\\x00\\x00\\x00\",\n                b\"\\x00\",\n                b\"\\x00\\x00\\x00\\x00\\x00\",\n            ]\n            for internal, uni in ok:\n                if sys.byteorder == \"little\":\n                    internal = bytes(reversed(internal))\n                self.assertEqual(uni, internal.decode(\"unicode_internal\"))\n            for internal in not_ok:\n                if sys.byteorder == \"little\":\n                    internal = bytes(reversed(internal))\n                self.assertRaises(UnicodeDecodeError, internal.decode,\n                    \"unicode_internal\")\n\n    def test_decode_error_attributes(self):\n        if sys.maxunicode > 0xffff:\n            try:\n                b\"\\x00\\x00\\x00\\x00\\x00\\x11\\x11\\x00\".decode(\"unicode_internal\")\n            except UnicodeDecodeError as ex:\n                self.assertEqual(\"unicode_internal\", ex.encoding)\n                self.assertEqual(b\"\\x00\\x00\\x00\\x00\\x00\\x11\\x11\\x00\", ex.object)\n                self.assertEqual(4, ex.start)\n                self.assertEqual(8, ex.end)\n            else:\n                self.fail()\n\n    def test_decode_callback(self):\n        if sys.maxunicode > 0xffff:\n            codecs.register_error(\"UnicodeInternalTest\", codecs.ignore_errors)\n            decoder = codecs.getdecoder(\"unicode_internal\")\n            ab = \"ab\".encode(\"unicode_internal\").decode()\n            ignored = decoder(bytes(\"%s\\x22\\x22\\x22\\x22%s\" % (ab[:4], ab[4:]),\n                                    \"ascii\"),\n                              \"UnicodeInternalTest\")\n            self.assertEqual((\"ab\", 12), ignored)\n\n    def test_encode_length(self):\n        # Issue 3739\n        encoder = codecs.getencoder(\"unicode_internal\")\n        self.assertEqual(encoder(\"a\")[1], 1)\n        self.assertEqual(encoder(\"\\xe9\\u0142\")[1], 2)\n\n        self.assertEqual(codecs.escape_encode(br'\\x00')[1], 4)\n\n# From http://www.gnu.org/software/libidn/draft-josefsson-idn-test-vectors.html\nnameprep_tests = [\n    # 3.1 Map to nothing.\n    (b'foo\\xc2\\xad\\xcd\\x8f\\xe1\\xa0\\x86\\xe1\\xa0\\x8bbar'\n     b'\\xe2\\x80\\x8b\\xe2\\x81\\xa0baz\\xef\\xb8\\x80\\xef\\xb8\\x88\\xef'\n     b'\\xb8\\x8f\\xef\\xbb\\xbf',\n     b'foobarbaz'),\n    # 3.2 Case folding ASCII U+0043 U+0041 U+0046 U+0045.\n    (b'CAFE',\n     b'cafe'),\n    # 3.3 Case folding 8bit U+00DF (german sharp s).\n    # The original test case is bogus; it says \\xc3\\xdf\n    (b'\\xc3\\x9f',\n     b'ss'),\n    # 3.4 Case folding U+0130 (turkish capital I with dot).\n    (b'\\xc4\\xb0',\n     b'i\\xcc\\x87'),\n    # 3.5 Case folding multibyte U+0143 U+037A.\n    (b'\\xc5\\x83\\xcd\\xba',\n     b'\\xc5\\x84 \\xce\\xb9'),\n    # 3.6 Case folding U+2121 U+33C6 U+1D7BB.\n    # XXX: skip this as it fails in UCS-2 mode\n    #('\\xe2\\x84\\xa1\\xe3\\x8f\\x86\\xf0\\x9d\\x9e\\xbb',\n    # 'telc\\xe2\\x88\\x95kg\\xcf\\x83'),\n    (None, None),\n    # 3.7 Normalization of U+006a U+030c U+00A0 U+00AA.\n    (b'j\\xcc\\x8c\\xc2\\xa0\\xc2\\xaa',\n     b'\\xc7\\xb0 a'),\n    # 3.8 Case folding U+1FB7 and normalization.\n    (b'\\xe1\\xbe\\xb7',\n     b'\\xe1\\xbe\\xb6\\xce\\xb9'),\n    # 3.9 Self-reverting case folding U+01F0 and normalization.\n    # The original test case is bogus, it says `\\xc7\\xf0'\n    (b'\\xc7\\xb0',\n     b'\\xc7\\xb0'),\n    # 3.10 Self-reverting case folding U+0390 and normalization.\n    (b'\\xce\\x90',\n     b'\\xce\\x90'),\n    # 3.11 Self-reverting case folding U+03B0 and normalization.\n    (b'\\xce\\xb0',\n     b'\\xce\\xb0'),\n    # 3.12 Self-reverting case folding U+1E96 and normalization.\n    (b'\\xe1\\xba\\x96',\n     b'\\xe1\\xba\\x96'),\n    # 3.13 Self-reverting case folding U+1F56 and normalization.\n    (b'\\xe1\\xbd\\x96',\n     b'\\xe1\\xbd\\x96'),\n    # 3.14 ASCII space character U+0020.\n    (b' ',\n     b' '),\n    # 3.15 Non-ASCII 8bit space character U+00A0.\n    (b'\\xc2\\xa0',\n     b' '),\n    # 3.16 Non-ASCII multibyte space character U+1680.\n    (b'\\xe1\\x9a\\x80',\n     None),\n    # 3.17 Non-ASCII multibyte space character U+2000.\n    (b'\\xe2\\x80\\x80',\n     b' '),\n    # 3.18 Zero Width Space U+200b.\n    (b'\\xe2\\x80\\x8b',\n     b''),\n    # 3.19 Non-ASCII multibyte space character U+3000.\n    (b'\\xe3\\x80\\x80',\n     b' '),\n    # 3.20 ASCII control characters U+0010 U+007F.\n    (b'\\x10\\x7f',\n     b'\\x10\\x7f'),\n    # 3.21 Non-ASCII 8bit control character U+0085.\n    (b'\\xc2\\x85',\n     None),\n    # 3.22 Non-ASCII multibyte control character U+180E.\n    (b'\\xe1\\xa0\\x8e',\n     None),\n    # 3.23 Zero Width No-Break Space U+FEFF.\n    (b'\\xef\\xbb\\xbf',\n     b''),\n    # 3.24 Non-ASCII control character U+1D175.\n    (b'\\xf0\\x9d\\x85\\xb5',\n     None),\n    # 3.25 Plane 0 private use character U+F123.\n    (b'\\xef\\x84\\xa3',\n     None),\n    # 3.26 Plane 15 private use character U+F1234.\n    (b'\\xf3\\xb1\\x88\\xb4',\n     None),\n    # 3.27 Plane 16 private use character U+10F234.\n    (b'\\xf4\\x8f\\x88\\xb4',\n     None),\n    # 3.28 Non-character code point U+8FFFE.\n    (b'\\xf2\\x8f\\xbf\\xbe',\n     None),\n    # 3.29 Non-character code point U+10FFFF.\n    (b'\\xf4\\x8f\\xbf\\xbf',\n     None),\n    # 3.30 Surrogate code U+DF42.\n    (b'\\xed\\xbd\\x82',\n     None),\n    # 3.31 Non-plain text character U+FFFD.\n    (b'\\xef\\xbf\\xbd',\n     None),\n    # 3.32 Ideographic description character U+2FF5.\n    (b'\\xe2\\xbf\\xb5',\n     None),\n    # 3.33 Display property character U+0341.\n    (b'\\xcd\\x81',\n     b'\\xcc\\x81'),\n    # 3.34 Left-to-right mark U+200E.\n    (b'\\xe2\\x80\\x8e',\n     None),\n    # 3.35 Deprecated U+202A.\n    (b'\\xe2\\x80\\xaa',\n     None),\n    # 3.36 Language tagging character U+E0001.\n    (b'\\xf3\\xa0\\x80\\x81',\n     None),\n    # 3.37 Language tagging character U+E0042.\n    (b'\\xf3\\xa0\\x81\\x82',\n     None),\n    # 3.38 Bidi: RandALCat character U+05BE and LCat characters.\n    (b'foo\\xd6\\xbebar',\n     None),\n    # 3.39 Bidi: RandALCat character U+FD50 and LCat characters.\n    (b'foo\\xef\\xb5\\x90bar',\n     None),\n    # 3.40 Bidi: RandALCat character U+FB38 and LCat characters.\n    (b'foo\\xef\\xb9\\xb6bar',\n     b'foo \\xd9\\x8ebar'),\n    # 3.41 Bidi: RandALCat without trailing RandALCat U+0627 U+0031.\n    (b'\\xd8\\xa71',\n     None),\n    # 3.42 Bidi: RandALCat character U+0627 U+0031 U+0628.\n    (b'\\xd8\\xa71\\xd8\\xa8',\n     b'\\xd8\\xa71\\xd8\\xa8'),\n    # 3.43 Unassigned code point U+E0002.\n    # Skip this test as we allow unassigned\n    #(b'\\xf3\\xa0\\x80\\x82',\n    # None),\n    (None, None),\n    # 3.44 Larger test (shrinking).\n    # Original test case reads \\xc3\\xdf\n    (b'X\\xc2\\xad\\xc3\\x9f\\xc4\\xb0\\xe2\\x84\\xa1j\\xcc\\x8c\\xc2\\xa0\\xc2'\n     b'\\xaa\\xce\\xb0\\xe2\\x80\\x80',\n     b'xssi\\xcc\\x87tel\\xc7\\xb0 a\\xce\\xb0 '),\n    # 3.45 Larger test (expanding).\n    # Original test case reads \\xc3\\x9f\n    (b'X\\xc3\\x9f\\xe3\\x8c\\x96\\xc4\\xb0\\xe2\\x84\\xa1\\xe2\\x92\\x9f\\xe3\\x8c'\n     b'\\x80',\n     b'xss\\xe3\\x82\\xad\\xe3\\x83\\xad\\xe3\\x83\\xa1\\xe3\\x83\\xbc\\xe3'\n     b'\\x83\\x88\\xe3\\x83\\xabi\\xcc\\x87tel\\x28d\\x29\\xe3\\x82'\n     b'\\xa2\\xe3\\x83\\x91\\xe3\\x83\\xbc\\xe3\\x83\\x88')\n    ]\n\n\nclass NameprepTest(unittest.TestCase):\n    def test_nameprep(self):\n        from encodings.idna import nameprep\n        for pos, (orig, prepped) in enumerate(nameprep_tests):\n            if orig is None:\n                # Skipped\n                continue\n            # The Unicode strings are given in UTF-8\n            orig = str(orig, \"utf-8\", \"surrogatepass\")\n            if prepped is None:\n                # Input contains prohibited characters\n                self.assertRaises(UnicodeError, nameprep, orig)\n            else:\n                prepped = str(prepped, \"utf-8\", \"surrogatepass\")\n                try:\n                    self.assertEqual(nameprep(orig), prepped)\n                except Exception as e:\n                    raise support.TestFailed(\"Test 3.%d: %s\" % (pos+1, str(e)))\n\nclass IDNACodecTest(unittest.TestCase):\n    def test_builtin_decode(self):\n        self.assertEqual(str(b\"python.org\", \"idna\"), \"python.org\")\n        self.assertEqual(str(b\"python.org.\", \"idna\"), \"python.org.\")\n        self.assertEqual(str(b\"xn--pythn-mua.org\", \"idna\"), \"pyth\\xf6n.org\")\n        self.assertEqual(str(b\"xn--pythn-mua.org.\", \"idna\"), \"pyth\\xf6n.org.\")\n\n    def test_builtin_encode(self):\n        self.assertEqual(\"python.org\".encode(\"idna\"), b\"python.org\")\n        self.assertEqual(\"python.org.\".encode(\"idna\"), b\"python.org.\")\n        self.assertEqual(\"pyth\\xf6n.org\".encode(\"idna\"), b\"xn--pythn-mua.org\")\n        self.assertEqual(\"pyth\\xf6n.org.\".encode(\"idna\"), b\"xn--pythn-mua.org.\")\n\n    def test_stream(self):\n        r = codecs.getreader(\"idna\")(io.BytesIO(b\"abc\"))\n        r.read(3)\n        self.assertEqual(r.read(), \"\")\n\n    def test_incremental_decode(self):\n        self.assertEqual(\n            \"\".join(codecs.iterdecode((bytes([c]) for c in b\"python.org\"), \"idna\")),\n            \"python.org\"\n        )\n        self.assertEqual(\n            \"\".join(codecs.iterdecode((bytes([c]) for c in b\"python.org.\"), \"idna\")),\n            \"python.org.\"\n        )\n        self.assertEqual(\n            \"\".join(codecs.iterdecode((bytes([c]) for c in b\"xn--pythn-mua.org.\"), \"idna\")),\n            \"pyth\\xf6n.org.\"\n        )\n        self.assertEqual(\n            \"\".join(codecs.iterdecode((bytes([c]) for c in b\"xn--pythn-mua.org.\"), \"idna\")),\n            \"pyth\\xf6n.org.\"\n        )\n\n        decoder = codecs.getincrementaldecoder(\"idna\")()\n        self.assertEqual(decoder.decode(b\"xn--xam\", ), \"\")\n        self.assertEqual(decoder.decode(b\"ple-9ta.o\", ), \"\\xe4xample.\")\n        self.assertEqual(decoder.decode(b\"rg\"), \"\")\n        self.assertEqual(decoder.decode(b\"\", True), \"org\")\n\n        decoder.reset()\n        self.assertEqual(decoder.decode(b\"xn--xam\", ), \"\")\n        self.assertEqual(decoder.decode(b\"ple-9ta.o\", ), \"\\xe4xample.\")\n        self.assertEqual(decoder.decode(b\"rg.\"), \"org.\")\n        self.assertEqual(decoder.decode(b\"\", True), \"\")\n\n    def test_incremental_encode(self):\n        self.assertEqual(\n            b\"\".join(codecs.iterencode(\"python.org\", \"idna\")),\n            b\"python.org\"\n        )\n        self.assertEqual(\n            b\"\".join(codecs.iterencode(\"python.org.\", \"idna\")),\n            b\"python.org.\"\n        )\n        self.assertEqual(\n            b\"\".join(codecs.iterencode(\"pyth\\xf6n.org.\", \"idna\")),\n            b\"xn--pythn-mua.org.\"\n        )\n        self.assertEqual(\n            b\"\".join(codecs.iterencode(\"pyth\\xf6n.org.\", \"idna\")),\n            b\"xn--pythn-mua.org.\"\n        )\n\n        encoder = codecs.getincrementalencoder(\"idna\")()\n        self.assertEqual(encoder.encode(\"\\xe4x\"), b\"\")\n        self.assertEqual(encoder.encode(\"ample.org\"), b\"xn--xample-9ta.\")\n        self.assertEqual(encoder.encode(\"\", True), b\"org\")\n\n        encoder.reset()\n        self.assertEqual(encoder.encode(\"\\xe4x\"), b\"\")\n        self.assertEqual(encoder.encode(\"ample.org.\"), b\"xn--xample-9ta.org.\")\n        self.assertEqual(encoder.encode(\"\", True), b\"\")\n\nclass CodecsModuleTest(unittest.TestCase):\n\n    def test_decode(self):\n        self.assertEqual(codecs.decode(b'\\xe4\\xf6\\xfc', 'latin-1'),\n                         '\\xe4\\xf6\\xfc')\n        self.assertRaises(TypeError, codecs.decode)\n        self.assertEqual(codecs.decode(b'abc'), 'abc')\n        self.assertRaises(UnicodeDecodeError, codecs.decode, b'\\xff', 'ascii')\n\n    def test_encode(self):\n        self.assertEqual(codecs.encode('\\xe4\\xf6\\xfc', 'latin-1'),\n                         b'\\xe4\\xf6\\xfc')\n        self.assertRaises(TypeError, codecs.encode)\n        self.assertRaises(LookupError, codecs.encode, \"foo\", \"__spam__\")\n        self.assertEqual(codecs.encode('abc'), b'abc')\n        self.assertRaises(UnicodeEncodeError, codecs.encode, '\\xffff', 'ascii')\n\n    def test_register(self):\n        self.assertRaises(TypeError, codecs.register)\n        self.assertRaises(TypeError, codecs.register, 42)\n\n    def test_lookup(self):\n        self.assertRaises(TypeError, codecs.lookup)\n        self.assertRaises(LookupError, codecs.lookup, \"__spam__\")\n        self.assertRaises(LookupError, codecs.lookup, \" \")\n\n    def test_getencoder(self):\n        self.assertRaises(TypeError, codecs.getencoder)\n        self.assertRaises(LookupError, codecs.getencoder, \"__spam__\")\n\n    def test_getdecoder(self):\n        self.assertRaises(TypeError, codecs.getdecoder)\n        self.assertRaises(LookupError, codecs.getdecoder, \"__spam__\")\n\n    def test_getreader(self):\n        self.assertRaises(TypeError, codecs.getreader)\n        self.assertRaises(LookupError, codecs.getreader, \"__spam__\")\n\n    def test_getwriter(self):\n        self.assertRaises(TypeError, codecs.getwriter)\n        self.assertRaises(LookupError, codecs.getwriter, \"__spam__\")\n\n    def test_lookup_issue1813(self):\n        # Issue #1813: under Turkish locales, lookup of some codecs failed\n        # because 'I' is lowercased as \"\u0131\" (dotless i)\n        oldlocale = locale.setlocale(locale.LC_CTYPE)\n        self.addCleanup(locale.setlocale, locale.LC_CTYPE, oldlocale)\n        try:\n            locale.setlocale(locale.LC_CTYPE, 'tr_TR')\n        except locale.Error:\n            # Unsupported locale on this system\n            self.skipTest('test needs Turkish locale')\n        c = codecs.lookup('ASCII')\n        self.assertEqual(c.name, 'ascii')\n\nclass StreamReaderTest(unittest.TestCase):\n\n    def setUp(self):\n        self.reader = codecs.getreader('utf-8')\n        self.stream = io.BytesIO(b'\\xed\\x95\\x9c\\n\\xea\\xb8\\x80')\n\n    def test_readlines(self):\n        f = self.reader(self.stream)\n        self.assertEqual(f.readlines(), ['\\ud55c\\n', '\\uae00'])\n\nclass EncodedFileTest(unittest.TestCase):\n\n    def test_basic(self):\n        f = io.BytesIO(b'\\xed\\x95\\x9c\\n\\xea\\xb8\\x80')\n        ef = codecs.EncodedFile(f, 'utf-16-le', 'utf-8')\n        self.assertEqual(ef.read(), b'\\\\\\xd5\\n\\x00\\x00\\xae')\n\n        f = io.BytesIO()\n        ef = codecs.EncodedFile(f, 'utf-8', 'latin1')\n        ef.write(b'\\xc3\\xbc')\n        self.assertEqual(f.getvalue(), b'\\xfc')\n\nall_unicode_encodings = [\n    \"ascii\",\n    \"big5\",\n    \"big5hkscs\",\n    \"charmap\",\n    \"cp037\",\n    \"cp1006\",\n    \"cp1026\",\n    \"cp1140\",\n    \"cp1250\",\n    \"cp1251\",\n    \"cp1252\",\n    \"cp1253\",\n    \"cp1254\",\n    \"cp1255\",\n    \"cp1256\",\n    \"cp1257\",\n    \"cp1258\",\n    \"cp424\",\n    \"cp437\",\n    \"cp500\",\n    \"cp720\",\n    \"cp737\",\n    \"cp775\",\n    \"cp850\",\n    \"cp852\",\n    \"cp855\",\n    \"cp856\",\n    \"cp857\",\n    \"cp858\",\n    \"cp860\",\n    \"cp861\",\n    \"cp862\",\n    \"cp863\",\n    \"cp864\",\n    \"cp865\",\n    \"cp866\",\n    \"cp869\",\n    \"cp874\",\n    \"cp875\",\n    \"cp932\",\n    \"cp949\",\n    \"cp950\",\n    \"euc_jis_2004\",\n    \"euc_jisx0213\",\n    \"euc_jp\",\n    \"euc_kr\",\n    \"gb18030\",\n    \"gb2312\",\n    \"gbk\",\n    \"hp_roman8\",\n    \"hz\",\n    \"idna\",\n    \"iso2022_jp\",\n    \"iso2022_jp_1\",\n    \"iso2022_jp_2\",\n    \"iso2022_jp_2004\",\n    \"iso2022_jp_3\",\n    \"iso2022_jp_ext\",\n    \"iso2022_kr\",\n    \"iso8859_1\",\n    \"iso8859_10\",\n    \"iso8859_11\",\n    \"iso8859_13\",\n    \"iso8859_14\",\n    \"iso8859_15\",\n    \"iso8859_16\",\n    \"iso8859_2\",\n    \"iso8859_3\",\n    \"iso8859_4\",\n    \"iso8859_5\",\n    \"iso8859_6\",\n    \"iso8859_7\",\n    \"iso8859_8\",\n    \"iso8859_9\",\n    \"johab\",\n    \"koi8_r\",\n    \"koi8_u\",\n    \"latin_1\",\n    \"mac_cyrillic\",\n    \"mac_greek\",\n    \"mac_iceland\",\n    \"mac_latin2\",\n    \"mac_roman\",\n    \"mac_turkish\",\n    \"palmos\",\n    \"ptcp154\",\n    \"punycode\",\n    \"raw_unicode_escape\",\n    \"shift_jis\",\n    \"shift_jis_2004\",\n    \"shift_jisx0213\",\n    \"tis_620\",\n    \"unicode_escape\",\n    \"unicode_internal\",\n    \"utf_16\",\n    \"utf_16_be\",\n    \"utf_16_le\",\n    \"utf_7\",\n    \"utf_8\",\n]\n\nif hasattr(codecs, \"mbcs_encode\"):\n    all_unicode_encodings.append(\"mbcs\")\n\n# The following encoding is not tested, because it's not supposed\n# to work:\n#    \"undefined\"\n\n# The following encodings don't work in stateful mode\nbroken_unicode_with_streams = [\n    \"punycode\",\n    \"unicode_internal\"\n]\nbroken_incremental_coders = broken_unicode_with_streams + [\n    \"idna\",\n]\n\nclass BasicUnicodeTest(unittest.TestCase, MixInCheckStateHandling):\n    def test_basics(self):\n        s = \"abc123\" # all codecs should be able to encode these\n        for encoding in all_unicode_encodings:\n            name = codecs.lookup(encoding).name\n            if encoding.endswith(\"_codec\"):\n                name += \"_codec\"\n            elif encoding == \"latin_1\":\n                name = \"latin_1\"\n            self.assertEqual(encoding.replace(\"_\", \"-\"), name.replace(\"_\", \"-\"))\n            (b, size) = codecs.getencoder(encoding)(s)\n            self.assertEqual(size, len(s), \"%r != %r (encoding=%r)\" % (size, len(s), encoding))\n            (chars, size) = codecs.getdecoder(encoding)(b)\n            self.assertEqual(chars, s, \"%r != %r (encoding=%r)\" % (chars, s, encoding))\n\n            if encoding not in broken_unicode_with_streams:\n                # check stream reader/writer\n                q = Queue(b\"\")\n                writer = codecs.getwriter(encoding)(q)\n                encodedresult = b\"\"\n                for c in s:\n                    writer.write(c)\n                    chunk = q.read()\n                    self.assertTrue(type(chunk) is bytes, type(chunk))\n                    encodedresult += chunk\n                q = Queue(b\"\")\n                reader = codecs.getreader(encoding)(q)\n                decodedresult = \"\"\n                for c in encodedresult:\n                    q.write(bytes([c]))\n                    decodedresult += reader.read()\n                self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n            if encoding not in broken_incremental_coders:\n                # check incremental decoder/encoder (fetched via the Python\n                # and C API) and iterencode()/iterdecode()\n                try:\n                    encoder = codecs.getincrementalencoder(encoding)()\n                    cencoder = _testcapi.codec_incrementalencoder(encoding)\n                except LookupError: # no IncrementalEncoder\n                    pass\n                else:\n                    # check incremental decoder/encoder\n                    encodedresult = b\"\"\n                    for c in s:\n                        encodedresult += encoder.encode(c)\n                    encodedresult += encoder.encode(\"\", True)\n                    decoder = codecs.getincrementaldecoder(encoding)()\n                    decodedresult = \"\"\n                    for c in encodedresult:\n                        decodedresult += decoder.decode(bytes([c]))\n                    decodedresult += decoder.decode(b\"\", True)\n                    self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n                    # check C API\n                    encodedresult = b\"\"\n                    for c in s:\n                        encodedresult += cencoder.encode(c)\n                    encodedresult += cencoder.encode(\"\", True)\n                    cdecoder = _testcapi.codec_incrementaldecoder(encoding)\n                    decodedresult = \"\"\n                    for c in encodedresult:\n                        decodedresult += cdecoder.decode(bytes([c]))\n                    decodedresult += cdecoder.decode(b\"\", True)\n                    self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n                    # check iterencode()/iterdecode()\n                    result = \"\".join(codecs.iterdecode(codecs.iterencode(s, encoding), encoding))\n                    self.assertEqual(result, s, \"%r != %r (encoding=%r)\" % (result, s, encoding))\n\n                    # check iterencode()/iterdecode() with empty string\n                    result = \"\".join(codecs.iterdecode(codecs.iterencode(\"\", encoding), encoding))\n                    self.assertEqual(result, \"\")\n\n                if encoding not in (\"idna\", \"mbcs\"):\n                    # check incremental decoder/encoder with errors argument\n                    try:\n                        encoder = codecs.getincrementalencoder(encoding)(\"ignore\")\n                        cencoder = _testcapi.codec_incrementalencoder(encoding, \"ignore\")\n                    except LookupError: # no IncrementalEncoder\n                        pass\n                    else:\n                        encodedresult = b\"\".join(encoder.encode(c) for c in s)\n                        decoder = codecs.getincrementaldecoder(encoding)(\"ignore\")\n                        decodedresult = \"\".join(decoder.decode(bytes([c])) for c in encodedresult)\n                        self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n                        encodedresult = b\"\".join(cencoder.encode(c) for c in s)\n                        cdecoder = _testcapi.codec_incrementaldecoder(encoding, \"ignore\")\n                        decodedresult = \"\".join(cdecoder.decode(bytes([c])) for c in encodedresult)\n                        self.assertEqual(decodedresult, s, \"%r != %r (encoding=%r)\" % (decodedresult, s, encoding))\n\n    def test_seek(self):\n        # all codecs should be able to encode these\n        s = \"%s\\n%s\\n\" % (100*\"abc123\", 100*\"def456\")\n        for encoding in all_unicode_encodings:\n            if encoding == \"idna\": # FIXME: See SF bug #1163178\n                continue\n            if encoding in broken_unicode_with_streams:\n                continue\n            reader = codecs.getreader(encoding)(io.BytesIO(s.encode(encoding)))\n            for t in range(5):\n                # Test that calling seek resets the internal codec state and buffers\n                reader.seek(0, 0)\n                data = reader.read()\n                self.assertEqual(s, data)\n\n    def test_bad_decode_args(self):\n        for encoding in all_unicode_encodings:\n            decoder = codecs.getdecoder(encoding)\n            self.assertRaises(TypeError, decoder)\n            if encoding not in (\"idna\", \"punycode\"):\n                self.assertRaises(TypeError, decoder, 42)\n\n    def test_bad_encode_args(self):\n        for encoding in all_unicode_encodings:\n            encoder = codecs.getencoder(encoding)\n            self.assertRaises(TypeError, encoder)\n\n    def test_encoding_map_type_initialized(self):\n        from encodings import cp1140\n        # This used to crash, we are only verifying there's no crash.\n        table_type = type(cp1140.encoding_table)\n        self.assertEqual(table_type, table_type)\n\n    def test_decoder_state(self):\n        # Check that getstate() and setstate() handle the state properly\n        u = \"abc123\"\n        for encoding in all_unicode_encodings:\n            if encoding not in broken_incremental_coders:\n                self.check_state_handling_decode(encoding, u, u.encode(encoding))\n                self.check_state_handling_encode(encoding, u, u.encode(encoding))\n\nclass CharmapTest(unittest.TestCase):\n    def test_decode_with_string_map(self):\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"strict\", \"abc\"),\n            (\"abc\", 3)\n        )\n\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"replace\", \"ab\"),\n            (\"ab\\ufffd\", 3)\n        )\n\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"replace\", \"ab\\ufffe\"),\n            (\"ab\\ufffd\", 3)\n        )\n\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"ignore\", \"ab\"),\n            (\"ab\", 3)\n        )\n\n        self.assertEqual(\n            codecs.charmap_decode(b\"\\x00\\x01\\x02\", \"ignore\", \"ab\\ufffe\"),\n            (\"ab\", 3)\n        )\n\n        allbytes = bytes(range(256))\n        self.assertEqual(\n            codecs.charmap_decode(allbytes, \"ignore\", \"\"),\n            (\"\", len(allbytes))\n        )\n\nclass WithStmtTest(unittest.TestCase):\n    def test_encodedfile(self):\n        f = io.BytesIO(b\"\\xc3\\xbc\")\n        with codecs.EncodedFile(f, \"latin-1\", \"utf-8\") as ef:\n            self.assertEqual(ef.read(), b\"\\xfc\")\n\n    def test_streamreaderwriter(self):\n        f = io.BytesIO(b\"\\xc3\\xbc\")\n        info = codecs.lookup(\"utf-8\")\n        with codecs.StreamReaderWriter(f, info.streamreader,\n                                       info.streamwriter, 'strict') as srw:\n            self.assertEqual(srw.read(), \"\\xfc\")\n\nclass TypesTest(unittest.TestCase):\n    def test_decode_unicode(self):\n        # Most decoders don't accept unicode input\n        decoders = [\n            codecs.utf_7_decode,\n            codecs.utf_8_decode,\n            codecs.utf_16_le_decode,\n            codecs.utf_16_be_decode,\n            codecs.utf_16_ex_decode,\n            codecs.utf_32_decode,\n            codecs.utf_32_le_decode,\n            codecs.utf_32_be_decode,\n            codecs.utf_32_ex_decode,\n            codecs.latin_1_decode,\n            codecs.ascii_decode,\n            codecs.charmap_decode,\n        ]\n        if hasattr(codecs, \"mbcs_decode\"):\n            decoders.append(codecs.mbcs_decode)\n        for decoder in decoders:\n            self.assertRaises(TypeError, decoder, \"xxx\")\n\n    def test_unicode_escape(self):\n        # Escape-decoding an unicode string is supported ang gives the same\n        # result as decoding the equivalent ASCII bytes string.\n        self.assertEqual(codecs.unicode_escape_decode(r\"\\u1234\"), (\"\\u1234\", 6))\n        self.assertEqual(codecs.unicode_escape_decode(br\"\\u1234\"), (\"\\u1234\", 6))\n        self.assertEqual(codecs.raw_unicode_escape_decode(r\"\\u1234\"), (\"\\u1234\", 6))\n        self.assertEqual(codecs.raw_unicode_escape_decode(br\"\\u1234\"), (\"\\u1234\", 6))\n\nclass SurrogateEscapeTest(unittest.TestCase):\n\n    def test_utf8(self):\n        # Bad byte\n        self.assertEqual(b\"foo\\x80bar\".decode(\"utf-8\", \"surrogateescape\"),\n                         \"foo\\udc80bar\")\n        self.assertEqual(\"foo\\udc80bar\".encode(\"utf-8\", \"surrogateescape\"),\n                         b\"foo\\x80bar\")\n        # bad-utf-8 encoded surrogate\n        self.assertEqual(b\"\\xed\\xb0\\x80\".decode(\"utf-8\", \"surrogateescape\"),\n                         \"\\udced\\udcb0\\udc80\")\n        self.assertEqual(\"\\udced\\udcb0\\udc80\".encode(\"utf-8\", \"surrogateescape\"),\n                         b\"\\xed\\xb0\\x80\")\n\n    def test_ascii(self):\n        # bad byte\n        self.assertEqual(b\"foo\\x80bar\".decode(\"ascii\", \"surrogateescape\"),\n                         \"foo\\udc80bar\")\n        self.assertEqual(\"foo\\udc80bar\".encode(\"ascii\", \"surrogateescape\"),\n                         b\"foo\\x80bar\")\n\n    def test_charmap(self):\n        # bad byte: \\xa5 is unmapped in iso-8859-3\n        self.assertEqual(b\"foo\\xa5bar\".decode(\"iso-8859-3\", \"surrogateescape\"),\n                         \"foo\\udca5bar\")\n        self.assertEqual(\"foo\\udca5bar\".encode(\"iso-8859-3\", \"surrogateescape\"),\n                         b\"foo\\xa5bar\")\n\n    def test_latin1(self):\n        # Issue6373\n        self.assertEqual(\"\\udce4\\udceb\\udcef\\udcf6\\udcfc\".encode(\"latin1\", \"surrogateescape\"),\n                         b\"\\xe4\\xeb\\xef\\xf6\\xfc\")\n\n\nclass BomTest(unittest.TestCase):\n    def test_seek0(self):\n        data = \"1234567890\"\n        tests = (\"utf-16\",\n                 \"utf-16-le\",\n                 \"utf-16-be\",\n                 \"utf-32\",\n                 \"utf-32-le\",\n                 \"utf-32-be\")\n        self.addCleanup(support.unlink, support.TESTFN)\n        for encoding in tests:\n            # Check if the BOM is written only once\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.write(data)\n                f.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data * 2)\n                f.seek(0)\n                self.assertEqual(f.read(), data * 2)\n\n            # Check that the BOM is written after a seek(0)\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.write(data[0])\n                self.assertNotEqual(f.tell(), 0)\n                f.seek(0)\n                f.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data)\n\n            # (StreamWriter) Check that the BOM is written after a seek(0)\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.writer.write(data[0])\n                self.assertNotEqual(f.writer.tell(), 0)\n                f.writer.seek(0)\n                f.writer.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data)\n\n            # Check that the BOM is not written after a seek() at a position\n            # different than the start\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.write(data)\n                f.seek(f.tell())\n                f.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data * 2)\n\n            # (StreamWriter) Check that the BOM is not written after a seek()\n            # at a position different than the start\n            with codecs.open(support.TESTFN, 'w+', encoding=encoding) as f:\n                f.writer.write(data)\n                f.writer.seek(f.writer.tell())\n                f.writer.write(data)\n                f.seek(0)\n                self.assertEqual(f.read(), data * 2)\n\n\nbytes_transform_encodings = [\n    \"base64_codec\",\n    \"uu_codec\",\n    \"quopri_codec\",\n    \"hex_codec\",\n]\ntry:\n    import zlib\nexcept ImportError:\n    pass\nelse:\n    bytes_transform_encodings.append(\"zlib_codec\")\ntry:\n    import bz2\nexcept ImportError:\n    pass\nelse:\n    bytes_transform_encodings.append(\"bz2_codec\")\n\nclass TransformCodecTest(unittest.TestCase):\n\n    def test_basics(self):\n        binput = bytes(range(256))\n        for encoding in bytes_transform_encodings:\n            # generic codecs interface\n            (o, size) = codecs.getencoder(encoding)(binput)\n            self.assertEqual(size, len(binput))\n            (i, size) = codecs.getdecoder(encoding)(o)\n            self.assertEqual(size, len(o))\n            self.assertEqual(i, binput)\n\n    def test_read(self):\n        for encoding in bytes_transform_encodings:\n            sin = codecs.encode(b\"\\x80\", encoding)\n            reader = codecs.getreader(encoding)(io.BytesIO(sin))\n            sout = reader.read()\n            self.assertEqual(sout, b\"\\x80\")\n\n    def test_readline(self):\n        for encoding in bytes_transform_encodings:\n            if encoding in ['uu_codec', 'zlib_codec']:\n                continue\n            sin = codecs.encode(b\"\\x80\", encoding)\n            reader = codecs.getreader(encoding)(io.BytesIO(sin))\n            sout = reader.readline()\n            self.assertEqual(sout, b\"\\x80\")\n\n\ndef test_main():\n    support.run_unittest(\n        UTF32Test,\n        UTF32LETest,\n        UTF32BETest,\n        UTF16Test,\n        UTF16LETest,\n        UTF16BETest,\n        UTF8Test,\n        UTF8SigTest,\n        UTF7Test,\n        UTF16ExTest,\n        ReadBufferTest,\n        RecodingTest,\n        PunycodeTest,\n        UnicodeInternalTest,\n        NameprepTest,\n        IDNACodecTest,\n        CodecsModuleTest,\n        StreamReaderTest,\n        EncodedFileTest,\n        BasicUnicodeTest,\n        CharmapTest,\n        WithStmtTest,\n        TypesTest,\n        SurrogateEscapeTest,\n        BomTest,\n        TransformCodecTest,\n    )\n\n\nif __name__ == \"__main__\":\n    test_main()\n"
  },
  {
    "patch": "diff --git a/Lib/xmlrpc/server.py b/Lib/xmlrpc/server.py\nindex 24d8a6a03e3..93df5615068 100644\n--- a/Lib/xmlrpc/server.py\n+++ b/Lib/xmlrpc/server.py\n@@ -449,7 +449,10 @@ def do_POST(self):\n             L = []\n             while size_remaining:\n                 chunk_size = min(size_remaining, max_chunk_size)\n-                L.append(self.rfile.read(chunk_size))\n+                chunk = self.rfile.read(chunk_size)\n+                if not chunk:\n+                    break\n+                L.append(chunk)\n                 size_remaining -= len(L[-1])\n             data = b''.join(L)\n \n",
    "commit_message": "Issue #14001: CVE-2012-0845: xmlrpc: Fix an endless loop in SimpleXMLRPCServer\nupon malformed POST request.\n\n",
    "code_before": "\"\"\"XML-RPC Servers.\n\nThis module can be used to create simple XML-RPC servers\nby creating a server and either installing functions, a\nclass instance, or by extending the SimpleXMLRPCServer\nclass.\n\nIt can also be used to handle XML-RPC requests in a CGI\nenvironment using CGIXMLRPCRequestHandler.\n\nThe Doc* classes can be used to create XML-RPC servers that\nserve pydoc-style documentation in response to HTTP\nGET requests. This documentation is dynamically generated\nbased on the functions and methods registered with the\nserver.\n\nA list of possible usage patterns follows:\n\n1. Install functions:\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_function(pow)\nserver.register_function(lambda x,y: x+y, 'add')\nserver.serve_forever()\n\n2. Install an instance:\n\nclass MyFuncs:\n    def __init__(self):\n        # make all of the sys functions available through sys.func_name\n        import sys\n        self.sys = sys\n    def _listMethods(self):\n        # implement this method so that system.listMethods\n        # knows to advertise the sys methods\n        return list_public_methods(self) + \\\n                ['sys.' + method for method in list_public_methods(self.sys)]\n    def pow(self, x, y): return pow(x, y)\n    def add(self, x, y) : return x + y\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_introspection_functions()\nserver.register_instance(MyFuncs())\nserver.serve_forever()\n\n3. Install an instance with custom dispatch method:\n\nclass Math:\n    def _listMethods(self):\n        # this method must be present for system.listMethods\n        # to work\n        return ['add', 'pow']\n    def _methodHelp(self, method):\n        # this method must be present for system.methodHelp\n        # to work\n        if method == 'add':\n            return \"add(2,3) => 5\"\n        elif method == 'pow':\n            return \"pow(x, y[, z]) => number\"\n        else:\n            # By convention, return empty\n            # string if no help is available\n            return \"\"\n    def _dispatch(self, method, params):\n        if method == 'pow':\n            return pow(*params)\n        elif method == 'add':\n            return params[0] + params[1]\n        else:\n            raise ValueError('bad method')\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_introspection_functions()\nserver.register_instance(Math())\nserver.serve_forever()\n\n4. Subclass SimpleXMLRPCServer:\n\nclass MathServer(SimpleXMLRPCServer):\n    def _dispatch(self, method, params):\n        try:\n            # We are forcing the 'export_' prefix on methods that are\n            # callable through XML-RPC to prevent potential security\n            # problems\n            func = getattr(self, 'export_' + method)\n        except AttributeError:\n            raise Exception('method \"%s\" is not supported' % method)\n        else:\n            return func(*params)\n\n    def export_add(self, x, y):\n        return x + y\n\nserver = MathServer((\"localhost\", 8000))\nserver.serve_forever()\n\n5. CGI script:\n\nserver = CGIXMLRPCRequestHandler()\nserver.register_function(pow)\nserver.handle_request()\n\"\"\"\n\n# Written by Brian Quinlan (brian@sweetapp.com).\n# Based on code written by Fredrik Lundh.\n\nfrom xmlrpc.client import Fault, dumps, loads\nfrom http.server import BaseHTTPRequestHandler\nimport http.server\nimport socketserver\nimport sys\nimport os\nimport re\nimport pydoc\nimport inspect\nimport traceback\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\ndef resolve_dotted_attribute(obj, attr, allow_dotted_names=True):\n    \"\"\"resolve_dotted_attribute(a, 'b.c.d') => a.b.c.d\n\n    Resolves a dotted attribute name to an object.  Raises\n    an AttributeError if any attribute in the chain starts with a '_'.\n\n    If the optional allow_dotted_names argument is false, dots are not\n    supported and this function operates similar to getattr(obj, attr).\n    \"\"\"\n\n    if allow_dotted_names:\n        attrs = attr.split('.')\n    else:\n        attrs = [attr]\n\n    for i in attrs:\n        if i.startswith('_'):\n            raise AttributeError(\n                'attempt to access private attribute \"%s\"' % i\n                )\n        else:\n            obj = getattr(obj,i)\n    return obj\n\ndef list_public_methods(obj):\n    \"\"\"Returns a list of attribute strings, found in the specified\n    object, which represent callable attributes\"\"\"\n\n    return [member for member in dir(obj)\n                if not member.startswith('_') and\n                    hasattr(getattr(obj, member), '__call__')]\n\nclass SimpleXMLRPCDispatcher:\n    \"\"\"Mix-in class that dispatches XML-RPC requests.\n\n    This class is used to register XML-RPC method handlers\n    and then to dispatch them. There should never be any\n    reason to instantiate this class directly.\n    \"\"\"\n\n    def __init__(self, allow_none=False, encoding=None):\n        self.funcs = {}\n        self.instance = None\n        self.allow_none = allow_none\n        self.encoding = encoding or 'utf-8'\n\n    def register_instance(self, instance, allow_dotted_names=False):\n        \"\"\"Registers an instance to respond to XML-RPC requests.\n\n        Only one instance can be installed at a time.\n\n        If the registered instance has a _dispatch method then that\n        method will be called with the name of the XML-RPC method and\n        its parameters as a tuple\n        e.g. instance._dispatch('add',(2,3))\n\n        If the registered instance does not have a _dispatch method\n        then the instance will be searched to find a matching method\n        and, if found, will be called. Methods beginning with an '_'\n        are considered private and will not be called by\n        SimpleXMLRPCServer.\n\n        If a registered function matches a XML-RPC request, then it\n        will be called instead of the registered instance.\n\n        If the optional allow_dotted_names argument is true and the\n        instance does not have a _dispatch method, method names\n        containing dots are supported and resolved, as long as none of\n        the name segments start with an '_'.\n\n            *** SECURITY WARNING: ***\n\n            Enabling the allow_dotted_names options allows intruders\n            to access your module's global variables and may allow\n            intruders to execute arbitrary code on your machine.  Only\n            use this option on a secure, closed network.\n\n        \"\"\"\n\n        self.instance = instance\n        self.allow_dotted_names = allow_dotted_names\n\n    def register_function(self, function, name=None):\n        \"\"\"Registers a function to respond to XML-RPC requests.\n\n        The optional name argument can be used to set a Unicode name\n        for the function.\n        \"\"\"\n\n        if name is None:\n            name = function.__name__\n        self.funcs[name] = function\n\n    def register_introspection_functions(self):\n        \"\"\"Registers the XML-RPC introspection methods in the system\n        namespace.\n\n        see http://xmlrpc.usefulinc.com/doc/reserved.html\n        \"\"\"\n\n        self.funcs.update({'system.listMethods' : self.system_listMethods,\n                      'system.methodSignature' : self.system_methodSignature,\n                      'system.methodHelp' : self.system_methodHelp})\n\n    def register_multicall_functions(self):\n        \"\"\"Registers the XML-RPC multicall method in the system\n        namespace.\n\n        see http://www.xmlrpc.com/discuss/msgReader$1208\"\"\"\n\n        self.funcs.update({'system.multicall' : self.system_multicall})\n\n    def _marshaled_dispatch(self, data, dispatch_method = None):\n        \"\"\"Dispatches an XML-RPC method from marshalled (XML) data.\n\n        XML-RPC methods are dispatched from the marshalled (XML) data\n        using the _dispatch method and the result is returned as\n        marshalled data. For backwards compatibility, a dispatch\n        function can be provided as an argument (see comment in\n        SimpleXMLRPCRequestHandler.do_POST) but overriding the\n        existing method through subclassing is the preferred means\n        of changing method dispatch behavior.\n        \"\"\"\n\n        try:\n            params, method = loads(data)\n\n            # generate response\n            if dispatch_method is not None:\n                response = dispatch_method(method, params)\n            else:\n                response = self._dispatch(method, params)\n            # wrap response in a singleton tuple\n            response = (response,)\n            response = dumps(response, methodresponse=1,\n                             allow_none=self.allow_none, encoding=self.encoding)\n        except Fault as fault:\n            response = dumps(fault, allow_none=self.allow_none,\n                             encoding=self.encoding)\n        except:\n            # report exception back to server\n            exc_type, exc_value, exc_tb = sys.exc_info()\n            response = dumps(\n                Fault(1, \"%s:%s\" % (exc_type, exc_value)),\n                encoding=self.encoding, allow_none=self.allow_none,\n                )\n\n        return response.encode(self.encoding)\n\n    def system_listMethods(self):\n        \"\"\"system.listMethods() => ['add', 'subtract', 'multiple']\n\n        Returns a list of the methods supported by the server.\"\"\"\n\n        methods = set(self.funcs.keys())\n        if self.instance is not None:\n            # Instance can implement _listMethod to return a list of\n            # methods\n            if hasattr(self.instance, '_listMethods'):\n                methods |= set(self.instance._listMethods())\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide a list\n            # of methods\n            elif not hasattr(self.instance, '_dispatch'):\n                methods |= set(list_public_methods(self.instance))\n        return sorted(methods)\n\n    def system_methodSignature(self, method_name):\n        \"\"\"system.methodSignature('add') => [double, int, int]\n\n        Returns a list describing the signature of the method. In the\n        above example, the add method takes two integers as arguments\n        and returns a double result.\n\n        This server does NOT support system.methodSignature.\"\"\"\n\n        # See http://xmlrpc.usefulinc.com/doc/sysmethodsig.html\n\n        return 'signatures not supported'\n\n    def system_methodHelp(self, method_name):\n        \"\"\"system.methodHelp('add') => \"Adds two integers together\"\n\n        Returns a string containing documentation for the specified method.\"\"\"\n\n        method = None\n        if method_name in self.funcs:\n            method = self.funcs[method_name]\n        elif self.instance is not None:\n            # Instance can implement _methodHelp to return help for a method\n            if hasattr(self.instance, '_methodHelp'):\n                return self.instance._methodHelp(method_name)\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide help\n            elif not hasattr(self.instance, '_dispatch'):\n                try:\n                    method = resolve_dotted_attribute(\n                                self.instance,\n                                method_name,\n                                self.allow_dotted_names\n                                )\n                except AttributeError:\n                    pass\n\n        # Note that we aren't checking that the method actually\n        # be a callable object of some kind\n        if method is None:\n            return \"\"\n        else:\n            import pydoc\n            return pydoc.getdoc(method)\n\n    def system_multicall(self, call_list):\n        \"\"\"system.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => \\\n[[4], ...]\n\n        Allows the caller to package multiple XML-RPC calls into a single\n        request.\n\n        See http://www.xmlrpc.com/discuss/msgReader$1208\n        \"\"\"\n\n        results = []\n        for call in call_list:\n            method_name = call['methodName']\n            params = call['params']\n\n            try:\n                # XXX A marshalling error in any response will fail the entire\n                # multicall. If someone cares they should fix this.\n                results.append([self._dispatch(method_name, params)])\n            except Fault as fault:\n                results.append(\n                    {'faultCode' : fault.faultCode,\n                     'faultString' : fault.faultString}\n                    )\n            except:\n                exc_type, exc_value, exc_tb = sys.exc_info()\n                results.append(\n                    {'faultCode' : 1,\n                     'faultString' : \"%s:%s\" % (exc_type, exc_value)}\n                    )\n        return results\n\n    def _dispatch(self, method, params):\n        \"\"\"Dispatches the XML-RPC method.\n\n        XML-RPC calls are forwarded to a registered function that\n        matches the called XML-RPC method name. If no such function\n        exists then the call is forwarded to the registered instance,\n        if available.\n\n        If the registered instance has a _dispatch method then that\n        method will be called with the name of the XML-RPC method and\n        its parameters as a tuple\n        e.g. instance._dispatch('add',(2,3))\n\n        If the registered instance does not have a _dispatch method\n        then the instance will be searched to find a matching method\n        and, if found, will be called.\n\n        Methods beginning with an '_' are considered private and will\n        not be called.\n        \"\"\"\n\n        func = None\n        try:\n            # check to see if a matching function has been registered\n            func = self.funcs[method]\n        except KeyError:\n            if self.instance is not None:\n                # check for a _dispatch method\n                if hasattr(self.instance, '_dispatch'):\n                    return self.instance._dispatch(method, params)\n                else:\n                    # call instance method directly\n                    try:\n                        func = resolve_dotted_attribute(\n                            self.instance,\n                            method,\n                            self.allow_dotted_names\n                            )\n                    except AttributeError:\n                        pass\n\n        if func is not None:\n            return func(*params)\n        else:\n            raise Exception('method \"%s\" is not supported' % method)\n\nclass SimpleXMLRPCRequestHandler(BaseHTTPRequestHandler):\n    \"\"\"Simple XML-RPC request handler class.\n\n    Handles all HTTP POST requests and attempts to decode them as\n    XML-RPC requests.\n    \"\"\"\n\n    # Class attribute listing the accessible path components;\n    # paths not on this list will result in a 404 error.\n    rpc_paths = ('/', '/RPC2')\n\n    def is_rpc_path_valid(self):\n        if self.rpc_paths:\n            return self.path in self.rpc_paths\n        else:\n            # If .rpc_paths is empty, just assume all paths are legal\n            return True\n\n    def do_POST(self):\n        \"\"\"Handles the HTTP POST request.\n\n        Attempts to interpret all HTTP POST requests as XML-RPC calls,\n        which are forwarded to the server's _dispatch method for handling.\n        \"\"\"\n\n        # Check that the path is legal\n        if not self.is_rpc_path_valid():\n            self.report_404()\n            return\n\n        try:\n            # Get arguments by reading body of request.\n            # We read this in chunks to avoid straining\n            # socket.read(); around the 10 or 15Mb mark, some platforms\n            # begin to have problems (bug #792570).\n            max_chunk_size = 10*1024*1024\n            size_remaining = int(self.headers[\"content-length\"])\n            L = []\n            while size_remaining:\n                chunk_size = min(size_remaining, max_chunk_size)\n                L.append(self.rfile.read(chunk_size))\n                size_remaining -= len(L[-1])\n            data = b''.join(L)\n\n            # In previous versions of SimpleXMLRPCServer, _dispatch\n            # could be overridden in this class, instead of in\n            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,\n            # check to see if a subclass implements _dispatch and dispatch\n            # using that method if present.\n            response = self.server._marshaled_dispatch(\n                    data, getattr(self, '_dispatch', None)\n                )\n        except Exception as e: # This should only happen if the module is buggy\n            # internal error, report as HTTP server error\n            self.send_response(500)\n\n            # Send information about the exception if requested\n            if hasattr(self.server, '_send_traceback_header') and \\\n                    self.server._send_traceback_header:\n                self.send_header(\"X-exception\", str(e))\n                trace = traceback.format_exc()\n                trace = str(trace.encode('ASCII', 'backslashreplace'), 'ASCII')\n                self.send_header(\"X-traceback\", trace)\n\n            self.end_headers()\n        else:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"text/xml\")\n            self.send_header(\"Content-length\", str(len(response)))\n            self.end_headers()\n            self.wfile.write(response)\n\n            # shut down the connection\n            self.wfile.flush()\n            self.connection.shutdown(1)\n\n    def report_404 (self):\n            # Report a 404 error\n        self.send_response(404)\n        response = b'No such page'\n        self.send_header(\"Content-type\", \"text/plain\")\n        self.send_header(\"Content-length\", str(len(response)))\n        self.end_headers()\n        self.wfile.write(response)\n        # shut down the connection\n        self.wfile.flush()\n        self.connection.shutdown(1)\n\n    def log_request(self, code='-', size='-'):\n        \"\"\"Selectively log an accepted request.\"\"\"\n\n        if self.server.logRequests:\n            BaseHTTPRequestHandler.log_request(self, code, size)\n\nclass SimpleXMLRPCServer(socketserver.TCPServer,\n                         SimpleXMLRPCDispatcher):\n    \"\"\"Simple XML-RPC server.\n\n    Simple XML-RPC server that allows functions and a single instance\n    to be installed to handle requests. The default implementation\n    attempts to dispatch XML-RPC calls to the functions or instance\n    installed in the server. Override the _dispatch method inhereted\n    from SimpleXMLRPCDispatcher to change this behavior.\n    \"\"\"\n\n    allow_reuse_address = True\n\n    # Warning: this is for debugging purposes only! Never set this to True in\n    # production code, as will be sending out sensitive information (exception\n    # and stack trace details) when exceptions are raised inside\n    # SimpleXMLRPCRequestHandler.do_POST\n    _send_traceback_header = False\n\n    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,\n                 logRequests=True, allow_none=False, encoding=None, bind_and_activate=True):\n        self.logRequests = logRequests\n\n        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)\n        socketserver.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)\n\n        # [Bug #1222790] If possible, set close-on-exec flag; if a\n        # method spawns a subprocess, the subprocess shouldn't have\n        # the listening socket open.\n        if fcntl is not None and hasattr(fcntl, 'FD_CLOEXEC'):\n            flags = fcntl.fcntl(self.fileno(), fcntl.F_GETFD)\n            flags |= fcntl.FD_CLOEXEC\n            fcntl.fcntl(self.fileno(), fcntl.F_SETFD, flags)\n\nclass CGIXMLRPCRequestHandler(SimpleXMLRPCDispatcher):\n    \"\"\"Simple handler for XML-RPC data passed through CGI.\"\"\"\n\n    def __init__(self, allow_none=False, encoding=None):\n        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)\n\n    def handle_xmlrpc(self, request_text):\n        \"\"\"Handle a single XML-RPC request\"\"\"\n\n        response = self._marshaled_dispatch(request_text)\n\n        print('Content-Type: text/xml')\n        print('Content-Length: %d' % len(response))\n        print()\n        sys.stdout.flush()\n        sys.stdout.buffer.write(response)\n        sys.stdout.buffer.flush()\n\n    def handle_get(self):\n        \"\"\"Handle a single HTTP GET request.\n\n        Default implementation indicates an error because\n        XML-RPC uses the POST method.\n        \"\"\"\n\n        code = 400\n        message, explain = BaseHTTPRequestHandler.responses[code]\n\n        response = http.server.DEFAULT_ERROR_MESSAGE % \\\n            {\n             'code' : code,\n             'message' : message,\n             'explain' : explain\n            }\n        response = response.encode('utf-8')\n        print('Status: %d %s' % (code, message))\n        print('Content-Type: %s' % http.server.DEFAULT_ERROR_CONTENT_TYPE)\n        print('Content-Length: %d' % len(response))\n        print()\n        sys.stdout.flush()\n        sys.stdout.buffer.write(response)\n        sys.stdout.buffer.flush()\n\n    def handle_request(self, request_text=None):\n        \"\"\"Handle a single XML-RPC request passed through a CGI post method.\n\n        If no XML data is given then it is read from stdin. The resulting\n        XML-RPC response is printed to stdout along with the correct HTTP\n        headers.\n        \"\"\"\n\n        if request_text is None and \\\n            os.environ.get('REQUEST_METHOD', None) == 'GET':\n            self.handle_get()\n        else:\n            # POST data is normally available through stdin\n            try:\n                length = int(os.environ.get('CONTENT_LENGTH', None))\n            except (ValueError, TypeError):\n                length = -1\n            if request_text is None:\n                request_text = sys.stdin.read(length)\n\n            self.handle_xmlrpc(request_text)\n\n\n# -----------------------------------------------------------------------------\n# Self documenting XML-RPC Server.\n\nclass ServerHTMLDoc(pydoc.HTMLDoc):\n    \"\"\"Class used to generate pydoc HTML document for a server\"\"\"\n\n    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):\n        \"\"\"Mark up some plain text, given a context of symbols to look for.\n        Each context dictionary maps object names to anchor names.\"\"\"\n        escape = escape or self.escape\n        results = []\n        here = 0\n\n        # XXX Note that this regular expression does not allow for the\n        # hyperlinking of arbitrary strings being used as method\n        # names. Only methods with names consisting of word characters\n        # and '.'s are hyperlinked.\n        pattern = re.compile(r'\\b((http|ftp)://\\S+[\\w/]|'\n                                r'RFC[- ]?(\\d+)|'\n                                r'PEP[- ]?(\\d+)|'\n                                r'(self\\.)?((?:\\w|\\.)+))\\b')\n        while 1:\n            match = pattern.search(text, here)\n            if not match: break\n            start, end = match.span()\n            results.append(escape(text[here:start]))\n\n            all, scheme, rfc, pep, selfdot, name = match.groups()\n            if scheme:\n                url = escape(all).replace('\"', '&quot;')\n                results.append('<a href=\"%s\">%s</a>' % (url, url))\n            elif rfc:\n                url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif pep:\n                url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif text[end:end+1] == '(':\n                results.append(self.namelink(name, methods, funcs, classes))\n            elif selfdot:\n                results.append('self.<strong>%s</strong>' % name)\n            else:\n                results.append(self.namelink(name, classes))\n            here = end\n        results.append(escape(text[here:]))\n        return ''.join(results)\n\n    def docroutine(self, object, name, mod=None,\n                   funcs={}, classes={}, methods={}, cl=None):\n        \"\"\"Produce HTML documentation for a function or method object.\"\"\"\n\n        anchor = (cl and cl.__name__ or '') + '-' + name\n        note = ''\n\n        title = '<a name=\"%s\"><strong>%s</strong></a>' % (\n            self.escape(anchor), self.escape(name))\n\n        if inspect.ismethod(object):\n            args, varargs, varkw, defaults = inspect.getargspec(object)\n            # exclude the argument bound to the instance, it will be\n            # confusing to the non-Python user\n            argspec = inspect.formatargspec (\n                    args[1:],\n                    varargs,\n                    varkw,\n                    defaults,\n                    formatvalue=self.formatvalue\n                )\n        elif inspect.isfunction(object):\n            args, varargs, varkw, defaults = inspect.getargspec(object)\n            argspec = inspect.formatargspec(\n                args, varargs, varkw, defaults, formatvalue=self.formatvalue)\n        else:\n            argspec = '(...)'\n\n        if isinstance(object, tuple):\n            argspec = object[0] or argspec\n            docstring = object[1] or \"\"\n        else:\n            docstring = pydoc.getdoc(object)\n\n        decl = title + argspec + (note and self.grey(\n               '<font face=\"helvetica, arial\">%s</font>' % note))\n\n        doc = self.markup(\n            docstring, self.preformat, funcs, classes, methods)\n        doc = doc and '<dd><tt>%s</tt></dd>' % doc\n        return '<dl><dt>%s</dt>%s</dl>\\n' % (decl, doc)\n\n    def docserver(self, server_name, package_documentation, methods):\n        \"\"\"Produce HTML documentation for an XML-RPC server.\"\"\"\n\n        fdict = {}\n        for key, value in methods.items():\n            fdict[key] = '#-' + key\n            fdict[value] = fdict[key]\n\n        server_name = self.escape(server_name)\n        head = '<big><big><strong>%s</strong></big></big>' % server_name\n        result = self.heading(head, '#ffffff', '#7799ee')\n\n        doc = self.markup(package_documentation, self.preformat, fdict)\n        doc = doc and '<tt>%s</tt>' % doc\n        result = result + '<p>%s</p>\\n' % doc\n\n        contents = []\n        method_items = sorted(methods.items())\n        for key, value in method_items:\n            contents.append(self.docroutine(value, key, funcs=fdict))\n        result = result + self.bigsection(\n            'Methods', '#ffffff', '#eeaa77', ''.join(contents))\n\n        return result\n\nclass XMLRPCDocGenerator:\n    \"\"\"Generates documentation for an XML-RPC server.\n\n    This class is designed as mix-in and should not\n    be constructed directly.\n    \"\"\"\n\n    def __init__(self):\n        # setup variables used for HTML documentation\n        self.server_name = 'XML-RPC Server Documentation'\n        self.server_documentation = \\\n            \"This server exports the following methods through the XML-RPC \"\\\n            \"protocol.\"\n        self.server_title = 'XML-RPC Server Documentation'\n\n    def set_server_title(self, server_title):\n        \"\"\"Set the HTML title of the generated server documentation\"\"\"\n\n        self.server_title = server_title\n\n    def set_server_name(self, server_name):\n        \"\"\"Set the name of the generated HTML server documentation\"\"\"\n\n        self.server_name = server_name\n\n    def set_server_documentation(self, server_documentation):\n        \"\"\"Set the documentation string for the entire server.\"\"\"\n\n        self.server_documentation = server_documentation\n\n    def generate_html_documentation(self):\n        \"\"\"generate_html_documentation() => html documentation for the server\n\n        Generates HTML documentation for the server using introspection for\n        installed functions and instances that do not implement the\n        _dispatch method. Alternatively, instances can choose to implement\n        the _get_method_argstring(method_name) method to provide the\n        argument string used in the documentation and the\n        _methodHelp(method_name) method to provide the help text used\n        in the documentation.\"\"\"\n\n        methods = {}\n\n        for method_name in self.system_listMethods():\n            if method_name in self.funcs:\n                method = self.funcs[method_name]\n            elif self.instance is not None:\n                method_info = [None, None] # argspec, documentation\n                if hasattr(self.instance, '_get_method_argstring'):\n                    method_info[0] = self.instance._get_method_argstring(method_name)\n                if hasattr(self.instance, '_methodHelp'):\n                    method_info[1] = self.instance._methodHelp(method_name)\n\n                method_info = tuple(method_info)\n                if method_info != (None, None):\n                    method = method_info\n                elif not hasattr(self.instance, '_dispatch'):\n                    try:\n                        method = resolve_dotted_attribute(\n                                    self.instance,\n                                    method_name\n                                    )\n                    except AttributeError:\n                        method = method_info\n                else:\n                    method = method_info\n            else:\n                assert 0, \"Could not find method in self.functions and no \"\\\n                          \"instance installed\"\n\n            methods[method_name] = method\n\n        documenter = ServerHTMLDoc()\n        documentation = documenter.docserver(\n                                self.server_name,\n                                self.server_documentation,\n                                methods\n                            )\n\n        return documenter.page(self.server_title, documentation)\n\nclass DocXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):\n    \"\"\"XML-RPC and documentation request handler class.\n\n    Handles all HTTP POST requests and attempts to decode them as\n    XML-RPC requests.\n\n    Handles all HTTP GET requests and interprets them as requests\n    for documentation.\n    \"\"\"\n\n    def do_GET(self):\n        \"\"\"Handles the HTTP GET request.\n\n        Interpret all HTTP GET requests as requests for server\n        documentation.\n        \"\"\"\n        # Check that the path is legal\n        if not self.is_rpc_path_valid():\n            self.report_404()\n            return\n\n        response = self.server.generate_html_documentation().encode('utf-8')\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"text/html\")\n        self.send_header(\"Content-length\", str(len(response)))\n        self.end_headers()\n        self.wfile.write(response)\n\n        # shut down the connection\n        self.wfile.flush()\n        self.connection.shutdown(1)\n\nclass DocXMLRPCServer(  SimpleXMLRPCServer,\n                        XMLRPCDocGenerator):\n    \"\"\"XML-RPC and HTML documentation server.\n\n    Adds the ability to serve server documentation to the capabilities\n    of SimpleXMLRPCServer.\n    \"\"\"\n\n    def __init__(self, addr, requestHandler=DocXMLRPCRequestHandler,\n                 logRequests=True, allow_none=False, encoding=None,\n                 bind_and_activate=True):\n        SimpleXMLRPCServer.__init__(self, addr, requestHandler, logRequests,\n                                    allow_none, encoding, bind_and_activate)\n        XMLRPCDocGenerator.__init__(self)\n\nclass DocCGIXMLRPCRequestHandler(   CGIXMLRPCRequestHandler,\n                                    XMLRPCDocGenerator):\n    \"\"\"Handler for XML-RPC data and documentation requests passed through\n    CGI\"\"\"\n\n    def handle_get(self):\n        \"\"\"Handles the HTTP GET request.\n\n        Interpret all HTTP GET requests as requests for server\n        documentation.\n        \"\"\"\n\n        response = self.generate_html_documentation().encode('utf-8')\n\n        print('Content-Type: text/html')\n        print('Content-Length: %d' % len(response))\n        print()\n        sys.stdout.flush()\n        sys.stdout.buffer.write(response)\n        sys.stdout.buffer.flush()\n\n    def __init__(self):\n        CGIXMLRPCRequestHandler.__init__(self)\n        XMLRPCDocGenerator.__init__(self)\n\n\nif __name__ == '__main__':\n    print('Running XML-RPC server on port 8000')\n    server = SimpleXMLRPCServer((\"localhost\", 8000))\n    server.register_function(pow)\n    server.register_function(lambda x,y: x+y, 'add')\n    server.serve_forever()\n",
    "code_after": "\"\"\"XML-RPC Servers.\n\nThis module can be used to create simple XML-RPC servers\nby creating a server and either installing functions, a\nclass instance, or by extending the SimpleXMLRPCServer\nclass.\n\nIt can also be used to handle XML-RPC requests in a CGI\nenvironment using CGIXMLRPCRequestHandler.\n\nThe Doc* classes can be used to create XML-RPC servers that\nserve pydoc-style documentation in response to HTTP\nGET requests. This documentation is dynamically generated\nbased on the functions and methods registered with the\nserver.\n\nA list of possible usage patterns follows:\n\n1. Install functions:\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_function(pow)\nserver.register_function(lambda x,y: x+y, 'add')\nserver.serve_forever()\n\n2. Install an instance:\n\nclass MyFuncs:\n    def __init__(self):\n        # make all of the sys functions available through sys.func_name\n        import sys\n        self.sys = sys\n    def _listMethods(self):\n        # implement this method so that system.listMethods\n        # knows to advertise the sys methods\n        return list_public_methods(self) + \\\n                ['sys.' + method for method in list_public_methods(self.sys)]\n    def pow(self, x, y): return pow(x, y)\n    def add(self, x, y) : return x + y\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_introspection_functions()\nserver.register_instance(MyFuncs())\nserver.serve_forever()\n\n3. Install an instance with custom dispatch method:\n\nclass Math:\n    def _listMethods(self):\n        # this method must be present for system.listMethods\n        # to work\n        return ['add', 'pow']\n    def _methodHelp(self, method):\n        # this method must be present for system.methodHelp\n        # to work\n        if method == 'add':\n            return \"add(2,3) => 5\"\n        elif method == 'pow':\n            return \"pow(x, y[, z]) => number\"\n        else:\n            # By convention, return empty\n            # string if no help is available\n            return \"\"\n    def _dispatch(self, method, params):\n        if method == 'pow':\n            return pow(*params)\n        elif method == 'add':\n            return params[0] + params[1]\n        else:\n            raise ValueError('bad method')\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_introspection_functions()\nserver.register_instance(Math())\nserver.serve_forever()\n\n4. Subclass SimpleXMLRPCServer:\n\nclass MathServer(SimpleXMLRPCServer):\n    def _dispatch(self, method, params):\n        try:\n            # We are forcing the 'export_' prefix on methods that are\n            # callable through XML-RPC to prevent potential security\n            # problems\n            func = getattr(self, 'export_' + method)\n        except AttributeError:\n            raise Exception('method \"%s\" is not supported' % method)\n        else:\n            return func(*params)\n\n    def export_add(self, x, y):\n        return x + y\n\nserver = MathServer((\"localhost\", 8000))\nserver.serve_forever()\n\n5. CGI script:\n\nserver = CGIXMLRPCRequestHandler()\nserver.register_function(pow)\nserver.handle_request()\n\"\"\"\n\n# Written by Brian Quinlan (brian@sweetapp.com).\n# Based on code written by Fredrik Lundh.\n\nfrom xmlrpc.client import Fault, dumps, loads\nfrom http.server import BaseHTTPRequestHandler\nimport http.server\nimport socketserver\nimport sys\nimport os\nimport re\nimport pydoc\nimport inspect\nimport traceback\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\ndef resolve_dotted_attribute(obj, attr, allow_dotted_names=True):\n    \"\"\"resolve_dotted_attribute(a, 'b.c.d') => a.b.c.d\n\n    Resolves a dotted attribute name to an object.  Raises\n    an AttributeError if any attribute in the chain starts with a '_'.\n\n    If the optional allow_dotted_names argument is false, dots are not\n    supported and this function operates similar to getattr(obj, attr).\n    \"\"\"\n\n    if allow_dotted_names:\n        attrs = attr.split('.')\n    else:\n        attrs = [attr]\n\n    for i in attrs:\n        if i.startswith('_'):\n            raise AttributeError(\n                'attempt to access private attribute \"%s\"' % i\n                )\n        else:\n            obj = getattr(obj,i)\n    return obj\n\ndef list_public_methods(obj):\n    \"\"\"Returns a list of attribute strings, found in the specified\n    object, which represent callable attributes\"\"\"\n\n    return [member for member in dir(obj)\n                if not member.startswith('_') and\n                    hasattr(getattr(obj, member), '__call__')]\n\nclass SimpleXMLRPCDispatcher:\n    \"\"\"Mix-in class that dispatches XML-RPC requests.\n\n    This class is used to register XML-RPC method handlers\n    and then to dispatch them. There should never be any\n    reason to instantiate this class directly.\n    \"\"\"\n\n    def __init__(self, allow_none=False, encoding=None):\n        self.funcs = {}\n        self.instance = None\n        self.allow_none = allow_none\n        self.encoding = encoding or 'utf-8'\n\n    def register_instance(self, instance, allow_dotted_names=False):\n        \"\"\"Registers an instance to respond to XML-RPC requests.\n\n        Only one instance can be installed at a time.\n\n        If the registered instance has a _dispatch method then that\n        method will be called with the name of the XML-RPC method and\n        its parameters as a tuple\n        e.g. instance._dispatch('add',(2,3))\n\n        If the registered instance does not have a _dispatch method\n        then the instance will be searched to find a matching method\n        and, if found, will be called. Methods beginning with an '_'\n        are considered private and will not be called by\n        SimpleXMLRPCServer.\n\n        If a registered function matches a XML-RPC request, then it\n        will be called instead of the registered instance.\n\n        If the optional allow_dotted_names argument is true and the\n        instance does not have a _dispatch method, method names\n        containing dots are supported and resolved, as long as none of\n        the name segments start with an '_'.\n\n            *** SECURITY WARNING: ***\n\n            Enabling the allow_dotted_names options allows intruders\n            to access your module's global variables and may allow\n            intruders to execute arbitrary code on your machine.  Only\n            use this option on a secure, closed network.\n\n        \"\"\"\n\n        self.instance = instance\n        self.allow_dotted_names = allow_dotted_names\n\n    def register_function(self, function, name=None):\n        \"\"\"Registers a function to respond to XML-RPC requests.\n\n        The optional name argument can be used to set a Unicode name\n        for the function.\n        \"\"\"\n\n        if name is None:\n            name = function.__name__\n        self.funcs[name] = function\n\n    def register_introspection_functions(self):\n        \"\"\"Registers the XML-RPC introspection methods in the system\n        namespace.\n\n        see http://xmlrpc.usefulinc.com/doc/reserved.html\n        \"\"\"\n\n        self.funcs.update({'system.listMethods' : self.system_listMethods,\n                      'system.methodSignature' : self.system_methodSignature,\n                      'system.methodHelp' : self.system_methodHelp})\n\n    def register_multicall_functions(self):\n        \"\"\"Registers the XML-RPC multicall method in the system\n        namespace.\n\n        see http://www.xmlrpc.com/discuss/msgReader$1208\"\"\"\n\n        self.funcs.update({'system.multicall' : self.system_multicall})\n\n    def _marshaled_dispatch(self, data, dispatch_method = None):\n        \"\"\"Dispatches an XML-RPC method from marshalled (XML) data.\n\n        XML-RPC methods are dispatched from the marshalled (XML) data\n        using the _dispatch method and the result is returned as\n        marshalled data. For backwards compatibility, a dispatch\n        function can be provided as an argument (see comment in\n        SimpleXMLRPCRequestHandler.do_POST) but overriding the\n        existing method through subclassing is the preferred means\n        of changing method dispatch behavior.\n        \"\"\"\n\n        try:\n            params, method = loads(data)\n\n            # generate response\n            if dispatch_method is not None:\n                response = dispatch_method(method, params)\n            else:\n                response = self._dispatch(method, params)\n            # wrap response in a singleton tuple\n            response = (response,)\n            response = dumps(response, methodresponse=1,\n                             allow_none=self.allow_none, encoding=self.encoding)\n        except Fault as fault:\n            response = dumps(fault, allow_none=self.allow_none,\n                             encoding=self.encoding)\n        except:\n            # report exception back to server\n            exc_type, exc_value, exc_tb = sys.exc_info()\n            response = dumps(\n                Fault(1, \"%s:%s\" % (exc_type, exc_value)),\n                encoding=self.encoding, allow_none=self.allow_none,\n                )\n\n        return response.encode(self.encoding)\n\n    def system_listMethods(self):\n        \"\"\"system.listMethods() => ['add', 'subtract', 'multiple']\n\n        Returns a list of the methods supported by the server.\"\"\"\n\n        methods = set(self.funcs.keys())\n        if self.instance is not None:\n            # Instance can implement _listMethod to return a list of\n            # methods\n            if hasattr(self.instance, '_listMethods'):\n                methods |= set(self.instance._listMethods())\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide a list\n            # of methods\n            elif not hasattr(self.instance, '_dispatch'):\n                methods |= set(list_public_methods(self.instance))\n        return sorted(methods)\n\n    def system_methodSignature(self, method_name):\n        \"\"\"system.methodSignature('add') => [double, int, int]\n\n        Returns a list describing the signature of the method. In the\n        above example, the add method takes two integers as arguments\n        and returns a double result.\n\n        This server does NOT support system.methodSignature.\"\"\"\n\n        # See http://xmlrpc.usefulinc.com/doc/sysmethodsig.html\n\n        return 'signatures not supported'\n\n    def system_methodHelp(self, method_name):\n        \"\"\"system.methodHelp('add') => \"Adds two integers together\"\n\n        Returns a string containing documentation for the specified method.\"\"\"\n\n        method = None\n        if method_name in self.funcs:\n            method = self.funcs[method_name]\n        elif self.instance is not None:\n            # Instance can implement _methodHelp to return help for a method\n            if hasattr(self.instance, '_methodHelp'):\n                return self.instance._methodHelp(method_name)\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide help\n            elif not hasattr(self.instance, '_dispatch'):\n                try:\n                    method = resolve_dotted_attribute(\n                                self.instance,\n                                method_name,\n                                self.allow_dotted_names\n                                )\n                except AttributeError:\n                    pass\n\n        # Note that we aren't checking that the method actually\n        # be a callable object of some kind\n        if method is None:\n            return \"\"\n        else:\n            import pydoc\n            return pydoc.getdoc(method)\n\n    def system_multicall(self, call_list):\n        \"\"\"system.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => \\\n[[4], ...]\n\n        Allows the caller to package multiple XML-RPC calls into a single\n        request.\n\n        See http://www.xmlrpc.com/discuss/msgReader$1208\n        \"\"\"\n\n        results = []\n        for call in call_list:\n            method_name = call['methodName']\n            params = call['params']\n\n            try:\n                # XXX A marshalling error in any response will fail the entire\n                # multicall. If someone cares they should fix this.\n                results.append([self._dispatch(method_name, params)])\n            except Fault as fault:\n                results.append(\n                    {'faultCode' : fault.faultCode,\n                     'faultString' : fault.faultString}\n                    )\n            except:\n                exc_type, exc_value, exc_tb = sys.exc_info()\n                results.append(\n                    {'faultCode' : 1,\n                     'faultString' : \"%s:%s\" % (exc_type, exc_value)}\n                    )\n        return results\n\n    def _dispatch(self, method, params):\n        \"\"\"Dispatches the XML-RPC method.\n\n        XML-RPC calls are forwarded to a registered function that\n        matches the called XML-RPC method name. If no such function\n        exists then the call is forwarded to the registered instance,\n        if available.\n\n        If the registered instance has a _dispatch method then that\n        method will be called with the name of the XML-RPC method and\n        its parameters as a tuple\n        e.g. instance._dispatch('add',(2,3))\n\n        If the registered instance does not have a _dispatch method\n        then the instance will be searched to find a matching method\n        and, if found, will be called.\n\n        Methods beginning with an '_' are considered private and will\n        not be called.\n        \"\"\"\n\n        func = None\n        try:\n            # check to see if a matching function has been registered\n            func = self.funcs[method]\n        except KeyError:\n            if self.instance is not None:\n                # check for a _dispatch method\n                if hasattr(self.instance, '_dispatch'):\n                    return self.instance._dispatch(method, params)\n                else:\n                    # call instance method directly\n                    try:\n                        func = resolve_dotted_attribute(\n                            self.instance,\n                            method,\n                            self.allow_dotted_names\n                            )\n                    except AttributeError:\n                        pass\n\n        if func is not None:\n            return func(*params)\n        else:\n            raise Exception('method \"%s\" is not supported' % method)\n\nclass SimpleXMLRPCRequestHandler(BaseHTTPRequestHandler):\n    \"\"\"Simple XML-RPC request handler class.\n\n    Handles all HTTP POST requests and attempts to decode them as\n    XML-RPC requests.\n    \"\"\"\n\n    # Class attribute listing the accessible path components;\n    # paths not on this list will result in a 404 error.\n    rpc_paths = ('/', '/RPC2')\n\n    def is_rpc_path_valid(self):\n        if self.rpc_paths:\n            return self.path in self.rpc_paths\n        else:\n            # If .rpc_paths is empty, just assume all paths are legal\n            return True\n\n    def do_POST(self):\n        \"\"\"Handles the HTTP POST request.\n\n        Attempts to interpret all HTTP POST requests as XML-RPC calls,\n        which are forwarded to the server's _dispatch method for handling.\n        \"\"\"\n\n        # Check that the path is legal\n        if not self.is_rpc_path_valid():\n            self.report_404()\n            return\n\n        try:\n            # Get arguments by reading body of request.\n            # We read this in chunks to avoid straining\n            # socket.read(); around the 10 or 15Mb mark, some platforms\n            # begin to have problems (bug #792570).\n            max_chunk_size = 10*1024*1024\n            size_remaining = int(self.headers[\"content-length\"])\n            L = []\n            while size_remaining:\n                chunk_size = min(size_remaining, max_chunk_size)\n                chunk = self.rfile.read(chunk_size)\n                if not chunk:\n                    break\n                L.append(chunk)\n                size_remaining -= len(L[-1])\n            data = b''.join(L)\n\n            # In previous versions of SimpleXMLRPCServer, _dispatch\n            # could be overridden in this class, instead of in\n            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,\n            # check to see if a subclass implements _dispatch and dispatch\n            # using that method if present.\n            response = self.server._marshaled_dispatch(\n                    data, getattr(self, '_dispatch', None)\n                )\n        except Exception as e: # This should only happen if the module is buggy\n            # internal error, report as HTTP server error\n            self.send_response(500)\n\n            # Send information about the exception if requested\n            if hasattr(self.server, '_send_traceback_header') and \\\n                    self.server._send_traceback_header:\n                self.send_header(\"X-exception\", str(e))\n                trace = traceback.format_exc()\n                trace = str(trace.encode('ASCII', 'backslashreplace'), 'ASCII')\n                self.send_header(\"X-traceback\", trace)\n\n            self.end_headers()\n        else:\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"text/xml\")\n            self.send_header(\"Content-length\", str(len(response)))\n            self.end_headers()\n            self.wfile.write(response)\n\n            # shut down the connection\n            self.wfile.flush()\n            self.connection.shutdown(1)\n\n    def report_404 (self):\n            # Report a 404 error\n        self.send_response(404)\n        response = b'No such page'\n        self.send_header(\"Content-type\", \"text/plain\")\n        self.send_header(\"Content-length\", str(len(response)))\n        self.end_headers()\n        self.wfile.write(response)\n        # shut down the connection\n        self.wfile.flush()\n        self.connection.shutdown(1)\n\n    def log_request(self, code='-', size='-'):\n        \"\"\"Selectively log an accepted request.\"\"\"\n\n        if self.server.logRequests:\n            BaseHTTPRequestHandler.log_request(self, code, size)\n\nclass SimpleXMLRPCServer(socketserver.TCPServer,\n                         SimpleXMLRPCDispatcher):\n    \"\"\"Simple XML-RPC server.\n\n    Simple XML-RPC server that allows functions and a single instance\n    to be installed to handle requests. The default implementation\n    attempts to dispatch XML-RPC calls to the functions or instance\n    installed in the server. Override the _dispatch method inhereted\n    from SimpleXMLRPCDispatcher to change this behavior.\n    \"\"\"\n\n    allow_reuse_address = True\n\n    # Warning: this is for debugging purposes only! Never set this to True in\n    # production code, as will be sending out sensitive information (exception\n    # and stack trace details) when exceptions are raised inside\n    # SimpleXMLRPCRequestHandler.do_POST\n    _send_traceback_header = False\n\n    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,\n                 logRequests=True, allow_none=False, encoding=None, bind_and_activate=True):\n        self.logRequests = logRequests\n\n        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)\n        socketserver.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)\n\n        # [Bug #1222790] If possible, set close-on-exec flag; if a\n        # method spawns a subprocess, the subprocess shouldn't have\n        # the listening socket open.\n        if fcntl is not None and hasattr(fcntl, 'FD_CLOEXEC'):\n            flags = fcntl.fcntl(self.fileno(), fcntl.F_GETFD)\n            flags |= fcntl.FD_CLOEXEC\n            fcntl.fcntl(self.fileno(), fcntl.F_SETFD, flags)\n\nclass CGIXMLRPCRequestHandler(SimpleXMLRPCDispatcher):\n    \"\"\"Simple handler for XML-RPC data passed through CGI.\"\"\"\n\n    def __init__(self, allow_none=False, encoding=None):\n        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)\n\n    def handle_xmlrpc(self, request_text):\n        \"\"\"Handle a single XML-RPC request\"\"\"\n\n        response = self._marshaled_dispatch(request_text)\n\n        print('Content-Type: text/xml')\n        print('Content-Length: %d' % len(response))\n        print()\n        sys.stdout.flush()\n        sys.stdout.buffer.write(response)\n        sys.stdout.buffer.flush()\n\n    def handle_get(self):\n        \"\"\"Handle a single HTTP GET request.\n\n        Default implementation indicates an error because\n        XML-RPC uses the POST method.\n        \"\"\"\n\n        code = 400\n        message, explain = BaseHTTPRequestHandler.responses[code]\n\n        response = http.server.DEFAULT_ERROR_MESSAGE % \\\n            {\n             'code' : code,\n             'message' : message,\n             'explain' : explain\n            }\n        response = response.encode('utf-8')\n        print('Status: %d %s' % (code, message))\n        print('Content-Type: %s' % http.server.DEFAULT_ERROR_CONTENT_TYPE)\n        print('Content-Length: %d' % len(response))\n        print()\n        sys.stdout.flush()\n        sys.stdout.buffer.write(response)\n        sys.stdout.buffer.flush()\n\n    def handle_request(self, request_text=None):\n        \"\"\"Handle a single XML-RPC request passed through a CGI post method.\n\n        If no XML data is given then it is read from stdin. The resulting\n        XML-RPC response is printed to stdout along with the correct HTTP\n        headers.\n        \"\"\"\n\n        if request_text is None and \\\n            os.environ.get('REQUEST_METHOD', None) == 'GET':\n            self.handle_get()\n        else:\n            # POST data is normally available through stdin\n            try:\n                length = int(os.environ.get('CONTENT_LENGTH', None))\n            except (ValueError, TypeError):\n                length = -1\n            if request_text is None:\n                request_text = sys.stdin.read(length)\n\n            self.handle_xmlrpc(request_text)\n\n\n# -----------------------------------------------------------------------------\n# Self documenting XML-RPC Server.\n\nclass ServerHTMLDoc(pydoc.HTMLDoc):\n    \"\"\"Class used to generate pydoc HTML document for a server\"\"\"\n\n    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):\n        \"\"\"Mark up some plain text, given a context of symbols to look for.\n        Each context dictionary maps object names to anchor names.\"\"\"\n        escape = escape or self.escape\n        results = []\n        here = 0\n\n        # XXX Note that this regular expression does not allow for the\n        # hyperlinking of arbitrary strings being used as method\n        # names. Only methods with names consisting of word characters\n        # and '.'s are hyperlinked.\n        pattern = re.compile(r'\\b((http|ftp)://\\S+[\\w/]|'\n                                r'RFC[- ]?(\\d+)|'\n                                r'PEP[- ]?(\\d+)|'\n                                r'(self\\.)?((?:\\w|\\.)+))\\b')\n        while 1:\n            match = pattern.search(text, here)\n            if not match: break\n            start, end = match.span()\n            results.append(escape(text[here:start]))\n\n            all, scheme, rfc, pep, selfdot, name = match.groups()\n            if scheme:\n                url = escape(all).replace('\"', '&quot;')\n                results.append('<a href=\"%s\">%s</a>' % (url, url))\n            elif rfc:\n                url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif pep:\n                url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)\n                results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n            elif text[end:end+1] == '(':\n                results.append(self.namelink(name, methods, funcs, classes))\n            elif selfdot:\n                results.append('self.<strong>%s</strong>' % name)\n            else:\n                results.append(self.namelink(name, classes))\n            here = end\n        results.append(escape(text[here:]))\n        return ''.join(results)\n\n    def docroutine(self, object, name, mod=None,\n                   funcs={}, classes={}, methods={}, cl=None):\n        \"\"\"Produce HTML documentation for a function or method object.\"\"\"\n\n        anchor = (cl and cl.__name__ or '') + '-' + name\n        note = ''\n\n        title = '<a name=\"%s\"><strong>%s</strong></a>' % (\n            self.escape(anchor), self.escape(name))\n\n        if inspect.ismethod(object):\n            args, varargs, varkw, defaults = inspect.getargspec(object)\n            # exclude the argument bound to the instance, it will be\n            # confusing to the non-Python user\n            argspec = inspect.formatargspec (\n                    args[1:],\n                    varargs,\n                    varkw,\n                    defaults,\n                    formatvalue=self.formatvalue\n                )\n        elif inspect.isfunction(object):\n            args, varargs, varkw, defaults = inspect.getargspec(object)\n            argspec = inspect.formatargspec(\n                args, varargs, varkw, defaults, formatvalue=self.formatvalue)\n        else:\n            argspec = '(...)'\n\n        if isinstance(object, tuple):\n            argspec = object[0] or argspec\n            docstring = object[1] or \"\"\n        else:\n            docstring = pydoc.getdoc(object)\n\n        decl = title + argspec + (note and self.grey(\n               '<font face=\"helvetica, arial\">%s</font>' % note))\n\n        doc = self.markup(\n            docstring, self.preformat, funcs, classes, methods)\n        doc = doc and '<dd><tt>%s</tt></dd>' % doc\n        return '<dl><dt>%s</dt>%s</dl>\\n' % (decl, doc)\n\n    def docserver(self, server_name, package_documentation, methods):\n        \"\"\"Produce HTML documentation for an XML-RPC server.\"\"\"\n\n        fdict = {}\n        for key, value in methods.items():\n            fdict[key] = '#-' + key\n            fdict[value] = fdict[key]\n\n        server_name = self.escape(server_name)\n        head = '<big><big><strong>%s</strong></big></big>' % server_name\n        result = self.heading(head, '#ffffff', '#7799ee')\n\n        doc = self.markup(package_documentation, self.preformat, fdict)\n        doc = doc and '<tt>%s</tt>' % doc\n        result = result + '<p>%s</p>\\n' % doc\n\n        contents = []\n        method_items = sorted(methods.items())\n        for key, value in method_items:\n            contents.append(self.docroutine(value, key, funcs=fdict))\n        result = result + self.bigsection(\n            'Methods', '#ffffff', '#eeaa77', ''.join(contents))\n\n        return result\n\nclass XMLRPCDocGenerator:\n    \"\"\"Generates documentation for an XML-RPC server.\n\n    This class is designed as mix-in and should not\n    be constructed directly.\n    \"\"\"\n\n    def __init__(self):\n        # setup variables used for HTML documentation\n        self.server_name = 'XML-RPC Server Documentation'\n        self.server_documentation = \\\n            \"This server exports the following methods through the XML-RPC \"\\\n            \"protocol.\"\n        self.server_title = 'XML-RPC Server Documentation'\n\n    def set_server_title(self, server_title):\n        \"\"\"Set the HTML title of the generated server documentation\"\"\"\n\n        self.server_title = server_title\n\n    def set_server_name(self, server_name):\n        \"\"\"Set the name of the generated HTML server documentation\"\"\"\n\n        self.server_name = server_name\n\n    def set_server_documentation(self, server_documentation):\n        \"\"\"Set the documentation string for the entire server.\"\"\"\n\n        self.server_documentation = server_documentation\n\n    def generate_html_documentation(self):\n        \"\"\"generate_html_documentation() => html documentation for the server\n\n        Generates HTML documentation for the server using introspection for\n        installed functions and instances that do not implement the\n        _dispatch method. Alternatively, instances can choose to implement\n        the _get_method_argstring(method_name) method to provide the\n        argument string used in the documentation and the\n        _methodHelp(method_name) method to provide the help text used\n        in the documentation.\"\"\"\n\n        methods = {}\n\n        for method_name in self.system_listMethods():\n            if method_name in self.funcs:\n                method = self.funcs[method_name]\n            elif self.instance is not None:\n                method_info = [None, None] # argspec, documentation\n                if hasattr(self.instance, '_get_method_argstring'):\n                    method_info[0] = self.instance._get_method_argstring(method_name)\n                if hasattr(self.instance, '_methodHelp'):\n                    method_info[1] = self.instance._methodHelp(method_name)\n\n                method_info = tuple(method_info)\n                if method_info != (None, None):\n                    method = method_info\n                elif not hasattr(self.instance, '_dispatch'):\n                    try:\n                        method = resolve_dotted_attribute(\n                                    self.instance,\n                                    method_name\n                                    )\n                    except AttributeError:\n                        method = method_info\n                else:\n                    method = method_info\n            else:\n                assert 0, \"Could not find method in self.functions and no \"\\\n                          \"instance installed\"\n\n            methods[method_name] = method\n\n        documenter = ServerHTMLDoc()\n        documentation = documenter.docserver(\n                                self.server_name,\n                                self.server_documentation,\n                                methods\n                            )\n\n        return documenter.page(self.server_title, documentation)\n\nclass DocXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):\n    \"\"\"XML-RPC and documentation request handler class.\n\n    Handles all HTTP POST requests and attempts to decode them as\n    XML-RPC requests.\n\n    Handles all HTTP GET requests and interprets them as requests\n    for documentation.\n    \"\"\"\n\n    def do_GET(self):\n        \"\"\"Handles the HTTP GET request.\n\n        Interpret all HTTP GET requests as requests for server\n        documentation.\n        \"\"\"\n        # Check that the path is legal\n        if not self.is_rpc_path_valid():\n            self.report_404()\n            return\n\n        response = self.server.generate_html_documentation().encode('utf-8')\n        self.send_response(200)\n        self.send_header(\"Content-type\", \"text/html\")\n        self.send_header(\"Content-length\", str(len(response)))\n        self.end_headers()\n        self.wfile.write(response)\n\n        # shut down the connection\n        self.wfile.flush()\n        self.connection.shutdown(1)\n\nclass DocXMLRPCServer(  SimpleXMLRPCServer,\n                        XMLRPCDocGenerator):\n    \"\"\"XML-RPC and HTML documentation server.\n\n    Adds the ability to serve server documentation to the capabilities\n    of SimpleXMLRPCServer.\n    \"\"\"\n\n    def __init__(self, addr, requestHandler=DocXMLRPCRequestHandler,\n                 logRequests=True, allow_none=False, encoding=None,\n                 bind_and_activate=True):\n        SimpleXMLRPCServer.__init__(self, addr, requestHandler, logRequests,\n                                    allow_none, encoding, bind_and_activate)\n        XMLRPCDocGenerator.__init__(self)\n\nclass DocCGIXMLRPCRequestHandler(   CGIXMLRPCRequestHandler,\n                                    XMLRPCDocGenerator):\n    \"\"\"Handler for XML-RPC data and documentation requests passed through\n    CGI\"\"\"\n\n    def handle_get(self):\n        \"\"\"Handles the HTTP GET request.\n\n        Interpret all HTTP GET requests as requests for server\n        documentation.\n        \"\"\"\n\n        response = self.generate_html_documentation().encode('utf-8')\n\n        print('Content-Type: text/html')\n        print('Content-Length: %d' % len(response))\n        print()\n        sys.stdout.flush()\n        sys.stdout.buffer.write(response)\n        sys.stdout.buffer.flush()\n\n    def __init__(self):\n        CGIXMLRPCRequestHandler.__init__(self)\n        XMLRPCDocGenerator.__init__(self)\n\n\nif __name__ == '__main__':\n    print('Running XML-RPC server on port 8000')\n    server = SimpleXMLRPCServer((\"localhost\", 8000))\n    server.register_function(pow)\n    server.register_function(lambda x,y: x+y, 'add')\n    server.serve_forever()\n"
  },
  {
    "patch": "diff --git a/Lib/SimpleXMLRPCServer.py b/Lib/SimpleXMLRPCServer.py\nindex 6af2f2f7e0b..23ad5bd670f 100644\n--- a/Lib/SimpleXMLRPCServer.py\n+++ b/Lib/SimpleXMLRPCServer.py\n@@ -459,7 +459,10 @@ def do_POST(self):\n             L = []\n             while size_remaining:\n                 chunk_size = min(size_remaining, max_chunk_size)\n-                L.append(self.rfile.read(chunk_size))\n+                chunk = self.rfile.read(chunk_size)\n+                if not chunk:\n+                    break\n+                L.append(chunk)\n                 size_remaining -= len(L[-1])\n             data = ''.join(L)\n \n",
    "commit_message": "Issue #14001: CVE-2012-0845: xmlrpc: Fix an endless loop in SimpleXMLRPCServer\nupon malformed POST request.\n\n",
    "code_before": "\"\"\"Simple XML-RPC Server.\n\nThis module can be used to create simple XML-RPC servers\nby creating a server and either installing functions, a\nclass instance, or by extending the SimpleXMLRPCServer\nclass.\n\nIt can also be used to handle XML-RPC requests in a CGI\nenvironment using CGIXMLRPCRequestHandler.\n\nA list of possible usage patterns follows:\n\n1. Install functions:\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_function(pow)\nserver.register_function(lambda x,y: x+y, 'add')\nserver.serve_forever()\n\n2. Install an instance:\n\nclass MyFuncs:\n    def __init__(self):\n        # make all of the string functions available through\n        # string.func_name\n        import string\n        self.string = string\n    def _listMethods(self):\n        # implement this method so that system.listMethods\n        # knows to advertise the strings methods\n        return list_public_methods(self) + \\\n                ['string.' + method for method in list_public_methods(self.string)]\n    def pow(self, x, y): return pow(x, y)\n    def add(self, x, y) : return x + y\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_introspection_functions()\nserver.register_instance(MyFuncs())\nserver.serve_forever()\n\n3. Install an instance with custom dispatch method:\n\nclass Math:\n    def _listMethods(self):\n        # this method must be present for system.listMethods\n        # to work\n        return ['add', 'pow']\n    def _methodHelp(self, method):\n        # this method must be present for system.methodHelp\n        # to work\n        if method == 'add':\n            return \"add(2,3) => 5\"\n        elif method == 'pow':\n            return \"pow(x, y[, z]) => number\"\n        else:\n            # By convention, return empty\n            # string if no help is available\n            return \"\"\n    def _dispatch(self, method, params):\n        if method == 'pow':\n            return pow(*params)\n        elif method == 'add':\n            return params[0] + params[1]\n        else:\n            raise 'bad method'\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_introspection_functions()\nserver.register_instance(Math())\nserver.serve_forever()\n\n4. Subclass SimpleXMLRPCServer:\n\nclass MathServer(SimpleXMLRPCServer):\n    def _dispatch(self, method, params):\n        try:\n            # We are forcing the 'export_' prefix on methods that are\n            # callable through XML-RPC to prevent potential security\n            # problems\n            func = getattr(self, 'export_' + method)\n        except AttributeError:\n            raise Exception('method \"%s\" is not supported' % method)\n        else:\n            return func(*params)\n\n    def export_add(self, x, y):\n        return x + y\n\nserver = MathServer((\"localhost\", 8000))\nserver.serve_forever()\n\n5. CGI script:\n\nserver = CGIXMLRPCRequestHandler()\nserver.register_function(pow)\nserver.handle_request()\n\"\"\"\n\n# Written by Brian Quinlan (brian@sweetapp.com).\n# Based on code written by Fredrik Lundh.\n\nimport xmlrpclib\nfrom xmlrpclib import Fault\nimport SocketServer\nimport BaseHTTPServer\nimport sys\nimport os\nimport traceback\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\ndef resolve_dotted_attribute(obj, attr, allow_dotted_names=True):\n    \"\"\"resolve_dotted_attribute(a, 'b.c.d') => a.b.c.d\n\n    Resolves a dotted attribute name to an object.  Raises\n    an AttributeError if any attribute in the chain starts with a '_'.\n\n    If the optional allow_dotted_names argument is false, dots are not\n    supported and this function operates similar to getattr(obj, attr).\n    \"\"\"\n\n    if allow_dotted_names:\n        attrs = attr.split('.')\n    else:\n        attrs = [attr]\n\n    for i in attrs:\n        if i.startswith('_'):\n            raise AttributeError(\n                'attempt to access private attribute \"%s\"' % i\n                )\n        else:\n            obj = getattr(obj,i)\n    return obj\n\ndef list_public_methods(obj):\n    \"\"\"Returns a list of attribute strings, found in the specified\n    object, which represent callable attributes\"\"\"\n\n    return [member for member in dir(obj)\n                if not member.startswith('_') and\n                    hasattr(getattr(obj, member), '__call__')]\n\ndef remove_duplicates(lst):\n    \"\"\"remove_duplicates([2,2,2,1,3,3]) => [3,1,2]\n\n    Returns a copy of a list without duplicates. Every list\n    item must be hashable and the order of the items in the\n    resulting list is not defined.\n    \"\"\"\n    u = {}\n    for x in lst:\n        u[x] = 1\n\n    return u.keys()\n\nclass SimpleXMLRPCDispatcher:\n    \"\"\"Mix-in class that dispatches XML-RPC requests.\n\n    This class is used to register XML-RPC method handlers\n    and then to dispatch them. There should never be any\n    reason to instantiate this class directly.\n    \"\"\"\n\n    def __init__(self, allow_none=False, encoding=None):\n        self.funcs = {}\n        self.instance = None\n        self.allow_none = allow_none\n        self.encoding = encoding\n\n    def register_instance(self, instance, allow_dotted_names=False):\n        \"\"\"Registers an instance to respond to XML-RPC requests.\n\n        Only one instance can be installed at a time.\n\n        If the registered instance has a _dispatch method then that\n        method will be called with the name of the XML-RPC method and\n        its parameters as a tuple\n        e.g. instance._dispatch('add',(2,3))\n\n        If the registered instance does not have a _dispatch method\n        then the instance will be searched to find a matching method\n        and, if found, will be called. Methods beginning with an '_'\n        are considered private and will not be called by\n        SimpleXMLRPCServer.\n\n        If a registered function matches a XML-RPC request, then it\n        will be called instead of the registered instance.\n\n        If the optional allow_dotted_names argument is true and the\n        instance does not have a _dispatch method, method names\n        containing dots are supported and resolved, as long as none of\n        the name segments start with an '_'.\n\n            *** SECURITY WARNING: ***\n\n            Enabling the allow_dotted_names options allows intruders\n            to access your module's global variables and may allow\n            intruders to execute arbitrary code on your machine.  Only\n            use this option on a secure, closed network.\n\n        \"\"\"\n\n        self.instance = instance\n        self.allow_dotted_names = allow_dotted_names\n\n    def register_function(self, function, name = None):\n        \"\"\"Registers a function to respond to XML-RPC requests.\n\n        The optional name argument can be used to set a Unicode name\n        for the function.\n        \"\"\"\n\n        if name is None:\n            name = function.__name__\n        self.funcs[name] = function\n\n    def register_introspection_functions(self):\n        \"\"\"Registers the XML-RPC introspection methods in the system\n        namespace.\n\n        see http://xmlrpc.usefulinc.com/doc/reserved.html\n        \"\"\"\n\n        self.funcs.update({'system.listMethods' : self.system_listMethods,\n                      'system.methodSignature' : self.system_methodSignature,\n                      'system.methodHelp' : self.system_methodHelp})\n\n    def register_multicall_functions(self):\n        \"\"\"Registers the XML-RPC multicall method in the system\n        namespace.\n\n        see http://www.xmlrpc.com/discuss/msgReader$1208\"\"\"\n\n        self.funcs.update({'system.multicall' : self.system_multicall})\n\n    def _marshaled_dispatch(self, data, dispatch_method = None):\n        \"\"\"Dispatches an XML-RPC method from marshalled (XML) data.\n\n        XML-RPC methods are dispatched from the marshalled (XML) data\n        using the _dispatch method and the result is returned as\n        marshalled data. For backwards compatibility, a dispatch\n        function can be provided as an argument (see comment in\n        SimpleXMLRPCRequestHandler.do_POST) but overriding the\n        existing method through subclassing is the prefered means\n        of changing method dispatch behavior.\n        \"\"\"\n\n        try:\n            params, method = xmlrpclib.loads(data)\n\n            # generate response\n            if dispatch_method is not None:\n                response = dispatch_method(method, params)\n            else:\n                response = self._dispatch(method, params)\n            # wrap response in a singleton tuple\n            response = (response,)\n            response = xmlrpclib.dumps(response, methodresponse=1,\n                                       allow_none=self.allow_none, encoding=self.encoding)\n        except Fault, fault:\n            response = xmlrpclib.dumps(fault, allow_none=self.allow_none,\n                                       encoding=self.encoding)\n        except:\n            # report exception back to server\n            exc_type, exc_value, exc_tb = sys.exc_info()\n            response = xmlrpclib.dumps(\n                xmlrpclib.Fault(1, \"%s:%s\" % (exc_type, exc_value)),\n                encoding=self.encoding, allow_none=self.allow_none,\n                )\n\n        return response\n\n    def system_listMethods(self):\n        \"\"\"system.listMethods() => ['add', 'subtract', 'multiple']\n\n        Returns a list of the methods supported by the server.\"\"\"\n\n        methods = self.funcs.keys()\n        if self.instance is not None:\n            # Instance can implement _listMethod to return a list of\n            # methods\n            if hasattr(self.instance, '_listMethods'):\n                methods = remove_duplicates(\n                        methods + self.instance._listMethods()\n                    )\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide a list\n            # of methods\n            elif not hasattr(self.instance, '_dispatch'):\n                methods = remove_duplicates(\n                        methods + list_public_methods(self.instance)\n                    )\n        methods.sort()\n        return methods\n\n    def system_methodSignature(self, method_name):\n        \"\"\"system.methodSignature('add') => [double, int, int]\n\n        Returns a list describing the signature of the method. In the\n        above example, the add method takes two integers as arguments\n        and returns a double result.\n\n        This server does NOT support system.methodSignature.\"\"\"\n\n        # See http://xmlrpc.usefulinc.com/doc/sysmethodsig.html\n\n        return 'signatures not supported'\n\n    def system_methodHelp(self, method_name):\n        \"\"\"system.methodHelp('add') => \"Adds two integers together\"\n\n        Returns a string containing documentation for the specified method.\"\"\"\n\n        method = None\n        if method_name in self.funcs:\n            method = self.funcs[method_name]\n        elif self.instance is not None:\n            # Instance can implement _methodHelp to return help for a method\n            if hasattr(self.instance, '_methodHelp'):\n                return self.instance._methodHelp(method_name)\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide help\n            elif not hasattr(self.instance, '_dispatch'):\n                try:\n                    method = resolve_dotted_attribute(\n                                self.instance,\n                                method_name,\n                                self.allow_dotted_names\n                                )\n                except AttributeError:\n                    pass\n\n        # Note that we aren't checking that the method actually\n        # be a callable object of some kind\n        if method is None:\n            return \"\"\n        else:\n            import pydoc\n            return pydoc.getdoc(method)\n\n    def system_multicall(self, call_list):\n        \"\"\"system.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => \\\n[[4], ...]\n\n        Allows the caller to package multiple XML-RPC calls into a single\n        request.\n\n        See http://www.xmlrpc.com/discuss/msgReader$1208\n        \"\"\"\n\n        results = []\n        for call in call_list:\n            method_name = call['methodName']\n            params = call['params']\n\n            try:\n                # XXX A marshalling error in any response will fail the entire\n                # multicall. If someone cares they should fix this.\n                results.append([self._dispatch(method_name, params)])\n            except Fault, fault:\n                results.append(\n                    {'faultCode' : fault.faultCode,\n                     'faultString' : fault.faultString}\n                    )\n            except:\n                exc_type, exc_value, exc_tb = sys.exc_info()\n                results.append(\n                    {'faultCode' : 1,\n                     'faultString' : \"%s:%s\" % (exc_type, exc_value)}\n                    )\n        return results\n\n    def _dispatch(self, method, params):\n        \"\"\"Dispatches the XML-RPC method.\n\n        XML-RPC calls are forwarded to a registered function that\n        matches the called XML-RPC method name. If no such function\n        exists then the call is forwarded to the registered instance,\n        if available.\n\n        If the registered instance has a _dispatch method then that\n        method will be called with the name of the XML-RPC method and\n        its parameters as a tuple\n        e.g. instance._dispatch('add',(2,3))\n\n        If the registered instance does not have a _dispatch method\n        then the instance will be searched to find a matching method\n        and, if found, will be called.\n\n        Methods beginning with an '_' are considered private and will\n        not be called.\n        \"\"\"\n\n        func = None\n        try:\n            # check to see if a matching function has been registered\n            func = self.funcs[method]\n        except KeyError:\n            if self.instance is not None:\n                # check for a _dispatch method\n                if hasattr(self.instance, '_dispatch'):\n                    return self.instance._dispatch(method, params)\n                else:\n                    # call instance method directly\n                    try:\n                        func = resolve_dotted_attribute(\n                            self.instance,\n                            method,\n                            self.allow_dotted_names\n                            )\n                    except AttributeError:\n                        pass\n\n        if func is not None:\n            return func(*params)\n        else:\n            raise Exception('method \"%s\" is not supported' % method)\n\nclass SimpleXMLRPCRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):\n    \"\"\"Simple XML-RPC request handler class.\n\n    Handles all HTTP POST requests and attempts to decode them as\n    XML-RPC requests.\n    \"\"\"\n\n    # Class attribute listing the accessible path components;\n    # paths not on this list will result in a 404 error.\n    rpc_paths = ('/', '/RPC2')\n\n    def is_rpc_path_valid(self):\n        if self.rpc_paths:\n            return self.path in self.rpc_paths\n        else:\n            # If .rpc_paths is empty, just assume all paths are legal\n            return True\n\n    def do_POST(self):\n        \"\"\"Handles the HTTP POST request.\n\n        Attempts to interpret all HTTP POST requests as XML-RPC calls,\n        which are forwarded to the server's _dispatch method for handling.\n        \"\"\"\n\n        # Check that the path is legal\n        if not self.is_rpc_path_valid():\n            self.report_404()\n            return\n\n        try:\n            # Get arguments by reading body of request.\n            # We read this in chunks to avoid straining\n            # socket.read(); around the 10 or 15Mb mark, some platforms\n            # begin to have problems (bug #792570).\n            max_chunk_size = 10*1024*1024\n            size_remaining = int(self.headers[\"content-length\"])\n            L = []\n            while size_remaining:\n                chunk_size = min(size_remaining, max_chunk_size)\n                L.append(self.rfile.read(chunk_size))\n                size_remaining -= len(L[-1])\n            data = ''.join(L)\n\n            # In previous versions of SimpleXMLRPCServer, _dispatch\n            # could be overridden in this class, instead of in\n            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,\n            # check to see if a subclass implements _dispatch and dispatch\n            # using that method if present.\n            response = self.server._marshaled_dispatch(\n                    data, getattr(self, '_dispatch', None)\n                )\n        except Exception, e: # This should only happen if the module is buggy\n            # internal error, report as HTTP server error\n            self.send_response(500)\n\n            # Send information about the exception if requested\n            if hasattr(self.server, '_send_traceback_header') and \\\n                    self.server._send_traceback_header:\n                self.send_header(\"X-exception\", str(e))\n                self.send_header(\"X-traceback\", traceback.format_exc())\n\n            self.end_headers()\n        else:\n            # got a valid XML RPC response\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"text/xml\")\n            self.send_header(\"Content-length\", str(len(response)))\n            self.end_headers()\n            self.wfile.write(response)\n\n            # shut down the connection\n            self.wfile.flush()\n            self.connection.shutdown(1)\n\n    def report_404 (self):\n            # Report a 404 error\n        self.send_response(404)\n        response = 'No such page'\n        self.send_header(\"Content-type\", \"text/plain\")\n        self.send_header(\"Content-length\", str(len(response)))\n        self.end_headers()\n        self.wfile.write(response)\n        # shut down the connection\n        self.wfile.flush()\n        self.connection.shutdown(1)\n\n    def log_request(self, code='-', size='-'):\n        \"\"\"Selectively log an accepted request.\"\"\"\n\n        if self.server.logRequests:\n            BaseHTTPServer.BaseHTTPRequestHandler.log_request(self, code, size)\n\nclass SimpleXMLRPCServer(SocketServer.TCPServer,\n                         SimpleXMLRPCDispatcher):\n    \"\"\"Simple XML-RPC server.\n\n    Simple XML-RPC server that allows functions and a single instance\n    to be installed to handle requests. The default implementation\n    attempts to dispatch XML-RPC calls to the functions or instance\n    installed in the server. Override the _dispatch method inhereted\n    from SimpleXMLRPCDispatcher to change this behavior.\n    \"\"\"\n\n    allow_reuse_address = True\n\n    # Warning: this is for debugging purposes only! Never set this to True in\n    # production code, as will be sending out sensitive information (exception\n    # and stack trace details) when exceptions are raised inside\n    # SimpleXMLRPCRequestHandler.do_POST\n    _send_traceback_header = False\n\n    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,\n                 logRequests=True, allow_none=False, encoding=None, bind_and_activate=True):\n        self.logRequests = logRequests\n\n        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)\n        SocketServer.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)\n\n        # [Bug #1222790] If possible, set close-on-exec flag; if a\n        # method spawns a subprocess, the subprocess shouldn't have\n        # the listening socket open.\n        if fcntl is not None and hasattr(fcntl, 'FD_CLOEXEC'):\n            flags = fcntl.fcntl(self.fileno(), fcntl.F_GETFD)\n            flags |= fcntl.FD_CLOEXEC\n            fcntl.fcntl(self.fileno(), fcntl.F_SETFD, flags)\n\nclass CGIXMLRPCRequestHandler(SimpleXMLRPCDispatcher):\n    \"\"\"Simple handler for XML-RPC data passed through CGI.\"\"\"\n\n    def __init__(self, allow_none=False, encoding=None):\n        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)\n\n    def handle_xmlrpc(self, request_text):\n        \"\"\"Handle a single XML-RPC request\"\"\"\n\n        response = self._marshaled_dispatch(request_text)\n\n        print 'Content-Type: text/xml'\n        print 'Content-Length: %d' % len(response)\n        print\n        sys.stdout.write(response)\n\n    def handle_get(self):\n        \"\"\"Handle a single HTTP GET request.\n\n        Default implementation indicates an error because\n        XML-RPC uses the POST method.\n        \"\"\"\n\n        code = 400\n        message, explain = \\\n                 BaseHTTPServer.BaseHTTPRequestHandler.responses[code]\n\n        response = BaseHTTPServer.DEFAULT_ERROR_MESSAGE % \\\n            {\n             'code' : code,\n             'message' : message,\n             'explain' : explain\n            }\n        print 'Status: %d %s' % (code, message)\n        print 'Content-Type: text/html'\n        print 'Content-Length: %d' % len(response)\n        print\n        sys.stdout.write(response)\n\n    def handle_request(self, request_text = None):\n        \"\"\"Handle a single XML-RPC request passed through a CGI post method.\n\n        If no XML data is given then it is read from stdin. The resulting\n        XML-RPC response is printed to stdout along with the correct HTTP\n        headers.\n        \"\"\"\n\n        if request_text is None and \\\n            os.environ.get('REQUEST_METHOD', None) == 'GET':\n            self.handle_get()\n        else:\n            # POST data is normally available through stdin\n            try:\n                length = int(os.environ.get('CONTENT_LENGTH', None))\n            except (TypeError, ValueError):\n                length = -1\n            if request_text is None:\n                request_text = sys.stdin.read(length)\n\n            self.handle_xmlrpc(request_text)\n\nif __name__ == '__main__':\n    print 'Running XML-RPC server on port 8000'\n    server = SimpleXMLRPCServer((\"localhost\", 8000))\n    server.register_function(pow)\n    server.register_function(lambda x,y: x+y, 'add')\n    server.serve_forever()\n",
    "code_after": "\"\"\"Simple XML-RPC Server.\n\nThis module can be used to create simple XML-RPC servers\nby creating a server and either installing functions, a\nclass instance, or by extending the SimpleXMLRPCServer\nclass.\n\nIt can also be used to handle XML-RPC requests in a CGI\nenvironment using CGIXMLRPCRequestHandler.\n\nA list of possible usage patterns follows:\n\n1. Install functions:\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_function(pow)\nserver.register_function(lambda x,y: x+y, 'add')\nserver.serve_forever()\n\n2. Install an instance:\n\nclass MyFuncs:\n    def __init__(self):\n        # make all of the string functions available through\n        # string.func_name\n        import string\n        self.string = string\n    def _listMethods(self):\n        # implement this method so that system.listMethods\n        # knows to advertise the strings methods\n        return list_public_methods(self) + \\\n                ['string.' + method for method in list_public_methods(self.string)]\n    def pow(self, x, y): return pow(x, y)\n    def add(self, x, y) : return x + y\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_introspection_functions()\nserver.register_instance(MyFuncs())\nserver.serve_forever()\n\n3. Install an instance with custom dispatch method:\n\nclass Math:\n    def _listMethods(self):\n        # this method must be present for system.listMethods\n        # to work\n        return ['add', 'pow']\n    def _methodHelp(self, method):\n        # this method must be present for system.methodHelp\n        # to work\n        if method == 'add':\n            return \"add(2,3) => 5\"\n        elif method == 'pow':\n            return \"pow(x, y[, z]) => number\"\n        else:\n            # By convention, return empty\n            # string if no help is available\n            return \"\"\n    def _dispatch(self, method, params):\n        if method == 'pow':\n            return pow(*params)\n        elif method == 'add':\n            return params[0] + params[1]\n        else:\n            raise 'bad method'\n\nserver = SimpleXMLRPCServer((\"localhost\", 8000))\nserver.register_introspection_functions()\nserver.register_instance(Math())\nserver.serve_forever()\n\n4. Subclass SimpleXMLRPCServer:\n\nclass MathServer(SimpleXMLRPCServer):\n    def _dispatch(self, method, params):\n        try:\n            # We are forcing the 'export_' prefix on methods that are\n            # callable through XML-RPC to prevent potential security\n            # problems\n            func = getattr(self, 'export_' + method)\n        except AttributeError:\n            raise Exception('method \"%s\" is not supported' % method)\n        else:\n            return func(*params)\n\n    def export_add(self, x, y):\n        return x + y\n\nserver = MathServer((\"localhost\", 8000))\nserver.serve_forever()\n\n5. CGI script:\n\nserver = CGIXMLRPCRequestHandler()\nserver.register_function(pow)\nserver.handle_request()\n\"\"\"\n\n# Written by Brian Quinlan (brian@sweetapp.com).\n# Based on code written by Fredrik Lundh.\n\nimport xmlrpclib\nfrom xmlrpclib import Fault\nimport SocketServer\nimport BaseHTTPServer\nimport sys\nimport os\nimport traceback\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\ndef resolve_dotted_attribute(obj, attr, allow_dotted_names=True):\n    \"\"\"resolve_dotted_attribute(a, 'b.c.d') => a.b.c.d\n\n    Resolves a dotted attribute name to an object.  Raises\n    an AttributeError if any attribute in the chain starts with a '_'.\n\n    If the optional allow_dotted_names argument is false, dots are not\n    supported and this function operates similar to getattr(obj, attr).\n    \"\"\"\n\n    if allow_dotted_names:\n        attrs = attr.split('.')\n    else:\n        attrs = [attr]\n\n    for i in attrs:\n        if i.startswith('_'):\n            raise AttributeError(\n                'attempt to access private attribute \"%s\"' % i\n                )\n        else:\n            obj = getattr(obj,i)\n    return obj\n\ndef list_public_methods(obj):\n    \"\"\"Returns a list of attribute strings, found in the specified\n    object, which represent callable attributes\"\"\"\n\n    return [member for member in dir(obj)\n                if not member.startswith('_') and\n                    hasattr(getattr(obj, member), '__call__')]\n\ndef remove_duplicates(lst):\n    \"\"\"remove_duplicates([2,2,2,1,3,3]) => [3,1,2]\n\n    Returns a copy of a list without duplicates. Every list\n    item must be hashable and the order of the items in the\n    resulting list is not defined.\n    \"\"\"\n    u = {}\n    for x in lst:\n        u[x] = 1\n\n    return u.keys()\n\nclass SimpleXMLRPCDispatcher:\n    \"\"\"Mix-in class that dispatches XML-RPC requests.\n\n    This class is used to register XML-RPC method handlers\n    and then to dispatch them. There should never be any\n    reason to instantiate this class directly.\n    \"\"\"\n\n    def __init__(self, allow_none=False, encoding=None):\n        self.funcs = {}\n        self.instance = None\n        self.allow_none = allow_none\n        self.encoding = encoding\n\n    def register_instance(self, instance, allow_dotted_names=False):\n        \"\"\"Registers an instance to respond to XML-RPC requests.\n\n        Only one instance can be installed at a time.\n\n        If the registered instance has a _dispatch method then that\n        method will be called with the name of the XML-RPC method and\n        its parameters as a tuple\n        e.g. instance._dispatch('add',(2,3))\n\n        If the registered instance does not have a _dispatch method\n        then the instance will be searched to find a matching method\n        and, if found, will be called. Methods beginning with an '_'\n        are considered private and will not be called by\n        SimpleXMLRPCServer.\n\n        If a registered function matches a XML-RPC request, then it\n        will be called instead of the registered instance.\n\n        If the optional allow_dotted_names argument is true and the\n        instance does not have a _dispatch method, method names\n        containing dots are supported and resolved, as long as none of\n        the name segments start with an '_'.\n\n            *** SECURITY WARNING: ***\n\n            Enabling the allow_dotted_names options allows intruders\n            to access your module's global variables and may allow\n            intruders to execute arbitrary code on your machine.  Only\n            use this option on a secure, closed network.\n\n        \"\"\"\n\n        self.instance = instance\n        self.allow_dotted_names = allow_dotted_names\n\n    def register_function(self, function, name = None):\n        \"\"\"Registers a function to respond to XML-RPC requests.\n\n        The optional name argument can be used to set a Unicode name\n        for the function.\n        \"\"\"\n\n        if name is None:\n            name = function.__name__\n        self.funcs[name] = function\n\n    def register_introspection_functions(self):\n        \"\"\"Registers the XML-RPC introspection methods in the system\n        namespace.\n\n        see http://xmlrpc.usefulinc.com/doc/reserved.html\n        \"\"\"\n\n        self.funcs.update({'system.listMethods' : self.system_listMethods,\n                      'system.methodSignature' : self.system_methodSignature,\n                      'system.methodHelp' : self.system_methodHelp})\n\n    def register_multicall_functions(self):\n        \"\"\"Registers the XML-RPC multicall method in the system\n        namespace.\n\n        see http://www.xmlrpc.com/discuss/msgReader$1208\"\"\"\n\n        self.funcs.update({'system.multicall' : self.system_multicall})\n\n    def _marshaled_dispatch(self, data, dispatch_method = None):\n        \"\"\"Dispatches an XML-RPC method from marshalled (XML) data.\n\n        XML-RPC methods are dispatched from the marshalled (XML) data\n        using the _dispatch method and the result is returned as\n        marshalled data. For backwards compatibility, a dispatch\n        function can be provided as an argument (see comment in\n        SimpleXMLRPCRequestHandler.do_POST) but overriding the\n        existing method through subclassing is the prefered means\n        of changing method dispatch behavior.\n        \"\"\"\n\n        try:\n            params, method = xmlrpclib.loads(data)\n\n            # generate response\n            if dispatch_method is not None:\n                response = dispatch_method(method, params)\n            else:\n                response = self._dispatch(method, params)\n            # wrap response in a singleton tuple\n            response = (response,)\n            response = xmlrpclib.dumps(response, methodresponse=1,\n                                       allow_none=self.allow_none, encoding=self.encoding)\n        except Fault, fault:\n            response = xmlrpclib.dumps(fault, allow_none=self.allow_none,\n                                       encoding=self.encoding)\n        except:\n            # report exception back to server\n            exc_type, exc_value, exc_tb = sys.exc_info()\n            response = xmlrpclib.dumps(\n                xmlrpclib.Fault(1, \"%s:%s\" % (exc_type, exc_value)),\n                encoding=self.encoding, allow_none=self.allow_none,\n                )\n\n        return response\n\n    def system_listMethods(self):\n        \"\"\"system.listMethods() => ['add', 'subtract', 'multiple']\n\n        Returns a list of the methods supported by the server.\"\"\"\n\n        methods = self.funcs.keys()\n        if self.instance is not None:\n            # Instance can implement _listMethod to return a list of\n            # methods\n            if hasattr(self.instance, '_listMethods'):\n                methods = remove_duplicates(\n                        methods + self.instance._listMethods()\n                    )\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide a list\n            # of methods\n            elif not hasattr(self.instance, '_dispatch'):\n                methods = remove_duplicates(\n                        methods + list_public_methods(self.instance)\n                    )\n        methods.sort()\n        return methods\n\n    def system_methodSignature(self, method_name):\n        \"\"\"system.methodSignature('add') => [double, int, int]\n\n        Returns a list describing the signature of the method. In the\n        above example, the add method takes two integers as arguments\n        and returns a double result.\n\n        This server does NOT support system.methodSignature.\"\"\"\n\n        # See http://xmlrpc.usefulinc.com/doc/sysmethodsig.html\n\n        return 'signatures not supported'\n\n    def system_methodHelp(self, method_name):\n        \"\"\"system.methodHelp('add') => \"Adds two integers together\"\n\n        Returns a string containing documentation for the specified method.\"\"\"\n\n        method = None\n        if method_name in self.funcs:\n            method = self.funcs[method_name]\n        elif self.instance is not None:\n            # Instance can implement _methodHelp to return help for a method\n            if hasattr(self.instance, '_methodHelp'):\n                return self.instance._methodHelp(method_name)\n            # if the instance has a _dispatch method then we\n            # don't have enough information to provide help\n            elif not hasattr(self.instance, '_dispatch'):\n                try:\n                    method = resolve_dotted_attribute(\n                                self.instance,\n                                method_name,\n                                self.allow_dotted_names\n                                )\n                except AttributeError:\n                    pass\n\n        # Note that we aren't checking that the method actually\n        # be a callable object of some kind\n        if method is None:\n            return \"\"\n        else:\n            import pydoc\n            return pydoc.getdoc(method)\n\n    def system_multicall(self, call_list):\n        \"\"\"system.multicall([{'methodName': 'add', 'params': [2, 2]}, ...]) => \\\n[[4], ...]\n\n        Allows the caller to package multiple XML-RPC calls into a single\n        request.\n\n        See http://www.xmlrpc.com/discuss/msgReader$1208\n        \"\"\"\n\n        results = []\n        for call in call_list:\n            method_name = call['methodName']\n            params = call['params']\n\n            try:\n                # XXX A marshalling error in any response will fail the entire\n                # multicall. If someone cares they should fix this.\n                results.append([self._dispatch(method_name, params)])\n            except Fault, fault:\n                results.append(\n                    {'faultCode' : fault.faultCode,\n                     'faultString' : fault.faultString}\n                    )\n            except:\n                exc_type, exc_value, exc_tb = sys.exc_info()\n                results.append(\n                    {'faultCode' : 1,\n                     'faultString' : \"%s:%s\" % (exc_type, exc_value)}\n                    )\n        return results\n\n    def _dispatch(self, method, params):\n        \"\"\"Dispatches the XML-RPC method.\n\n        XML-RPC calls are forwarded to a registered function that\n        matches the called XML-RPC method name. If no such function\n        exists then the call is forwarded to the registered instance,\n        if available.\n\n        If the registered instance has a _dispatch method then that\n        method will be called with the name of the XML-RPC method and\n        its parameters as a tuple\n        e.g. instance._dispatch('add',(2,3))\n\n        If the registered instance does not have a _dispatch method\n        then the instance will be searched to find a matching method\n        and, if found, will be called.\n\n        Methods beginning with an '_' are considered private and will\n        not be called.\n        \"\"\"\n\n        func = None\n        try:\n            # check to see if a matching function has been registered\n            func = self.funcs[method]\n        except KeyError:\n            if self.instance is not None:\n                # check for a _dispatch method\n                if hasattr(self.instance, '_dispatch'):\n                    return self.instance._dispatch(method, params)\n                else:\n                    # call instance method directly\n                    try:\n                        func = resolve_dotted_attribute(\n                            self.instance,\n                            method,\n                            self.allow_dotted_names\n                            )\n                    except AttributeError:\n                        pass\n\n        if func is not None:\n            return func(*params)\n        else:\n            raise Exception('method \"%s\" is not supported' % method)\n\nclass SimpleXMLRPCRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):\n    \"\"\"Simple XML-RPC request handler class.\n\n    Handles all HTTP POST requests and attempts to decode them as\n    XML-RPC requests.\n    \"\"\"\n\n    # Class attribute listing the accessible path components;\n    # paths not on this list will result in a 404 error.\n    rpc_paths = ('/', '/RPC2')\n\n    def is_rpc_path_valid(self):\n        if self.rpc_paths:\n            return self.path in self.rpc_paths\n        else:\n            # If .rpc_paths is empty, just assume all paths are legal\n            return True\n\n    def do_POST(self):\n        \"\"\"Handles the HTTP POST request.\n\n        Attempts to interpret all HTTP POST requests as XML-RPC calls,\n        which are forwarded to the server's _dispatch method for handling.\n        \"\"\"\n\n        # Check that the path is legal\n        if not self.is_rpc_path_valid():\n            self.report_404()\n            return\n\n        try:\n            # Get arguments by reading body of request.\n            # We read this in chunks to avoid straining\n            # socket.read(); around the 10 or 15Mb mark, some platforms\n            # begin to have problems (bug #792570).\n            max_chunk_size = 10*1024*1024\n            size_remaining = int(self.headers[\"content-length\"])\n            L = []\n            while size_remaining:\n                chunk_size = min(size_remaining, max_chunk_size)\n                chunk = self.rfile.read(chunk_size)\n                if not chunk:\n                    break\n                L.append(chunk)\n                size_remaining -= len(L[-1])\n            data = ''.join(L)\n\n            # In previous versions of SimpleXMLRPCServer, _dispatch\n            # could be overridden in this class, instead of in\n            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,\n            # check to see if a subclass implements _dispatch and dispatch\n            # using that method if present.\n            response = self.server._marshaled_dispatch(\n                    data, getattr(self, '_dispatch', None)\n                )\n        except Exception, e: # This should only happen if the module is buggy\n            # internal error, report as HTTP server error\n            self.send_response(500)\n\n            # Send information about the exception if requested\n            if hasattr(self.server, '_send_traceback_header') and \\\n                    self.server._send_traceback_header:\n                self.send_header(\"X-exception\", str(e))\n                self.send_header(\"X-traceback\", traceback.format_exc())\n\n            self.end_headers()\n        else:\n            # got a valid XML RPC response\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"text/xml\")\n            self.send_header(\"Content-length\", str(len(response)))\n            self.end_headers()\n            self.wfile.write(response)\n\n            # shut down the connection\n            self.wfile.flush()\n            self.connection.shutdown(1)\n\n    def report_404 (self):\n            # Report a 404 error\n        self.send_response(404)\n        response = 'No such page'\n        self.send_header(\"Content-type\", \"text/plain\")\n        self.send_header(\"Content-length\", str(len(response)))\n        self.end_headers()\n        self.wfile.write(response)\n        # shut down the connection\n        self.wfile.flush()\n        self.connection.shutdown(1)\n\n    def log_request(self, code='-', size='-'):\n        \"\"\"Selectively log an accepted request.\"\"\"\n\n        if self.server.logRequests:\n            BaseHTTPServer.BaseHTTPRequestHandler.log_request(self, code, size)\n\nclass SimpleXMLRPCServer(SocketServer.TCPServer,\n                         SimpleXMLRPCDispatcher):\n    \"\"\"Simple XML-RPC server.\n\n    Simple XML-RPC server that allows functions and a single instance\n    to be installed to handle requests. The default implementation\n    attempts to dispatch XML-RPC calls to the functions or instance\n    installed in the server. Override the _dispatch method inhereted\n    from SimpleXMLRPCDispatcher to change this behavior.\n    \"\"\"\n\n    allow_reuse_address = True\n\n    # Warning: this is for debugging purposes only! Never set this to True in\n    # production code, as will be sending out sensitive information (exception\n    # and stack trace details) when exceptions are raised inside\n    # SimpleXMLRPCRequestHandler.do_POST\n    _send_traceback_header = False\n\n    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,\n                 logRequests=True, allow_none=False, encoding=None, bind_and_activate=True):\n        self.logRequests = logRequests\n\n        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)\n        SocketServer.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)\n\n        # [Bug #1222790] If possible, set close-on-exec flag; if a\n        # method spawns a subprocess, the subprocess shouldn't have\n        # the listening socket open.\n        if fcntl is not None and hasattr(fcntl, 'FD_CLOEXEC'):\n            flags = fcntl.fcntl(self.fileno(), fcntl.F_GETFD)\n            flags |= fcntl.FD_CLOEXEC\n            fcntl.fcntl(self.fileno(), fcntl.F_SETFD, flags)\n\nclass CGIXMLRPCRequestHandler(SimpleXMLRPCDispatcher):\n    \"\"\"Simple handler for XML-RPC data passed through CGI.\"\"\"\n\n    def __init__(self, allow_none=False, encoding=None):\n        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding)\n\n    def handle_xmlrpc(self, request_text):\n        \"\"\"Handle a single XML-RPC request\"\"\"\n\n        response = self._marshaled_dispatch(request_text)\n\n        print 'Content-Type: text/xml'\n        print 'Content-Length: %d' % len(response)\n        print\n        sys.stdout.write(response)\n\n    def handle_get(self):\n        \"\"\"Handle a single HTTP GET request.\n\n        Default implementation indicates an error because\n        XML-RPC uses the POST method.\n        \"\"\"\n\n        code = 400\n        message, explain = \\\n                 BaseHTTPServer.BaseHTTPRequestHandler.responses[code]\n\n        response = BaseHTTPServer.DEFAULT_ERROR_MESSAGE % \\\n            {\n             'code' : code,\n             'message' : message,\n             'explain' : explain\n            }\n        print 'Status: %d %s' % (code, message)\n        print 'Content-Type: text/html'\n        print 'Content-Length: %d' % len(response)\n        print\n        sys.stdout.write(response)\n\n    def handle_request(self, request_text = None):\n        \"\"\"Handle a single XML-RPC request passed through a CGI post method.\n\n        If no XML data is given then it is read from stdin. The resulting\n        XML-RPC response is printed to stdout along with the correct HTTP\n        headers.\n        \"\"\"\n\n        if request_text is None and \\\n            os.environ.get('REQUEST_METHOD', None) == 'GET':\n            self.handle_get()\n        else:\n            # POST data is normally available through stdin\n            try:\n                length = int(os.environ.get('CONTENT_LENGTH', None))\n            except (TypeError, ValueError):\n                length = -1\n            if request_text is None:\n                request_text = sys.stdin.read(length)\n\n            self.handle_xmlrpc(request_text)\n\nif __name__ == '__main__':\n    print 'Running XML-RPC server on port 8000'\n    server = SimpleXMLRPCServer((\"localhost\", 8000))\n    server.register_function(pow)\n    server.register_function(lambda x,y: x+y, 'add')\n    server.serve_forever()\n"
  },
  {
    "patch": "diff --git a/Lib/test/test_audioop.py b/Lib/test/test_audioop.py\nindex 1cd80a157d4..308c3e314b5 100644\n--- a/Lib/test/test_audioop.py\n+++ b/Lib/test/test_audioop.py\n@@ -20,6 +20,12 @@ def gendata4():\n \n data = [gendata1(), gendata2(), gendata4()]\n \n+INVALID_DATA = [\n+    ('abc', 0),\n+    ('abc', 2),\n+    ('abc', 4),\n+]\n+\n \n class TestAudioop(unittest.TestCase):\n \n@@ -168,6 +174,33 @@ def test_negativelen(self):\n         self.assertRaises(audioop.error,\n             audioop.findmax, ''.join(chr(x) for x in range(256)), -2392392)\n \n+    def test_issue7673(self):\n+        state = None\n+        for data, size in INVALID_DATA:\n+            size2 = size\n+            self.assertRaises(audioop.error, audioop.getsample, data, size, 0)\n+            self.assertRaises(audioop.error, audioop.max, data, size)\n+            self.assertRaises(audioop.error, audioop.minmax, data, size)\n+            self.assertRaises(audioop.error, audioop.avg, data, size)\n+            self.assertRaises(audioop.error, audioop.rms, data, size)\n+            self.assertRaises(audioop.error, audioop.avgpp, data, size)\n+            self.assertRaises(audioop.error, audioop.maxpp, data, size)\n+            self.assertRaises(audioop.error, audioop.cross, data, size)\n+            self.assertRaises(audioop.error, audioop.mul, data, size, 1.0)\n+            self.assertRaises(audioop.error, audioop.tomono, data, size, 0.5, 0.5)\n+            self.assertRaises(audioop.error, audioop.tostereo, data, size, 0.5, 0.5)\n+            self.assertRaises(audioop.error, audioop.add, data, data, size)\n+            self.assertRaises(audioop.error, audioop.bias, data, size, 0)\n+            self.assertRaises(audioop.error, audioop.reverse, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2lin, data, size, size2)\n+            self.assertRaises(audioop.error, audioop.ratecv, data, size, 1, 1, 1, state)\n+            self.assertRaises(audioop.error, audioop.lin2ulaw, data, size)\n+            self.assertRaises(audioop.error, audioop.ulaw2lin, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2alaw, data, size)\n+            self.assertRaises(audioop.error, audioop.alaw2lin, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2adpcm, data, size, state)\n+            self.assertRaises(audioop.error, audioop.adpcm2lin, data, size, state)\n+\n def test_main():\n     run_unittest(TestAudioop)\n \n",
    "commit_message": "Merged revisions 82495 via svnmerge from\nsvn+ssh://pythondev@svn.python.org/python/branches/py3k\n\n................\n  r82495 | victor.stinner | 2010-07-03 15:44:22 +0200 (sam., 03 juil. 2010) | 10 lines\n\n  Merged revisions 82492 via svnmerge from\n  svn+ssh://pythondev@svn.python.org/python/trunk\n\n  ........\n    r82492 | victor.stinner | 2010-07-03 15:36:19 +0200 (sam., 03 juil. 2010) | 3 lines\n\n    Issue #7673: Fix security vulnerability (CVE-2010-2089) in the audioop module,\n    ensure that the input string length is a multiple of the frame size\n  ........\n................\n\n",
    "code_before": "import audioop\nimport unittest\nfrom test.support import run_unittest\n\n\ndef gendata1():\n    return b'\\0\\1\\2'\n\ndef gendata2():\n    if audioop.getsample(b'\\0\\1', 2, 0) == 1:\n        return b'\\0\\0\\0\\1\\0\\2'\n    else:\n        return b'\\0\\0\\1\\0\\2\\0'\n\ndef gendata4():\n    if audioop.getsample(b'\\0\\0\\0\\1', 4, 0) == 1:\n        return b'\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\2'\n    else:\n        return b'\\0\\0\\0\\0\\1\\0\\0\\0\\2\\0\\0\\0'\n\ndata = [gendata1(), gendata2(), gendata4()]\n\n\nclass TestAudioop(unittest.TestCase):\n\n    def test_max(self):\n        self.assertEqual(audioop.max(data[0], 1), 2)\n        self.assertEqual(audioop.max(data[1], 2), 2)\n        self.assertEqual(audioop.max(data[2], 4), 2)\n\n    def test_minmax(self):\n        self.assertEqual(audioop.minmax(data[0], 1), (0, 2))\n        self.assertEqual(audioop.minmax(data[1], 2), (0, 2))\n        self.assertEqual(audioop.minmax(data[2], 4), (0, 2))\n\n    def test_maxpp(self):\n        self.assertEqual(audioop.maxpp(data[0], 1), 0)\n        self.assertEqual(audioop.maxpp(data[1], 2), 0)\n        self.assertEqual(audioop.maxpp(data[2], 4), 0)\n\n    def test_avg(self):\n        self.assertEqual(audioop.avg(data[0], 1), 1)\n        self.assertEqual(audioop.avg(data[1], 2), 1)\n        self.assertEqual(audioop.avg(data[2], 4), 1)\n\n    def test_avgpp(self):\n        self.assertEqual(audioop.avgpp(data[0], 1), 0)\n        self.assertEqual(audioop.avgpp(data[1], 2), 0)\n        self.assertEqual(audioop.avgpp(data[2], 4), 0)\n\n    def test_rms(self):\n        self.assertEqual(audioop.rms(data[0], 1), 1)\n        self.assertEqual(audioop.rms(data[1], 2), 1)\n        self.assertEqual(audioop.rms(data[2], 4), 1)\n\n    def test_cross(self):\n        self.assertEqual(audioop.cross(data[0], 1), 0)\n        self.assertEqual(audioop.cross(data[1], 2), 0)\n        self.assertEqual(audioop.cross(data[2], 4), 0)\n\n    def test_add(self):\n        data2 = []\n        for d in data:\n            str = bytearray(len(d))\n            for i,b in enumerate(d):\n                str[i] = 2*b\n            data2.append(str)\n        self.assertEqual(audioop.add(data[0], data[0], 1), data2[0])\n        self.assertEqual(audioop.add(data[1], data[1], 2), data2[1])\n        self.assertEqual(audioop.add(data[2], data[2], 4), data2[2])\n\n    def test_bias(self):\n        # Note: this test assumes that avg() works\n        d1 = audioop.bias(data[0], 1, 100)\n        d2 = audioop.bias(data[1], 2, 100)\n        d4 = audioop.bias(data[2], 4, 100)\n        self.assertEqual(audioop.avg(d1, 1), 101)\n        self.assertEqual(audioop.avg(d2, 2), 101)\n        self.assertEqual(audioop.avg(d4, 4), 101)\n\n    def test_lin2lin(self):\n        # too simple: we test only the size\n        for d1 in data:\n            for d2 in data:\n                got = len(d1)//3\n                wtd = len(d2)//3\n                self.assertEqual(len(audioop.lin2lin(d1, got, wtd)), len(d2))\n\n    def test_adpcm2lin(self):\n        # Very cursory test\n        self.assertEqual(audioop.adpcm2lin(b'\\0\\0', 1, None), (b'\\0\\0\\0\\0', (0,0)))\n\n    def test_lin2adpcm(self):\n        # Very cursory test\n        self.assertEqual(audioop.lin2adpcm(b'\\0\\0\\0\\0', 1, None), (b'\\0\\0', (0,0)))\n\n    def test_lin2alaw(self):\n        self.assertEqual(audioop.lin2alaw(data[0], 1), b'\\xd5\\xc5\\xf5')\n        self.assertEqual(audioop.lin2alaw(data[1], 2), b'\\xd5\\xd5\\xd5')\n        self.assertEqual(audioop.lin2alaw(data[2], 4), b'\\xd5\\xd5\\xd5')\n\n    def test_alaw2lin(self):\n        # Cursory\n        d = audioop.lin2alaw(data[0], 1)\n        self.assertEqual(audioop.alaw2lin(d, 1), data[0])\n\n    def test_lin2ulaw(self):\n        self.assertEqual(audioop.lin2ulaw(data[0], 1), b'\\xff\\xe7\\xdb')\n        self.assertEqual(audioop.lin2ulaw(data[1], 2), b'\\xff\\xff\\xff')\n        self.assertEqual(audioop.lin2ulaw(data[2], 4), b'\\xff\\xff\\xff')\n\n    def test_ulaw2lin(self):\n        # Cursory\n        d = audioop.lin2ulaw(data[0], 1)\n        self.assertEqual(audioop.ulaw2lin(d, 1), data[0])\n\n    def test_mul(self):\n        data2 = []\n        for d in data:\n            str = bytearray(len(d))\n            for i,b in enumerate(d):\n                str[i] = 2*b\n            data2.append(str)\n        self.assertEqual(audioop.mul(data[0], 1, 2), data2[0])\n        self.assertEqual(audioop.mul(data[1],2, 2), data2[1])\n        self.assertEqual(audioop.mul(data[2], 4, 2), data2[2])\n\n    def test_ratecv(self):\n        state = None\n        d1, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        d2, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        self.assertEqual(d1 + d2, b'\\000\\000\\001\\001\\002\\001\\000\\000\\001\\001\\002')\n\n    def test_reverse(self):\n        self.assertEqual(audioop.reverse(data[0], 1), b'\\2\\1\\0')\n\n    def test_tomono(self):\n        data2 = bytearray()\n        for d in data[0]:\n            data2.append(d)\n            data2.append(d)\n        self.assertEqual(audioop.tomono(data2, 1, 0.5, 0.5), data[0])\n\n    def test_tostereo(self):\n        data2 = bytearray()\n        for d in data[0]:\n            data2.append(d)\n            data2.append(d)\n        self.assertEqual(audioop.tostereo(data[0], 1, 1, 1), data2)\n\n    def test_findfactor(self):\n        self.assertEqual(audioop.findfactor(data[1], data[1]), 1.0)\n\n    def test_findfit(self):\n        self.assertEqual(audioop.findfit(data[1], data[1]), (0, 1.0))\n\n    def test_findmax(self):\n        self.assertEqual(audioop.findmax(data[1], 1), 2)\n\n    def test_getsample(self):\n        for i in range(3):\n            self.assertEqual(audioop.getsample(data[0], 1, i), i)\n            self.assertEqual(audioop.getsample(data[1], 2, i), i)\n            self.assertEqual(audioop.getsample(data[2], 4, i), i)\n\n    def test_negativelen(self):\n        # from issue 3306, previously it segfaulted\n        self.assertRaises(audioop.error,\n            audioop.findmax, ''.join(chr(x) for x in range(256)), -2392392)\n\ndef test_main():\n    run_unittest(TestAudioop)\n\nif __name__ == '__main__':\n    test_main()\n",
    "code_after": "import audioop\nimport unittest\nfrom test.support import run_unittest\n\n\ndef gendata1():\n    return b'\\0\\1\\2'\n\ndef gendata2():\n    if audioop.getsample(b'\\0\\1', 2, 0) == 1:\n        return b'\\0\\0\\0\\1\\0\\2'\n    else:\n        return b'\\0\\0\\1\\0\\2\\0'\n\ndef gendata4():\n    if audioop.getsample(b'\\0\\0\\0\\1', 4, 0) == 1:\n        return b'\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\2'\n    else:\n        return b'\\0\\0\\0\\0\\1\\0\\0\\0\\2\\0\\0\\0'\n\ndata = [gendata1(), gendata2(), gendata4()]\n\nINVALID_DATA = [\n    ('abc', 0),\n    ('abc', 2),\n    ('abc', 4),\n]\n\n\nclass TestAudioop(unittest.TestCase):\n\n    def test_max(self):\n        self.assertEqual(audioop.max(data[0], 1), 2)\n        self.assertEqual(audioop.max(data[1], 2), 2)\n        self.assertEqual(audioop.max(data[2], 4), 2)\n\n    def test_minmax(self):\n        self.assertEqual(audioop.minmax(data[0], 1), (0, 2))\n        self.assertEqual(audioop.minmax(data[1], 2), (0, 2))\n        self.assertEqual(audioop.minmax(data[2], 4), (0, 2))\n\n    def test_maxpp(self):\n        self.assertEqual(audioop.maxpp(data[0], 1), 0)\n        self.assertEqual(audioop.maxpp(data[1], 2), 0)\n        self.assertEqual(audioop.maxpp(data[2], 4), 0)\n\n    def test_avg(self):\n        self.assertEqual(audioop.avg(data[0], 1), 1)\n        self.assertEqual(audioop.avg(data[1], 2), 1)\n        self.assertEqual(audioop.avg(data[2], 4), 1)\n\n    def test_avgpp(self):\n        self.assertEqual(audioop.avgpp(data[0], 1), 0)\n        self.assertEqual(audioop.avgpp(data[1], 2), 0)\n        self.assertEqual(audioop.avgpp(data[2], 4), 0)\n\n    def test_rms(self):\n        self.assertEqual(audioop.rms(data[0], 1), 1)\n        self.assertEqual(audioop.rms(data[1], 2), 1)\n        self.assertEqual(audioop.rms(data[2], 4), 1)\n\n    def test_cross(self):\n        self.assertEqual(audioop.cross(data[0], 1), 0)\n        self.assertEqual(audioop.cross(data[1], 2), 0)\n        self.assertEqual(audioop.cross(data[2], 4), 0)\n\n    def test_add(self):\n        data2 = []\n        for d in data:\n            str = bytearray(len(d))\n            for i,b in enumerate(d):\n                str[i] = 2*b\n            data2.append(str)\n        self.assertEqual(audioop.add(data[0], data[0], 1), data2[0])\n        self.assertEqual(audioop.add(data[1], data[1], 2), data2[1])\n        self.assertEqual(audioop.add(data[2], data[2], 4), data2[2])\n\n    def test_bias(self):\n        # Note: this test assumes that avg() works\n        d1 = audioop.bias(data[0], 1, 100)\n        d2 = audioop.bias(data[1], 2, 100)\n        d4 = audioop.bias(data[2], 4, 100)\n        self.assertEqual(audioop.avg(d1, 1), 101)\n        self.assertEqual(audioop.avg(d2, 2), 101)\n        self.assertEqual(audioop.avg(d4, 4), 101)\n\n    def test_lin2lin(self):\n        # too simple: we test only the size\n        for d1 in data:\n            for d2 in data:\n                got = len(d1)//3\n                wtd = len(d2)//3\n                self.assertEqual(len(audioop.lin2lin(d1, got, wtd)), len(d2))\n\n    def test_adpcm2lin(self):\n        # Very cursory test\n        self.assertEqual(audioop.adpcm2lin(b'\\0\\0', 1, None), (b'\\0\\0\\0\\0', (0,0)))\n\n    def test_lin2adpcm(self):\n        # Very cursory test\n        self.assertEqual(audioop.lin2adpcm(b'\\0\\0\\0\\0', 1, None), (b'\\0\\0', (0,0)))\n\n    def test_lin2alaw(self):\n        self.assertEqual(audioop.lin2alaw(data[0], 1), b'\\xd5\\xc5\\xf5')\n        self.assertEqual(audioop.lin2alaw(data[1], 2), b'\\xd5\\xd5\\xd5')\n        self.assertEqual(audioop.lin2alaw(data[2], 4), b'\\xd5\\xd5\\xd5')\n\n    def test_alaw2lin(self):\n        # Cursory\n        d = audioop.lin2alaw(data[0], 1)\n        self.assertEqual(audioop.alaw2lin(d, 1), data[0])\n\n    def test_lin2ulaw(self):\n        self.assertEqual(audioop.lin2ulaw(data[0], 1), b'\\xff\\xe7\\xdb')\n        self.assertEqual(audioop.lin2ulaw(data[1], 2), b'\\xff\\xff\\xff')\n        self.assertEqual(audioop.lin2ulaw(data[2], 4), b'\\xff\\xff\\xff')\n\n    def test_ulaw2lin(self):\n        # Cursory\n        d = audioop.lin2ulaw(data[0], 1)\n        self.assertEqual(audioop.ulaw2lin(d, 1), data[0])\n\n    def test_mul(self):\n        data2 = []\n        for d in data:\n            str = bytearray(len(d))\n            for i,b in enumerate(d):\n                str[i] = 2*b\n            data2.append(str)\n        self.assertEqual(audioop.mul(data[0], 1, 2), data2[0])\n        self.assertEqual(audioop.mul(data[1],2, 2), data2[1])\n        self.assertEqual(audioop.mul(data[2], 4, 2), data2[2])\n\n    def test_ratecv(self):\n        state = None\n        d1, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        d2, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        self.assertEqual(d1 + d2, b'\\000\\000\\001\\001\\002\\001\\000\\000\\001\\001\\002')\n\n    def test_reverse(self):\n        self.assertEqual(audioop.reverse(data[0], 1), b'\\2\\1\\0')\n\n    def test_tomono(self):\n        data2 = bytearray()\n        for d in data[0]:\n            data2.append(d)\n            data2.append(d)\n        self.assertEqual(audioop.tomono(data2, 1, 0.5, 0.5), data[0])\n\n    def test_tostereo(self):\n        data2 = bytearray()\n        for d in data[0]:\n            data2.append(d)\n            data2.append(d)\n        self.assertEqual(audioop.tostereo(data[0], 1, 1, 1), data2)\n\n    def test_findfactor(self):\n        self.assertEqual(audioop.findfactor(data[1], data[1]), 1.0)\n\n    def test_findfit(self):\n        self.assertEqual(audioop.findfit(data[1], data[1]), (0, 1.0))\n\n    def test_findmax(self):\n        self.assertEqual(audioop.findmax(data[1], 1), 2)\n\n    def test_getsample(self):\n        for i in range(3):\n            self.assertEqual(audioop.getsample(data[0], 1, i), i)\n            self.assertEqual(audioop.getsample(data[1], 2, i), i)\n            self.assertEqual(audioop.getsample(data[2], 4, i), i)\n\n    def test_negativelen(self):\n        # from issue 3306, previously it segfaulted\n        self.assertRaises(audioop.error,\n            audioop.findmax, ''.join(chr(x) for x in range(256)), -2392392)\n\n    def test_issue7673(self):\n        state = None\n        for data, size in INVALID_DATA:\n            size2 = size\n            self.assertRaises(audioop.error, audioop.getsample, data, size, 0)\n            self.assertRaises(audioop.error, audioop.max, data, size)\n            self.assertRaises(audioop.error, audioop.minmax, data, size)\n            self.assertRaises(audioop.error, audioop.avg, data, size)\n            self.assertRaises(audioop.error, audioop.rms, data, size)\n            self.assertRaises(audioop.error, audioop.avgpp, data, size)\n            self.assertRaises(audioop.error, audioop.maxpp, data, size)\n            self.assertRaises(audioop.error, audioop.cross, data, size)\n            self.assertRaises(audioop.error, audioop.mul, data, size, 1.0)\n            self.assertRaises(audioop.error, audioop.tomono, data, size, 0.5, 0.5)\n            self.assertRaises(audioop.error, audioop.tostereo, data, size, 0.5, 0.5)\n            self.assertRaises(audioop.error, audioop.add, data, data, size)\n            self.assertRaises(audioop.error, audioop.bias, data, size, 0)\n            self.assertRaises(audioop.error, audioop.reverse, data, size)\n            self.assertRaises(audioop.error, audioop.lin2lin, data, size, size2)\n            self.assertRaises(audioop.error, audioop.ratecv, data, size, 1, 1, 1, state)\n            self.assertRaises(audioop.error, audioop.lin2ulaw, data, size)\n            self.assertRaises(audioop.error, audioop.ulaw2lin, data, size)\n            self.assertRaises(audioop.error, audioop.lin2alaw, data, size)\n            self.assertRaises(audioop.error, audioop.alaw2lin, data, size)\n            self.assertRaises(audioop.error, audioop.lin2adpcm, data, size, state)\n            self.assertRaises(audioop.error, audioop.adpcm2lin, data, size, state)\n\ndef test_main():\n    run_unittest(TestAudioop)\n\nif __name__ == '__main__':\n    test_main()\n"
  },
  {
    "patch": "diff --git a/Lib/test/test_audioop.py b/Lib/test/test_audioop.py\nindex 1cd80a157d4..308c3e314b5 100644\n--- a/Lib/test/test_audioop.py\n+++ b/Lib/test/test_audioop.py\n@@ -20,6 +20,12 @@ def gendata4():\n \n data = [gendata1(), gendata2(), gendata4()]\n \n+INVALID_DATA = [\n+    ('abc', 0),\n+    ('abc', 2),\n+    ('abc', 4),\n+]\n+\n \n class TestAudioop(unittest.TestCase):\n \n@@ -168,6 +174,33 @@ def test_negativelen(self):\n         self.assertRaises(audioop.error,\n             audioop.findmax, ''.join(chr(x) for x in range(256)), -2392392)\n \n+    def test_issue7673(self):\n+        state = None\n+        for data, size in INVALID_DATA:\n+            size2 = size\n+            self.assertRaises(audioop.error, audioop.getsample, data, size, 0)\n+            self.assertRaises(audioop.error, audioop.max, data, size)\n+            self.assertRaises(audioop.error, audioop.minmax, data, size)\n+            self.assertRaises(audioop.error, audioop.avg, data, size)\n+            self.assertRaises(audioop.error, audioop.rms, data, size)\n+            self.assertRaises(audioop.error, audioop.avgpp, data, size)\n+            self.assertRaises(audioop.error, audioop.maxpp, data, size)\n+            self.assertRaises(audioop.error, audioop.cross, data, size)\n+            self.assertRaises(audioop.error, audioop.mul, data, size, 1.0)\n+            self.assertRaises(audioop.error, audioop.tomono, data, size, 0.5, 0.5)\n+            self.assertRaises(audioop.error, audioop.tostereo, data, size, 0.5, 0.5)\n+            self.assertRaises(audioop.error, audioop.add, data, data, size)\n+            self.assertRaises(audioop.error, audioop.bias, data, size, 0)\n+            self.assertRaises(audioop.error, audioop.reverse, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2lin, data, size, size2)\n+            self.assertRaises(audioop.error, audioop.ratecv, data, size, 1, 1, 1, state)\n+            self.assertRaises(audioop.error, audioop.lin2ulaw, data, size)\n+            self.assertRaises(audioop.error, audioop.ulaw2lin, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2alaw, data, size)\n+            self.assertRaises(audioop.error, audioop.alaw2lin, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2adpcm, data, size, state)\n+            self.assertRaises(audioop.error, audioop.adpcm2lin, data, size, state)\n+\n def test_main():\n     run_unittest(TestAudioop)\n \n",
    "commit_message": "Merged revisions 82492 via svnmerge from\nsvn+ssh://pythondev@svn.python.org/python/trunk\n\n........\n  r82492 | victor.stinner | 2010-07-03 15:36:19 +0200 (sam., 03 juil. 2010) | 3 lines\n\n  Issue #7673: Fix security vulnerability (CVE-2010-2089) in the audioop module,\n  ensure that the input string length is a multiple of the frame size\n........\n\n",
    "code_before": "import audioop\nimport unittest\nfrom test.support import run_unittest\n\n\ndef gendata1():\n    return b'\\0\\1\\2'\n\ndef gendata2():\n    if audioop.getsample(b'\\0\\1', 2, 0) == 1:\n        return b'\\0\\0\\0\\1\\0\\2'\n    else:\n        return b'\\0\\0\\1\\0\\2\\0'\n\ndef gendata4():\n    if audioop.getsample(b'\\0\\0\\0\\1', 4, 0) == 1:\n        return b'\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\2'\n    else:\n        return b'\\0\\0\\0\\0\\1\\0\\0\\0\\2\\0\\0\\0'\n\ndata = [gendata1(), gendata2(), gendata4()]\n\n\nclass TestAudioop(unittest.TestCase):\n\n    def test_max(self):\n        self.assertEqual(audioop.max(data[0], 1), 2)\n        self.assertEqual(audioop.max(data[1], 2), 2)\n        self.assertEqual(audioop.max(data[2], 4), 2)\n\n    def test_minmax(self):\n        self.assertEqual(audioop.minmax(data[0], 1), (0, 2))\n        self.assertEqual(audioop.minmax(data[1], 2), (0, 2))\n        self.assertEqual(audioop.minmax(data[2], 4), (0, 2))\n\n    def test_maxpp(self):\n        self.assertEqual(audioop.maxpp(data[0], 1), 0)\n        self.assertEqual(audioop.maxpp(data[1], 2), 0)\n        self.assertEqual(audioop.maxpp(data[2], 4), 0)\n\n    def test_avg(self):\n        self.assertEqual(audioop.avg(data[0], 1), 1)\n        self.assertEqual(audioop.avg(data[1], 2), 1)\n        self.assertEqual(audioop.avg(data[2], 4), 1)\n\n    def test_avgpp(self):\n        self.assertEqual(audioop.avgpp(data[0], 1), 0)\n        self.assertEqual(audioop.avgpp(data[1], 2), 0)\n        self.assertEqual(audioop.avgpp(data[2], 4), 0)\n\n    def test_rms(self):\n        self.assertEqual(audioop.rms(data[0], 1), 1)\n        self.assertEqual(audioop.rms(data[1], 2), 1)\n        self.assertEqual(audioop.rms(data[2], 4), 1)\n\n    def test_cross(self):\n        self.assertEqual(audioop.cross(data[0], 1), 0)\n        self.assertEqual(audioop.cross(data[1], 2), 0)\n        self.assertEqual(audioop.cross(data[2], 4), 0)\n\n    def test_add(self):\n        data2 = []\n        for d in data:\n            str = bytearray(len(d))\n            for i,b in enumerate(d):\n                str[i] = 2*b\n            data2.append(str)\n        self.assertEqual(audioop.add(data[0], data[0], 1), data2[0])\n        self.assertEqual(audioop.add(data[1], data[1], 2), data2[1])\n        self.assertEqual(audioop.add(data[2], data[2], 4), data2[2])\n\n    def test_bias(self):\n        # Note: this test assumes that avg() works\n        d1 = audioop.bias(data[0], 1, 100)\n        d2 = audioop.bias(data[1], 2, 100)\n        d4 = audioop.bias(data[2], 4, 100)\n        self.assertEqual(audioop.avg(d1, 1), 101)\n        self.assertEqual(audioop.avg(d2, 2), 101)\n        self.assertEqual(audioop.avg(d4, 4), 101)\n\n    def test_lin2lin(self):\n        # too simple: we test only the size\n        for d1 in data:\n            for d2 in data:\n                got = len(d1)//3\n                wtd = len(d2)//3\n                self.assertEqual(len(audioop.lin2lin(d1, got, wtd)), len(d2))\n\n    def test_adpcm2lin(self):\n        # Very cursory test\n        self.assertEqual(audioop.adpcm2lin(b'\\0\\0', 1, None), (b'\\0\\0\\0\\0', (0,0)))\n\n    def test_lin2adpcm(self):\n        # Very cursory test\n        self.assertEqual(audioop.lin2adpcm(b'\\0\\0\\0\\0', 1, None), (b'\\0\\0', (0,0)))\n\n    def test_lin2alaw(self):\n        self.assertEqual(audioop.lin2alaw(data[0], 1), b'\\xd5\\xc5\\xf5')\n        self.assertEqual(audioop.lin2alaw(data[1], 2), b'\\xd5\\xd5\\xd5')\n        self.assertEqual(audioop.lin2alaw(data[2], 4), b'\\xd5\\xd5\\xd5')\n\n    def test_alaw2lin(self):\n        # Cursory\n        d = audioop.lin2alaw(data[0], 1)\n        self.assertEqual(audioop.alaw2lin(d, 1), data[0])\n\n    def test_lin2ulaw(self):\n        self.assertEqual(audioop.lin2ulaw(data[0], 1), b'\\xff\\xe7\\xdb')\n        self.assertEqual(audioop.lin2ulaw(data[1], 2), b'\\xff\\xff\\xff')\n        self.assertEqual(audioop.lin2ulaw(data[2], 4), b'\\xff\\xff\\xff')\n\n    def test_ulaw2lin(self):\n        # Cursory\n        d = audioop.lin2ulaw(data[0], 1)\n        self.assertEqual(audioop.ulaw2lin(d, 1), data[0])\n\n    def test_mul(self):\n        data2 = []\n        for d in data:\n            str = bytearray(len(d))\n            for i,b in enumerate(d):\n                str[i] = 2*b\n            data2.append(str)\n        self.assertEqual(audioop.mul(data[0], 1, 2), data2[0])\n        self.assertEqual(audioop.mul(data[1],2, 2), data2[1])\n        self.assertEqual(audioop.mul(data[2], 4, 2), data2[2])\n\n    def test_ratecv(self):\n        state = None\n        d1, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        d2, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        self.assertEqual(d1 + d2, b'\\000\\000\\001\\001\\002\\001\\000\\000\\001\\001\\002')\n\n    def test_reverse(self):\n        self.assertEqual(audioop.reverse(data[0], 1), b'\\2\\1\\0')\n\n    def test_tomono(self):\n        data2 = bytearray()\n        for d in data[0]:\n            data2.append(d)\n            data2.append(d)\n        self.assertEqual(audioop.tomono(data2, 1, 0.5, 0.5), data[0])\n\n    def test_tostereo(self):\n        data2 = bytearray()\n        for d in data[0]:\n            data2.append(d)\n            data2.append(d)\n        self.assertEqual(audioop.tostereo(data[0], 1, 1, 1), data2)\n\n    def test_findfactor(self):\n        self.assertEqual(audioop.findfactor(data[1], data[1]), 1.0)\n\n    def test_findfit(self):\n        self.assertEqual(audioop.findfit(data[1], data[1]), (0, 1.0))\n\n    def test_findmax(self):\n        self.assertEqual(audioop.findmax(data[1], 1), 2)\n\n    def test_getsample(self):\n        for i in range(3):\n            self.assertEqual(audioop.getsample(data[0], 1, i), i)\n            self.assertEqual(audioop.getsample(data[1], 2, i), i)\n            self.assertEqual(audioop.getsample(data[2], 4, i), i)\n\n    def test_negativelen(self):\n        # from issue 3306, previously it segfaulted\n        self.assertRaises(audioop.error,\n            audioop.findmax, ''.join(chr(x) for x in range(256)), -2392392)\n\ndef test_main():\n    run_unittest(TestAudioop)\n\nif __name__ == '__main__':\n    test_main()\n",
    "code_after": "import audioop\nimport unittest\nfrom test.support import run_unittest\n\n\ndef gendata1():\n    return b'\\0\\1\\2'\n\ndef gendata2():\n    if audioop.getsample(b'\\0\\1', 2, 0) == 1:\n        return b'\\0\\0\\0\\1\\0\\2'\n    else:\n        return b'\\0\\0\\1\\0\\2\\0'\n\ndef gendata4():\n    if audioop.getsample(b'\\0\\0\\0\\1', 4, 0) == 1:\n        return b'\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\2'\n    else:\n        return b'\\0\\0\\0\\0\\1\\0\\0\\0\\2\\0\\0\\0'\n\ndata = [gendata1(), gendata2(), gendata4()]\n\nINVALID_DATA = [\n    ('abc', 0),\n    ('abc', 2),\n    ('abc', 4),\n]\n\n\nclass TestAudioop(unittest.TestCase):\n\n    def test_max(self):\n        self.assertEqual(audioop.max(data[0], 1), 2)\n        self.assertEqual(audioop.max(data[1], 2), 2)\n        self.assertEqual(audioop.max(data[2], 4), 2)\n\n    def test_minmax(self):\n        self.assertEqual(audioop.minmax(data[0], 1), (0, 2))\n        self.assertEqual(audioop.minmax(data[1], 2), (0, 2))\n        self.assertEqual(audioop.minmax(data[2], 4), (0, 2))\n\n    def test_maxpp(self):\n        self.assertEqual(audioop.maxpp(data[0], 1), 0)\n        self.assertEqual(audioop.maxpp(data[1], 2), 0)\n        self.assertEqual(audioop.maxpp(data[2], 4), 0)\n\n    def test_avg(self):\n        self.assertEqual(audioop.avg(data[0], 1), 1)\n        self.assertEqual(audioop.avg(data[1], 2), 1)\n        self.assertEqual(audioop.avg(data[2], 4), 1)\n\n    def test_avgpp(self):\n        self.assertEqual(audioop.avgpp(data[0], 1), 0)\n        self.assertEqual(audioop.avgpp(data[1], 2), 0)\n        self.assertEqual(audioop.avgpp(data[2], 4), 0)\n\n    def test_rms(self):\n        self.assertEqual(audioop.rms(data[0], 1), 1)\n        self.assertEqual(audioop.rms(data[1], 2), 1)\n        self.assertEqual(audioop.rms(data[2], 4), 1)\n\n    def test_cross(self):\n        self.assertEqual(audioop.cross(data[0], 1), 0)\n        self.assertEqual(audioop.cross(data[1], 2), 0)\n        self.assertEqual(audioop.cross(data[2], 4), 0)\n\n    def test_add(self):\n        data2 = []\n        for d in data:\n            str = bytearray(len(d))\n            for i,b in enumerate(d):\n                str[i] = 2*b\n            data2.append(str)\n        self.assertEqual(audioop.add(data[0], data[0], 1), data2[0])\n        self.assertEqual(audioop.add(data[1], data[1], 2), data2[1])\n        self.assertEqual(audioop.add(data[2], data[2], 4), data2[2])\n\n    def test_bias(self):\n        # Note: this test assumes that avg() works\n        d1 = audioop.bias(data[0], 1, 100)\n        d2 = audioop.bias(data[1], 2, 100)\n        d4 = audioop.bias(data[2], 4, 100)\n        self.assertEqual(audioop.avg(d1, 1), 101)\n        self.assertEqual(audioop.avg(d2, 2), 101)\n        self.assertEqual(audioop.avg(d4, 4), 101)\n\n    def test_lin2lin(self):\n        # too simple: we test only the size\n        for d1 in data:\n            for d2 in data:\n                got = len(d1)//3\n                wtd = len(d2)//3\n                self.assertEqual(len(audioop.lin2lin(d1, got, wtd)), len(d2))\n\n    def test_adpcm2lin(self):\n        # Very cursory test\n        self.assertEqual(audioop.adpcm2lin(b'\\0\\0', 1, None), (b'\\0\\0\\0\\0', (0,0)))\n\n    def test_lin2adpcm(self):\n        # Very cursory test\n        self.assertEqual(audioop.lin2adpcm(b'\\0\\0\\0\\0', 1, None), (b'\\0\\0', (0,0)))\n\n    def test_lin2alaw(self):\n        self.assertEqual(audioop.lin2alaw(data[0], 1), b'\\xd5\\xc5\\xf5')\n        self.assertEqual(audioop.lin2alaw(data[1], 2), b'\\xd5\\xd5\\xd5')\n        self.assertEqual(audioop.lin2alaw(data[2], 4), b'\\xd5\\xd5\\xd5')\n\n    def test_alaw2lin(self):\n        # Cursory\n        d = audioop.lin2alaw(data[0], 1)\n        self.assertEqual(audioop.alaw2lin(d, 1), data[0])\n\n    def test_lin2ulaw(self):\n        self.assertEqual(audioop.lin2ulaw(data[0], 1), b'\\xff\\xe7\\xdb')\n        self.assertEqual(audioop.lin2ulaw(data[1], 2), b'\\xff\\xff\\xff')\n        self.assertEqual(audioop.lin2ulaw(data[2], 4), b'\\xff\\xff\\xff')\n\n    def test_ulaw2lin(self):\n        # Cursory\n        d = audioop.lin2ulaw(data[0], 1)\n        self.assertEqual(audioop.ulaw2lin(d, 1), data[0])\n\n    def test_mul(self):\n        data2 = []\n        for d in data:\n            str = bytearray(len(d))\n            for i,b in enumerate(d):\n                str[i] = 2*b\n            data2.append(str)\n        self.assertEqual(audioop.mul(data[0], 1, 2), data2[0])\n        self.assertEqual(audioop.mul(data[1],2, 2), data2[1])\n        self.assertEqual(audioop.mul(data[2], 4, 2), data2[2])\n\n    def test_ratecv(self):\n        state = None\n        d1, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        d2, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        self.assertEqual(d1 + d2, b'\\000\\000\\001\\001\\002\\001\\000\\000\\001\\001\\002')\n\n    def test_reverse(self):\n        self.assertEqual(audioop.reverse(data[0], 1), b'\\2\\1\\0')\n\n    def test_tomono(self):\n        data2 = bytearray()\n        for d in data[0]:\n            data2.append(d)\n            data2.append(d)\n        self.assertEqual(audioop.tomono(data2, 1, 0.5, 0.5), data[0])\n\n    def test_tostereo(self):\n        data2 = bytearray()\n        for d in data[0]:\n            data2.append(d)\n            data2.append(d)\n        self.assertEqual(audioop.tostereo(data[0], 1, 1, 1), data2)\n\n    def test_findfactor(self):\n        self.assertEqual(audioop.findfactor(data[1], data[1]), 1.0)\n\n    def test_findfit(self):\n        self.assertEqual(audioop.findfit(data[1], data[1]), (0, 1.0))\n\n    def test_findmax(self):\n        self.assertEqual(audioop.findmax(data[1], 1), 2)\n\n    def test_getsample(self):\n        for i in range(3):\n            self.assertEqual(audioop.getsample(data[0], 1, i), i)\n            self.assertEqual(audioop.getsample(data[1], 2, i), i)\n            self.assertEqual(audioop.getsample(data[2], 4, i), i)\n\n    def test_negativelen(self):\n        # from issue 3306, previously it segfaulted\n        self.assertRaises(audioop.error,\n            audioop.findmax, ''.join(chr(x) for x in range(256)), -2392392)\n\n    def test_issue7673(self):\n        state = None\n        for data, size in INVALID_DATA:\n            size2 = size\n            self.assertRaises(audioop.error, audioop.getsample, data, size, 0)\n            self.assertRaises(audioop.error, audioop.max, data, size)\n            self.assertRaises(audioop.error, audioop.minmax, data, size)\n            self.assertRaises(audioop.error, audioop.avg, data, size)\n            self.assertRaises(audioop.error, audioop.rms, data, size)\n            self.assertRaises(audioop.error, audioop.avgpp, data, size)\n            self.assertRaises(audioop.error, audioop.maxpp, data, size)\n            self.assertRaises(audioop.error, audioop.cross, data, size)\n            self.assertRaises(audioop.error, audioop.mul, data, size, 1.0)\n            self.assertRaises(audioop.error, audioop.tomono, data, size, 0.5, 0.5)\n            self.assertRaises(audioop.error, audioop.tostereo, data, size, 0.5, 0.5)\n            self.assertRaises(audioop.error, audioop.add, data, data, size)\n            self.assertRaises(audioop.error, audioop.bias, data, size, 0)\n            self.assertRaises(audioop.error, audioop.reverse, data, size)\n            self.assertRaises(audioop.error, audioop.lin2lin, data, size, size2)\n            self.assertRaises(audioop.error, audioop.ratecv, data, size, 1, 1, 1, state)\n            self.assertRaises(audioop.error, audioop.lin2ulaw, data, size)\n            self.assertRaises(audioop.error, audioop.ulaw2lin, data, size)\n            self.assertRaises(audioop.error, audioop.lin2alaw, data, size)\n            self.assertRaises(audioop.error, audioop.alaw2lin, data, size)\n            self.assertRaises(audioop.error, audioop.lin2adpcm, data, size, state)\n            self.assertRaises(audioop.error, audioop.adpcm2lin, data, size, state)\n\ndef test_main():\n    run_unittest(TestAudioop)\n\nif __name__ == '__main__':\n    test_main()\n"
  },
  {
    "patch": "diff --git a/Lib/test/test_audioop.py b/Lib/test/test_audioop.py\nindex 7bc2cd67d51..e03ceb5b145 100644\n--- a/Lib/test/test_audioop.py\n+++ b/Lib/test/test_audioop.py\n@@ -20,6 +20,12 @@ def gendata4():\n \n data = [gendata1(), gendata2(), gendata4()]\n \n+INVALID_DATA = [\n+    ('abc', 0),\n+    ('abc', 2),\n+    ('abc', 4),\n+]\n+\n \n class TestAudioop(unittest.TestCase):\n \n@@ -166,6 +172,33 @@ def test_negativelen(self):\n         self.assertRaises(audioop.error,\n             audioop.findmax, ''.join( chr(x) for x in xrange(256)), -2392392)\n \n+    def test_issue7673(self):\n+        state = None\n+        for data, size in INVALID_DATA:\n+            size2 = size\n+            self.assertRaises(audioop.error, audioop.getsample, data, size, 0)\n+            self.assertRaises(audioop.error, audioop.max, data, size)\n+            self.assertRaises(audioop.error, audioop.minmax, data, size)\n+            self.assertRaises(audioop.error, audioop.avg, data, size)\n+            self.assertRaises(audioop.error, audioop.rms, data, size)\n+            self.assertRaises(audioop.error, audioop.avgpp, data, size)\n+            self.assertRaises(audioop.error, audioop.maxpp, data, size)\n+            self.assertRaises(audioop.error, audioop.cross, data, size)\n+            self.assertRaises(audioop.error, audioop.mul, data, size, 1.0)\n+            self.assertRaises(audioop.error, audioop.tomono, data, size, 0.5, 0.5)\n+            self.assertRaises(audioop.error, audioop.tostereo, data, size, 0.5, 0.5)\n+            self.assertRaises(audioop.error, audioop.add, data, data, size)\n+            self.assertRaises(audioop.error, audioop.bias, data, size, 0)\n+            self.assertRaises(audioop.error, audioop.reverse, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2lin, data, size, size2)\n+            self.assertRaises(audioop.error, audioop.ratecv, data, size, 1, 1, 1, state)\n+            self.assertRaises(audioop.error, audioop.lin2ulaw, data, size)\n+            self.assertRaises(audioop.error, audioop.ulaw2lin, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2alaw, data, size)\n+            self.assertRaises(audioop.error, audioop.alaw2lin, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2adpcm, data, size, state)\n+            self.assertRaises(audioop.error, audioop.adpcm2lin, data, size, state)\n+\n def test_main():\n     run_unittest(TestAudioop)\n \n",
    "commit_message": "Merged revisions 82492 via svnmerge from\nsvn+ssh://pythondev@svn.python.org/python/trunk\n\n........\n  r82492 | victor.stinner | 2010-07-03 15:36:19 +0200 (sam., 03 juil. 2010) | 3 lines\n\n  Issue #7673: Fix security vulnerability (CVE-2010-2089) in the audioop module,\n  ensure that the input string length is a multiple of the frame size\n........\n\n",
    "code_before": "import audioop\nimport unittest\nfrom test.test_support import run_unittest\n\n\ndef gendata1():\n    return '\\0\\1\\2'\n\ndef gendata2():\n    if audioop.getsample('\\0\\1', 2, 0) == 1:\n        return '\\0\\0\\0\\1\\0\\2'\n    else:\n        return '\\0\\0\\1\\0\\2\\0'\n\ndef gendata4():\n    if audioop.getsample('\\0\\0\\0\\1', 4, 0) == 1:\n        return '\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\2'\n    else:\n        return '\\0\\0\\0\\0\\1\\0\\0\\0\\2\\0\\0\\0'\n\ndata = [gendata1(), gendata2(), gendata4()]\n\n\nclass TestAudioop(unittest.TestCase):\n\n    def test_max(self):\n        self.assertEqual(audioop.max(data[0], 1), 2)\n        self.assertEqual(audioop.max(data[1], 2), 2)\n        self.assertEqual(audioop.max(data[2], 4), 2)\n\n    def test_minmax(self):\n        self.assertEqual(audioop.minmax(data[0], 1), (0, 2))\n        self.assertEqual(audioop.minmax(data[1], 2), (0, 2))\n        self.assertEqual(audioop.minmax(data[2], 4), (0, 2))\n\n    def test_maxpp(self):\n        self.assertEqual(audioop.maxpp(data[0], 1), 0)\n        self.assertEqual(audioop.maxpp(data[1], 2), 0)\n        self.assertEqual(audioop.maxpp(data[2], 4), 0)\n\n    def test_avg(self):\n        self.assertEqual(audioop.avg(data[0], 1), 1)\n        self.assertEqual(audioop.avg(data[1], 2), 1)\n        self.assertEqual(audioop.avg(data[2], 4), 1)\n\n    def test_avgpp(self):\n        self.assertEqual(audioop.avgpp(data[0], 1), 0)\n        self.assertEqual(audioop.avgpp(data[1], 2), 0)\n        self.assertEqual(audioop.avgpp(data[2], 4), 0)\n\n    def test_rms(self):\n        self.assertEqual(audioop.rms(data[0], 1), 1)\n        self.assertEqual(audioop.rms(data[1], 2), 1)\n        self.assertEqual(audioop.rms(data[2], 4), 1)\n\n    def test_cross(self):\n        self.assertEqual(audioop.cross(data[0], 1), 0)\n        self.assertEqual(audioop.cross(data[1], 2), 0)\n        self.assertEqual(audioop.cross(data[2], 4), 0)\n\n    def test_add(self):\n        data2 = []\n        for d in data:\n            str = ''\n            for s in d:\n                str = str + chr(ord(s)*2)\n            data2.append(str)\n        self.assertEqual(audioop.add(data[0], data[0], 1), data2[0])\n        self.assertEqual(audioop.add(data[1], data[1], 2), data2[1])\n        self.assertEqual(audioop.add(data[2], data[2], 4), data2[2])\n\n    def test_bias(self):\n        # Note: this test assumes that avg() works\n        d1 = audioop.bias(data[0], 1, 100)\n        d2 = audioop.bias(data[1], 2, 100)\n        d4 = audioop.bias(data[2], 4, 100)\n        self.assertEqual(audioop.avg(d1, 1), 101)\n        self.assertEqual(audioop.avg(d2, 2), 101)\n        self.assertEqual(audioop.avg(d4, 4), 101)\n\n    def test_lin2lin(self):\n        # too simple: we test only the size\n        for d1 in data:\n            for d2 in data:\n                got = len(d1)//3\n                wtd = len(d2)//3\n                self.assertEqual(len(audioop.lin2lin(d1, got, wtd)), len(d2))\n\n    def test_adpcm2lin(self):\n        # Very cursory test\n        self.assertEqual(audioop.adpcm2lin('\\0\\0', 1, None), ('\\0\\0\\0\\0', (0,0)))\n\n    def test_lin2adpcm(self):\n        # Very cursory test\n        self.assertEqual(audioop.lin2adpcm('\\0\\0\\0\\0', 1, None), ('\\0\\0', (0,0)))\n\n    def test_lin2alaw(self):\n        self.assertEqual(audioop.lin2alaw(data[0], 1), '\\xd5\\xc5\\xf5')\n        self.assertEqual(audioop.lin2alaw(data[1], 2), '\\xd5\\xd5\\xd5')\n        self.assertEqual(audioop.lin2alaw(data[2], 4), '\\xd5\\xd5\\xd5')\n\n    def test_alaw2lin(self):\n        # Cursory\n        d = audioop.lin2alaw(data[0], 1)\n        self.assertEqual(audioop.alaw2lin(d, 1), data[0])\n\n    def test_lin2ulaw(self):\n        self.assertEqual(audioop.lin2ulaw(data[0], 1), '\\xff\\xe7\\xdb')\n        self.assertEqual(audioop.lin2ulaw(data[1], 2), '\\xff\\xff\\xff')\n        self.assertEqual(audioop.lin2ulaw(data[2], 4), '\\xff\\xff\\xff')\n\n    def test_ulaw2lin(self):\n        # Cursory\n        d = audioop.lin2ulaw(data[0], 1)\n        self.assertEqual(audioop.ulaw2lin(d, 1), data[0])\n\n    def test_mul(self):\n        data2 = []\n        for d in data:\n            str = ''\n            for s in d:\n                str = str + chr(ord(s)*2)\n            data2.append(str)\n        self.assertEqual(audioop.mul(data[0], 1, 2), data2[0])\n        self.assertEqual(audioop.mul(data[1],2, 2), data2[1])\n        self.assertEqual(audioop.mul(data[2], 4, 2), data2[2])\n\n    def test_ratecv(self):\n        state = None\n        d1, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        d2, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        self.assertEqual(d1 + d2, '\\000\\000\\001\\001\\002\\001\\000\\000\\001\\001\\002')\n\n    def test_reverse(self):\n        self.assertEqual(audioop.reverse(data[0], 1), '\\2\\1\\0')\n\n    def test_tomono(self):\n        data2 = ''\n        for d in data[0]:\n            data2 = data2 + d + d\n        self.assertEqual(audioop.tomono(data2, 1, 0.5, 0.5), data[0])\n\n    def test_tostereo(self):\n        data2 = ''\n        for d in data[0]:\n            data2 = data2 + d + d\n        self.assertEqual(audioop.tostereo(data[0], 1, 1, 1), data2)\n\n    def test_findfactor(self):\n        self.assertEqual(audioop.findfactor(data[1], data[1]), 1.0)\n\n    def test_findfit(self):\n        self.assertEqual(audioop.findfit(data[1], data[1]), (0, 1.0))\n\n    def test_findmax(self):\n        self.assertEqual(audioop.findmax(data[1], 1), 2)\n\n    def test_getsample(self):\n        for i in range(3):\n            self.assertEqual(audioop.getsample(data[0], 1, i), i)\n            self.assertEqual(audioop.getsample(data[1], 2, i), i)\n            self.assertEqual(audioop.getsample(data[2], 4, i), i)\n\n    def test_negativelen(self):\n        # from issue 3306, previously it segfaulted\n        self.assertRaises(audioop.error,\n            audioop.findmax, ''.join( chr(x) for x in xrange(256)), -2392392)\n\ndef test_main():\n    run_unittest(TestAudioop)\n\nif __name__ == '__main__':\n    test_main()\n",
    "code_after": "import audioop\nimport unittest\nfrom test.test_support import run_unittest\n\n\ndef gendata1():\n    return '\\0\\1\\2'\n\ndef gendata2():\n    if audioop.getsample('\\0\\1', 2, 0) == 1:\n        return '\\0\\0\\0\\1\\0\\2'\n    else:\n        return '\\0\\0\\1\\0\\2\\0'\n\ndef gendata4():\n    if audioop.getsample('\\0\\0\\0\\1', 4, 0) == 1:\n        return '\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\2'\n    else:\n        return '\\0\\0\\0\\0\\1\\0\\0\\0\\2\\0\\0\\0'\n\ndata = [gendata1(), gendata2(), gendata4()]\n\nINVALID_DATA = [\n    ('abc', 0),\n    ('abc', 2),\n    ('abc', 4),\n]\n\n\nclass TestAudioop(unittest.TestCase):\n\n    def test_max(self):\n        self.assertEqual(audioop.max(data[0], 1), 2)\n        self.assertEqual(audioop.max(data[1], 2), 2)\n        self.assertEqual(audioop.max(data[2], 4), 2)\n\n    def test_minmax(self):\n        self.assertEqual(audioop.minmax(data[0], 1), (0, 2))\n        self.assertEqual(audioop.minmax(data[1], 2), (0, 2))\n        self.assertEqual(audioop.minmax(data[2], 4), (0, 2))\n\n    def test_maxpp(self):\n        self.assertEqual(audioop.maxpp(data[0], 1), 0)\n        self.assertEqual(audioop.maxpp(data[1], 2), 0)\n        self.assertEqual(audioop.maxpp(data[2], 4), 0)\n\n    def test_avg(self):\n        self.assertEqual(audioop.avg(data[0], 1), 1)\n        self.assertEqual(audioop.avg(data[1], 2), 1)\n        self.assertEqual(audioop.avg(data[2], 4), 1)\n\n    def test_avgpp(self):\n        self.assertEqual(audioop.avgpp(data[0], 1), 0)\n        self.assertEqual(audioop.avgpp(data[1], 2), 0)\n        self.assertEqual(audioop.avgpp(data[2], 4), 0)\n\n    def test_rms(self):\n        self.assertEqual(audioop.rms(data[0], 1), 1)\n        self.assertEqual(audioop.rms(data[1], 2), 1)\n        self.assertEqual(audioop.rms(data[2], 4), 1)\n\n    def test_cross(self):\n        self.assertEqual(audioop.cross(data[0], 1), 0)\n        self.assertEqual(audioop.cross(data[1], 2), 0)\n        self.assertEqual(audioop.cross(data[2], 4), 0)\n\n    def test_add(self):\n        data2 = []\n        for d in data:\n            str = ''\n            for s in d:\n                str = str + chr(ord(s)*2)\n            data2.append(str)\n        self.assertEqual(audioop.add(data[0], data[0], 1), data2[0])\n        self.assertEqual(audioop.add(data[1], data[1], 2), data2[1])\n        self.assertEqual(audioop.add(data[2], data[2], 4), data2[2])\n\n    def test_bias(self):\n        # Note: this test assumes that avg() works\n        d1 = audioop.bias(data[0], 1, 100)\n        d2 = audioop.bias(data[1], 2, 100)\n        d4 = audioop.bias(data[2], 4, 100)\n        self.assertEqual(audioop.avg(d1, 1), 101)\n        self.assertEqual(audioop.avg(d2, 2), 101)\n        self.assertEqual(audioop.avg(d4, 4), 101)\n\n    def test_lin2lin(self):\n        # too simple: we test only the size\n        for d1 in data:\n            for d2 in data:\n                got = len(d1)//3\n                wtd = len(d2)//3\n                self.assertEqual(len(audioop.lin2lin(d1, got, wtd)), len(d2))\n\n    def test_adpcm2lin(self):\n        # Very cursory test\n        self.assertEqual(audioop.adpcm2lin('\\0\\0', 1, None), ('\\0\\0\\0\\0', (0,0)))\n\n    def test_lin2adpcm(self):\n        # Very cursory test\n        self.assertEqual(audioop.lin2adpcm('\\0\\0\\0\\0', 1, None), ('\\0\\0', (0,0)))\n\n    def test_lin2alaw(self):\n        self.assertEqual(audioop.lin2alaw(data[0], 1), '\\xd5\\xc5\\xf5')\n        self.assertEqual(audioop.lin2alaw(data[1], 2), '\\xd5\\xd5\\xd5')\n        self.assertEqual(audioop.lin2alaw(data[2], 4), '\\xd5\\xd5\\xd5')\n\n    def test_alaw2lin(self):\n        # Cursory\n        d = audioop.lin2alaw(data[0], 1)\n        self.assertEqual(audioop.alaw2lin(d, 1), data[0])\n\n    def test_lin2ulaw(self):\n        self.assertEqual(audioop.lin2ulaw(data[0], 1), '\\xff\\xe7\\xdb')\n        self.assertEqual(audioop.lin2ulaw(data[1], 2), '\\xff\\xff\\xff')\n        self.assertEqual(audioop.lin2ulaw(data[2], 4), '\\xff\\xff\\xff')\n\n    def test_ulaw2lin(self):\n        # Cursory\n        d = audioop.lin2ulaw(data[0], 1)\n        self.assertEqual(audioop.ulaw2lin(d, 1), data[0])\n\n    def test_mul(self):\n        data2 = []\n        for d in data:\n            str = ''\n            for s in d:\n                str = str + chr(ord(s)*2)\n            data2.append(str)\n        self.assertEqual(audioop.mul(data[0], 1, 2), data2[0])\n        self.assertEqual(audioop.mul(data[1],2, 2), data2[1])\n        self.assertEqual(audioop.mul(data[2], 4, 2), data2[2])\n\n    def test_ratecv(self):\n        state = None\n        d1, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        d2, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        self.assertEqual(d1 + d2, '\\000\\000\\001\\001\\002\\001\\000\\000\\001\\001\\002')\n\n    def test_reverse(self):\n        self.assertEqual(audioop.reverse(data[0], 1), '\\2\\1\\0')\n\n    def test_tomono(self):\n        data2 = ''\n        for d in data[0]:\n            data2 = data2 + d + d\n        self.assertEqual(audioop.tomono(data2, 1, 0.5, 0.5), data[0])\n\n    def test_tostereo(self):\n        data2 = ''\n        for d in data[0]:\n            data2 = data2 + d + d\n        self.assertEqual(audioop.tostereo(data[0], 1, 1, 1), data2)\n\n    def test_findfactor(self):\n        self.assertEqual(audioop.findfactor(data[1], data[1]), 1.0)\n\n    def test_findfit(self):\n        self.assertEqual(audioop.findfit(data[1], data[1]), (0, 1.0))\n\n    def test_findmax(self):\n        self.assertEqual(audioop.findmax(data[1], 1), 2)\n\n    def test_getsample(self):\n        for i in range(3):\n            self.assertEqual(audioop.getsample(data[0], 1, i), i)\n            self.assertEqual(audioop.getsample(data[1], 2, i), i)\n            self.assertEqual(audioop.getsample(data[2], 4, i), i)\n\n    def test_negativelen(self):\n        # from issue 3306, previously it segfaulted\n        self.assertRaises(audioop.error,\n            audioop.findmax, ''.join( chr(x) for x in xrange(256)), -2392392)\n\n    def test_issue7673(self):\n        state = None\n        for data, size in INVALID_DATA:\n            size2 = size\n            self.assertRaises(audioop.error, audioop.getsample, data, size, 0)\n            self.assertRaises(audioop.error, audioop.max, data, size)\n            self.assertRaises(audioop.error, audioop.minmax, data, size)\n            self.assertRaises(audioop.error, audioop.avg, data, size)\n            self.assertRaises(audioop.error, audioop.rms, data, size)\n            self.assertRaises(audioop.error, audioop.avgpp, data, size)\n            self.assertRaises(audioop.error, audioop.maxpp, data, size)\n            self.assertRaises(audioop.error, audioop.cross, data, size)\n            self.assertRaises(audioop.error, audioop.mul, data, size, 1.0)\n            self.assertRaises(audioop.error, audioop.tomono, data, size, 0.5, 0.5)\n            self.assertRaises(audioop.error, audioop.tostereo, data, size, 0.5, 0.5)\n            self.assertRaises(audioop.error, audioop.add, data, data, size)\n            self.assertRaises(audioop.error, audioop.bias, data, size, 0)\n            self.assertRaises(audioop.error, audioop.reverse, data, size)\n            self.assertRaises(audioop.error, audioop.lin2lin, data, size, size2)\n            self.assertRaises(audioop.error, audioop.ratecv, data, size, 1, 1, 1, state)\n            self.assertRaises(audioop.error, audioop.lin2ulaw, data, size)\n            self.assertRaises(audioop.error, audioop.ulaw2lin, data, size)\n            self.assertRaises(audioop.error, audioop.lin2alaw, data, size)\n            self.assertRaises(audioop.error, audioop.alaw2lin, data, size)\n            self.assertRaises(audioop.error, audioop.lin2adpcm, data, size, state)\n            self.assertRaises(audioop.error, audioop.adpcm2lin, data, size, state)\n\ndef test_main():\n    run_unittest(TestAudioop)\n\nif __name__ == '__main__':\n    test_main()\n"
  },
  {
    "patch": "diff --git a/Lib/test/test_audioop.py b/Lib/test/test_audioop.py\nindex 7bc2cd67d51..e03ceb5b145 100644\n--- a/Lib/test/test_audioop.py\n+++ b/Lib/test/test_audioop.py\n@@ -20,6 +20,12 @@ def gendata4():\n \n data = [gendata1(), gendata2(), gendata4()]\n \n+INVALID_DATA = [\n+    ('abc', 0),\n+    ('abc', 2),\n+    ('abc', 4),\n+]\n+\n \n class TestAudioop(unittest.TestCase):\n \n@@ -166,6 +172,33 @@ def test_negativelen(self):\n         self.assertRaises(audioop.error,\n             audioop.findmax, ''.join( chr(x) for x in xrange(256)), -2392392)\n \n+    def test_issue7673(self):\n+        state = None\n+        for data, size in INVALID_DATA:\n+            size2 = size\n+            self.assertRaises(audioop.error, audioop.getsample, data, size, 0)\n+            self.assertRaises(audioop.error, audioop.max, data, size)\n+            self.assertRaises(audioop.error, audioop.minmax, data, size)\n+            self.assertRaises(audioop.error, audioop.avg, data, size)\n+            self.assertRaises(audioop.error, audioop.rms, data, size)\n+            self.assertRaises(audioop.error, audioop.avgpp, data, size)\n+            self.assertRaises(audioop.error, audioop.maxpp, data, size)\n+            self.assertRaises(audioop.error, audioop.cross, data, size)\n+            self.assertRaises(audioop.error, audioop.mul, data, size, 1.0)\n+            self.assertRaises(audioop.error, audioop.tomono, data, size, 0.5, 0.5)\n+            self.assertRaises(audioop.error, audioop.tostereo, data, size, 0.5, 0.5)\n+            self.assertRaises(audioop.error, audioop.add, data, data, size)\n+            self.assertRaises(audioop.error, audioop.bias, data, size, 0)\n+            self.assertRaises(audioop.error, audioop.reverse, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2lin, data, size, size2)\n+            self.assertRaises(audioop.error, audioop.ratecv, data, size, 1, 1, 1, state)\n+            self.assertRaises(audioop.error, audioop.lin2ulaw, data, size)\n+            self.assertRaises(audioop.error, audioop.ulaw2lin, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2alaw, data, size)\n+            self.assertRaises(audioop.error, audioop.alaw2lin, data, size)\n+            self.assertRaises(audioop.error, audioop.lin2adpcm, data, size, state)\n+            self.assertRaises(audioop.error, audioop.adpcm2lin, data, size, state)\n+\n def test_main():\n     run_unittest(TestAudioop)\n \n",
    "commit_message": "Issue #7673: Fix security vulnerability (CVE-2010-2089) in the audioop module,\nensure that the input string length is a multiple of the frame size\n\n",
    "code_before": "import audioop\nimport unittest\nfrom test.test_support import run_unittest\n\n\ndef gendata1():\n    return '\\0\\1\\2'\n\ndef gendata2():\n    if audioop.getsample('\\0\\1', 2, 0) == 1:\n        return '\\0\\0\\0\\1\\0\\2'\n    else:\n        return '\\0\\0\\1\\0\\2\\0'\n\ndef gendata4():\n    if audioop.getsample('\\0\\0\\0\\1', 4, 0) == 1:\n        return '\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\2'\n    else:\n        return '\\0\\0\\0\\0\\1\\0\\0\\0\\2\\0\\0\\0'\n\ndata = [gendata1(), gendata2(), gendata4()]\n\n\nclass TestAudioop(unittest.TestCase):\n\n    def test_max(self):\n        self.assertEqual(audioop.max(data[0], 1), 2)\n        self.assertEqual(audioop.max(data[1], 2), 2)\n        self.assertEqual(audioop.max(data[2], 4), 2)\n\n    def test_minmax(self):\n        self.assertEqual(audioop.minmax(data[0], 1), (0, 2))\n        self.assertEqual(audioop.minmax(data[1], 2), (0, 2))\n        self.assertEqual(audioop.minmax(data[2], 4), (0, 2))\n\n    def test_maxpp(self):\n        self.assertEqual(audioop.maxpp(data[0], 1), 0)\n        self.assertEqual(audioop.maxpp(data[1], 2), 0)\n        self.assertEqual(audioop.maxpp(data[2], 4), 0)\n\n    def test_avg(self):\n        self.assertEqual(audioop.avg(data[0], 1), 1)\n        self.assertEqual(audioop.avg(data[1], 2), 1)\n        self.assertEqual(audioop.avg(data[2], 4), 1)\n\n    def test_avgpp(self):\n        self.assertEqual(audioop.avgpp(data[0], 1), 0)\n        self.assertEqual(audioop.avgpp(data[1], 2), 0)\n        self.assertEqual(audioop.avgpp(data[2], 4), 0)\n\n    def test_rms(self):\n        self.assertEqual(audioop.rms(data[0], 1), 1)\n        self.assertEqual(audioop.rms(data[1], 2), 1)\n        self.assertEqual(audioop.rms(data[2], 4), 1)\n\n    def test_cross(self):\n        self.assertEqual(audioop.cross(data[0], 1), 0)\n        self.assertEqual(audioop.cross(data[1], 2), 0)\n        self.assertEqual(audioop.cross(data[2], 4), 0)\n\n    def test_add(self):\n        data2 = []\n        for d in data:\n            str = ''\n            for s in d:\n                str = str + chr(ord(s)*2)\n            data2.append(str)\n        self.assertEqual(audioop.add(data[0], data[0], 1), data2[0])\n        self.assertEqual(audioop.add(data[1], data[1], 2), data2[1])\n        self.assertEqual(audioop.add(data[2], data[2], 4), data2[2])\n\n    def test_bias(self):\n        # Note: this test assumes that avg() works\n        d1 = audioop.bias(data[0], 1, 100)\n        d2 = audioop.bias(data[1], 2, 100)\n        d4 = audioop.bias(data[2], 4, 100)\n        self.assertEqual(audioop.avg(d1, 1), 101)\n        self.assertEqual(audioop.avg(d2, 2), 101)\n        self.assertEqual(audioop.avg(d4, 4), 101)\n\n    def test_lin2lin(self):\n        # too simple: we test only the size\n        for d1 in data:\n            for d2 in data:\n                got = len(d1)//3\n                wtd = len(d2)//3\n                self.assertEqual(len(audioop.lin2lin(d1, got, wtd)), len(d2))\n\n    def test_adpcm2lin(self):\n        # Very cursory test\n        self.assertEqual(audioop.adpcm2lin('\\0\\0', 1, None), ('\\0\\0\\0\\0', (0,0)))\n\n    def test_lin2adpcm(self):\n        # Very cursory test\n        self.assertEqual(audioop.lin2adpcm('\\0\\0\\0\\0', 1, None), ('\\0\\0', (0,0)))\n\n    def test_lin2alaw(self):\n        self.assertEqual(audioop.lin2alaw(data[0], 1), '\\xd5\\xc5\\xf5')\n        self.assertEqual(audioop.lin2alaw(data[1], 2), '\\xd5\\xd5\\xd5')\n        self.assertEqual(audioop.lin2alaw(data[2], 4), '\\xd5\\xd5\\xd5')\n\n    def test_alaw2lin(self):\n        # Cursory\n        d = audioop.lin2alaw(data[0], 1)\n        self.assertEqual(audioop.alaw2lin(d, 1), data[0])\n\n    def test_lin2ulaw(self):\n        self.assertEqual(audioop.lin2ulaw(data[0], 1), '\\xff\\xe7\\xdb')\n        self.assertEqual(audioop.lin2ulaw(data[1], 2), '\\xff\\xff\\xff')\n        self.assertEqual(audioop.lin2ulaw(data[2], 4), '\\xff\\xff\\xff')\n\n    def test_ulaw2lin(self):\n        # Cursory\n        d = audioop.lin2ulaw(data[0], 1)\n        self.assertEqual(audioop.ulaw2lin(d, 1), data[0])\n\n    def test_mul(self):\n        data2 = []\n        for d in data:\n            str = ''\n            for s in d:\n                str = str + chr(ord(s)*2)\n            data2.append(str)\n        self.assertEqual(audioop.mul(data[0], 1, 2), data2[0])\n        self.assertEqual(audioop.mul(data[1],2, 2), data2[1])\n        self.assertEqual(audioop.mul(data[2], 4, 2), data2[2])\n\n    def test_ratecv(self):\n        state = None\n        d1, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        d2, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        self.assertEqual(d1 + d2, '\\000\\000\\001\\001\\002\\001\\000\\000\\001\\001\\002')\n\n    def test_reverse(self):\n        self.assertEqual(audioop.reverse(data[0], 1), '\\2\\1\\0')\n\n    def test_tomono(self):\n        data2 = ''\n        for d in data[0]:\n            data2 = data2 + d + d\n        self.assertEqual(audioop.tomono(data2, 1, 0.5, 0.5), data[0])\n\n    def test_tostereo(self):\n        data2 = ''\n        for d in data[0]:\n            data2 = data2 + d + d\n        self.assertEqual(audioop.tostereo(data[0], 1, 1, 1), data2)\n\n    def test_findfactor(self):\n        self.assertEqual(audioop.findfactor(data[1], data[1]), 1.0)\n\n    def test_findfit(self):\n        self.assertEqual(audioop.findfit(data[1], data[1]), (0, 1.0))\n\n    def test_findmax(self):\n        self.assertEqual(audioop.findmax(data[1], 1), 2)\n\n    def test_getsample(self):\n        for i in range(3):\n            self.assertEqual(audioop.getsample(data[0], 1, i), i)\n            self.assertEqual(audioop.getsample(data[1], 2, i), i)\n            self.assertEqual(audioop.getsample(data[2], 4, i), i)\n\n    def test_negativelen(self):\n        # from issue 3306, previously it segfaulted\n        self.assertRaises(audioop.error,\n            audioop.findmax, ''.join( chr(x) for x in xrange(256)), -2392392)\n\ndef test_main():\n    run_unittest(TestAudioop)\n\nif __name__ == '__main__':\n    test_main()\n",
    "code_after": "import audioop\nimport unittest\nfrom test.test_support import run_unittest\n\n\ndef gendata1():\n    return '\\0\\1\\2'\n\ndef gendata2():\n    if audioop.getsample('\\0\\1', 2, 0) == 1:\n        return '\\0\\0\\0\\1\\0\\2'\n    else:\n        return '\\0\\0\\1\\0\\2\\0'\n\ndef gendata4():\n    if audioop.getsample('\\0\\0\\0\\1', 4, 0) == 1:\n        return '\\0\\0\\0\\0\\0\\0\\0\\1\\0\\0\\0\\2'\n    else:\n        return '\\0\\0\\0\\0\\1\\0\\0\\0\\2\\0\\0\\0'\n\ndata = [gendata1(), gendata2(), gendata4()]\n\nINVALID_DATA = [\n    ('abc', 0),\n    ('abc', 2),\n    ('abc', 4),\n]\n\n\nclass TestAudioop(unittest.TestCase):\n\n    def test_max(self):\n        self.assertEqual(audioop.max(data[0], 1), 2)\n        self.assertEqual(audioop.max(data[1], 2), 2)\n        self.assertEqual(audioop.max(data[2], 4), 2)\n\n    def test_minmax(self):\n        self.assertEqual(audioop.minmax(data[0], 1), (0, 2))\n        self.assertEqual(audioop.minmax(data[1], 2), (0, 2))\n        self.assertEqual(audioop.minmax(data[2], 4), (0, 2))\n\n    def test_maxpp(self):\n        self.assertEqual(audioop.maxpp(data[0], 1), 0)\n        self.assertEqual(audioop.maxpp(data[1], 2), 0)\n        self.assertEqual(audioop.maxpp(data[2], 4), 0)\n\n    def test_avg(self):\n        self.assertEqual(audioop.avg(data[0], 1), 1)\n        self.assertEqual(audioop.avg(data[1], 2), 1)\n        self.assertEqual(audioop.avg(data[2], 4), 1)\n\n    def test_avgpp(self):\n        self.assertEqual(audioop.avgpp(data[0], 1), 0)\n        self.assertEqual(audioop.avgpp(data[1], 2), 0)\n        self.assertEqual(audioop.avgpp(data[2], 4), 0)\n\n    def test_rms(self):\n        self.assertEqual(audioop.rms(data[0], 1), 1)\n        self.assertEqual(audioop.rms(data[1], 2), 1)\n        self.assertEqual(audioop.rms(data[2], 4), 1)\n\n    def test_cross(self):\n        self.assertEqual(audioop.cross(data[0], 1), 0)\n        self.assertEqual(audioop.cross(data[1], 2), 0)\n        self.assertEqual(audioop.cross(data[2], 4), 0)\n\n    def test_add(self):\n        data2 = []\n        for d in data:\n            str = ''\n            for s in d:\n                str = str + chr(ord(s)*2)\n            data2.append(str)\n        self.assertEqual(audioop.add(data[0], data[0], 1), data2[0])\n        self.assertEqual(audioop.add(data[1], data[1], 2), data2[1])\n        self.assertEqual(audioop.add(data[2], data[2], 4), data2[2])\n\n    def test_bias(self):\n        # Note: this test assumes that avg() works\n        d1 = audioop.bias(data[0], 1, 100)\n        d2 = audioop.bias(data[1], 2, 100)\n        d4 = audioop.bias(data[2], 4, 100)\n        self.assertEqual(audioop.avg(d1, 1), 101)\n        self.assertEqual(audioop.avg(d2, 2), 101)\n        self.assertEqual(audioop.avg(d4, 4), 101)\n\n    def test_lin2lin(self):\n        # too simple: we test only the size\n        for d1 in data:\n            for d2 in data:\n                got = len(d1)//3\n                wtd = len(d2)//3\n                self.assertEqual(len(audioop.lin2lin(d1, got, wtd)), len(d2))\n\n    def test_adpcm2lin(self):\n        # Very cursory test\n        self.assertEqual(audioop.adpcm2lin('\\0\\0', 1, None), ('\\0\\0\\0\\0', (0,0)))\n\n    def test_lin2adpcm(self):\n        # Very cursory test\n        self.assertEqual(audioop.lin2adpcm('\\0\\0\\0\\0', 1, None), ('\\0\\0', (0,0)))\n\n    def test_lin2alaw(self):\n        self.assertEqual(audioop.lin2alaw(data[0], 1), '\\xd5\\xc5\\xf5')\n        self.assertEqual(audioop.lin2alaw(data[1], 2), '\\xd5\\xd5\\xd5')\n        self.assertEqual(audioop.lin2alaw(data[2], 4), '\\xd5\\xd5\\xd5')\n\n    def test_alaw2lin(self):\n        # Cursory\n        d = audioop.lin2alaw(data[0], 1)\n        self.assertEqual(audioop.alaw2lin(d, 1), data[0])\n\n    def test_lin2ulaw(self):\n        self.assertEqual(audioop.lin2ulaw(data[0], 1), '\\xff\\xe7\\xdb')\n        self.assertEqual(audioop.lin2ulaw(data[1], 2), '\\xff\\xff\\xff')\n        self.assertEqual(audioop.lin2ulaw(data[2], 4), '\\xff\\xff\\xff')\n\n    def test_ulaw2lin(self):\n        # Cursory\n        d = audioop.lin2ulaw(data[0], 1)\n        self.assertEqual(audioop.ulaw2lin(d, 1), data[0])\n\n    def test_mul(self):\n        data2 = []\n        for d in data:\n            str = ''\n            for s in d:\n                str = str + chr(ord(s)*2)\n            data2.append(str)\n        self.assertEqual(audioop.mul(data[0], 1, 2), data2[0])\n        self.assertEqual(audioop.mul(data[1],2, 2), data2[1])\n        self.assertEqual(audioop.mul(data[2], 4, 2), data2[2])\n\n    def test_ratecv(self):\n        state = None\n        d1, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        d2, state = audioop.ratecv(data[0], 1, 1, 8000, 16000, state)\n        self.assertEqual(d1 + d2, '\\000\\000\\001\\001\\002\\001\\000\\000\\001\\001\\002')\n\n    def test_reverse(self):\n        self.assertEqual(audioop.reverse(data[0], 1), '\\2\\1\\0')\n\n    def test_tomono(self):\n        data2 = ''\n        for d in data[0]:\n            data2 = data2 + d + d\n        self.assertEqual(audioop.tomono(data2, 1, 0.5, 0.5), data[0])\n\n    def test_tostereo(self):\n        data2 = ''\n        for d in data[0]:\n            data2 = data2 + d + d\n        self.assertEqual(audioop.tostereo(data[0], 1, 1, 1), data2)\n\n    def test_findfactor(self):\n        self.assertEqual(audioop.findfactor(data[1], data[1]), 1.0)\n\n    def test_findfit(self):\n        self.assertEqual(audioop.findfit(data[1], data[1]), (0, 1.0))\n\n    def test_findmax(self):\n        self.assertEqual(audioop.findmax(data[1], 1), 2)\n\n    def test_getsample(self):\n        for i in range(3):\n            self.assertEqual(audioop.getsample(data[0], 1, i), i)\n            self.assertEqual(audioop.getsample(data[1], 2, i), i)\n            self.assertEqual(audioop.getsample(data[2], 4, i), i)\n\n    def test_negativelen(self):\n        # from issue 3306, previously it segfaulted\n        self.assertRaises(audioop.error,\n            audioop.findmax, ''.join( chr(x) for x in xrange(256)), -2392392)\n\n    def test_issue7673(self):\n        state = None\n        for data, size in INVALID_DATA:\n            size2 = size\n            self.assertRaises(audioop.error, audioop.getsample, data, size, 0)\n            self.assertRaises(audioop.error, audioop.max, data, size)\n            self.assertRaises(audioop.error, audioop.minmax, data, size)\n            self.assertRaises(audioop.error, audioop.avg, data, size)\n            self.assertRaises(audioop.error, audioop.rms, data, size)\n            self.assertRaises(audioop.error, audioop.avgpp, data, size)\n            self.assertRaises(audioop.error, audioop.maxpp, data, size)\n            self.assertRaises(audioop.error, audioop.cross, data, size)\n            self.assertRaises(audioop.error, audioop.mul, data, size, 1.0)\n            self.assertRaises(audioop.error, audioop.tomono, data, size, 0.5, 0.5)\n            self.assertRaises(audioop.error, audioop.tostereo, data, size, 0.5, 0.5)\n            self.assertRaises(audioop.error, audioop.add, data, data, size)\n            self.assertRaises(audioop.error, audioop.bias, data, size, 0)\n            self.assertRaises(audioop.error, audioop.reverse, data, size)\n            self.assertRaises(audioop.error, audioop.lin2lin, data, size, size2)\n            self.assertRaises(audioop.error, audioop.ratecv, data, size, 1, 1, 1, state)\n            self.assertRaises(audioop.error, audioop.lin2ulaw, data, size)\n            self.assertRaises(audioop.error, audioop.ulaw2lin, data, size)\n            self.assertRaises(audioop.error, audioop.lin2alaw, data, size)\n            self.assertRaises(audioop.error, audioop.alaw2lin, data, size)\n            self.assertRaises(audioop.error, audioop.lin2adpcm, data, size, state)\n            self.assertRaises(audioop.error, audioop.adpcm2lin, data, size, state)\n\ndef test_main():\n    run_unittest(TestAudioop)\n\nif __name__ == '__main__':\n    test_main()\n"
  }
]
